---
layout: post
title: '常用算法大全（代码）'
date: 2020-09-05
author: 李大鹏
cover: ''
tags: 算法
---

# 目录

## 1. 数据结构篇

- [二叉树](#1-二叉树)
- [链表](#2-链表)
- [栈和队列](#3-栈和队列)
- [二进制](#4-二进制)

## 2. 基础算法篇

- [二分搜索](#1-二分搜索)
- [排序算法](#2-排序算法)
- [动态规划](#3-动态规划)

## 3. 三、算法思维

- [递归思维](#1-递归思维)
- [滑动窗口思想](#2-滑动窗口思想)
- [二叉搜索树](#3-二叉搜索树)
- [回溯法](#4-回溯法)

# 一、数据结构篇

## 1. 二叉树

- [构建二叉树](#0-构建二叉树)
- [二叉树的最大深度](#1-二叉树的最大深度)
- [平衡二叉树](#2-平衡二叉树)
- [二叉树中的最大路径和](#3-二叉树中的最大路径和)
- [二叉树的最近公共祖先](#4-二叉树的最近公共祖先)
- [二叉树的层序遍历](#5-二叉树的层序遍历)
- [二叉树的层次遍历-2](#6-二叉树的层次遍历-2)
- [二叉树的锯齿形层次遍历](#7-二叉树的锯齿形层次遍历)
- [验证二叉搜索树](#8-验证二叉搜索树)
- [二叉搜索树中的插入操作](#9-二叉搜索树中的插入操作)

## 2. 链表

- [删除排序链表中的重复元素](#10-删除排序链表中的重复元素)
- [删除排序链表中的重复元素-2](#11-删除排序链表中的重复元素-2)
- [反转链表](#12-反转链表)
- [反转链表-2](#13-反转链表-2)
- [合并两个有序链表](#14-合并两个有序链表)
- [分隔链表](#15-分隔链表)
- [排序链表](#16-排序链表)
- [重排链表](#17-重排链表)
- [环形链表](#18-环形链表)
- [环形链表-2](#19-环形链表-2)
- [回文链表](#20-回文链表)
- [复制带随机指针的链表](#21-复制带随机指针的链表)

## 3. 栈和队列

- [最小栈](#22-最小栈)
- [逆波兰表达式求值](#23-逆波兰表达式求值)
- [字符串解码](#24-字符串解码)
- [二叉树的中序遍历](#25-二叉树的中序遍历)
- [克隆图](#26-克隆图)
- [岛屿数量](#27-岛屿数量)
- [柱状图中最大的矩形](#28-柱状图中最大的矩形)
- [用栈实现队列](#29-用栈实现队列)
- [01 矩阵](#30-01-矩阵)

### 4. 二进制

- [只出现一次的数字](#31-只出现一次的数字)
- [只出现一次的数字-2](#32-只出现一次的数字-2)
- [位 1 的个数](#33-位1的个数)
- [比特位计数](#34-比特位计数)
- [比特位计数](#35-比特位计数)
- [颠倒二进制位](#36-颠倒二进制位)

# 二、基础算法篇

## 1. 二分搜索

- [搜索区间](#37-搜索区间)
- [搜索插入位置](#38-搜索插入位置)
- [搜索二维矩阵](#39-搜索二维矩阵)
- [第一个错误的版本](#40-第一个错误的版本)
- [寻找旋转排序数组中的最小值](#41-寻找旋转排序数组中的最小值)
- [寻找旋转排序数组中的最小值-2](#42-寻找旋转排序数组中的最小值-2)
- [搜索旋转排序数组](#43-搜索旋转排序数组)
- [搜索旋转排序数组-2](#44-搜索旋转排序数组-2)

## 2. 排序算法

- [十大经典排序](#45-十大经典排序)
- [快速排序](#46-快速排序)
- [堆排序](#46-堆排序)
- [冒泡排序](#46-冒泡排序)

## 3. 动态规划

### Matrix DP (10%)

- [三角形最小路径和](#47-三角形最小路径和)
- [最小路径和](#48-最小路径和)
- [不同路径](#49-不同路径)
- [不同路径-2](#50-不同路径-2)
- [安卓系统手势解锁](#80-安卓系统手势解锁)

### Sequence (40%)

- [爬楼梯](#51-爬楼梯)
- [跳跃游戏](#52-跳跃游戏)
- [跳跃游戏-2](#53-跳跃游戏-2)
- [分割回文串-2](#54-分割回文串-2)
- [最长上升子序列](#55-最长上升子序列)
- [单词拆分](#56-单词拆分)

### Two Sequences DP (40%)

- [最长公共子序列](#57-最长公共子序列)
- [编辑距离](#58-编辑距离)

### Backpack & Coin Change (10%)

- [零钱兑换](#59-零钱兑换)
- [背包问题](#60-背包问题)
- [背包问题-2](#61-背包问题-2)

### 三、算法思维

## 1. 递归思维

- [反转字符串](#62-反转字符串)
- [两两交换链表中的节点](#63-两两交换链表中的节点)
- [不同的二叉搜索树-2](#64-不同的二叉搜索树-2)
- [斐波那契数](#65-斐波那契数)

## 2. 滑动窗口思想

- [最小覆盖子串](#66-最小覆盖子串)
- [字符串的排列](#67-字符串的排列)
- [找到字符串中所有字母异位词](#68-找到字符串中所有字母异位词)
- [无重复字符的最长子串](#69-无重复字符的最长子串)

## 3. 二叉搜索树

- [删除二叉搜索树中的节点](#70-删除二叉搜索树中的节点)

## 4. 回溯法

- [子集](#71-子集)
- [子集-2](#72-子集-2)
- [全排列](#73-全排列)
- [全排列-2](#74-全排列-2)

### 挑战题目

- [组合总和](#75-组合总和)
- [电话号码的字母组合](#76-电话号码的字母组合)
- [分割回文串](#77-分割回文串)
- [复原 IP 地址](#78-复原IP地址)
- [全排列](#79-全排列)

# 代码

## 一、数据结构篇

### 1. 二叉树

#### 0. 构建二叉树

```Swift
// 构建二叉树
public class TreeNode {
    public var val: Int
    public var left: TreeNode?
    public var right: TreeNode?
    public init(_ val: Int) {
        self.val = val
        self.left = nil
        self.right = nil
    }
}

var indexMap: [Int: Int] = [:]

func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {
    for i in inorder.indices { indexMap[inorder[i]] = i }
    return fBuildTree(preorder: preorder, inorder: inorder, preLeft: 0, preRight: preorder.count - 1, inLeft: 0, inRight: inorder.count - 1)
}

func fBuildTree(preorder: [Int], inorder: [Int], preLeft: Int, preRight: Int, inLeft: Int, inRight: Int) -> TreeNode? {

    if preLeft > preRight { return nil }

    // 前序遍历中的第一个节点就是根节点
    let preRoot = preLeft
    // 获取中序遍历的根结点位置
    let inRoot = indexMap[preorder[preRoot]]!
    // 创建根结点
    let root = TreeNode(preorder[preRoot])
    // 获取左子树中的节点数目
    let leftCount = inRoot - inLeft
    // 递归构造左子树,并连接到根节点
    root.left = fBuildTree(preorder: preorder, inorder: inorder, preLeft: preLeft + 1, preRight: preLeft + leftCount, inLeft: inLeft, inRight: inRoot - 1)
    // 递归构造右子树,并连接到根节点
    root.right = fBuildTree(preorder: preorder, inorder: inorder, preLeft: preLeft + leftCount + 1, preRight: preRight, inLeft: inRoot + 1, inRight: inRight)

    return root
}

//     3
//    / \
//   9  20
//  /     \
// 15      7

let preorder = [3,9,20,15,7]
let inorder = [9,3,15,20,7]

let node = buildTree(preorder, inorder)
print(node?.right?.right?.val)
```

#### 1. 二叉树的最大深度

```Swift

func maxDepth(_ root: TreeNode?) -> Int {
    if root == nil { return 0 }
    return max(maxDepth(root?.left) + 1, maxDepth(root?.right) + 1)
}
```

#### 2. 平衡二叉树

```Swift
func isBalanced(_ root: TreeNode?) -> Bool {

    if root == nil {
            return true}
        else {
            return 1 >= abs(maxDepth(root?.left) - maxDepth(root?.right)) && isBalanced(root?.left) && isBalanced(root?.right)
        }
    }

    func maxDepth(_ root: TreeNode?) -> Int {
        if root == nil { return 0 }
        return max(maxDepth(root?.left) + 1, maxDepth(root?.right) + 1)
    }
}
```

#### 3. 二叉树中的最大路径和

```Swift
var maxSum = Int.min

func maxPathSum(_ root: TreeNode?) -> Int {

    maxPath(root)
    return maxSum

}

func maxPath(_ node: TreeNode?) -> Int {

    if node == nil {
        return 0
    }

    let left = max(maxPath(node?.left), 0)
    let right = max(maxPath(node?.right), 0)

    let pathSum = node!.val + left + right
    maxSum = max(pathSum, maxSum)

    return node!.val + max(left, right)

}
```

#### 4. 二叉树的最近公共祖先

```Swift
var ans: TreeNode?
var p: TreeNode?
var q: TreeNode?

func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {
    self.p = p
    self.q = q
    dfs(root)
    return ans
}

func dfs(_ root: TreeNode?) -> Bool {
    if root == nil { return false}
    let left = dfs(root?.left)
    let right = dfs(root?.right)
    if left && right || (root?.val == p?.val || root?.val == q?.val) && (left || right) {
        ans = root
    }
    return left || right || (root?.val == p?.val || root?.val == q?.val)
}

```

#### 5. 二叉树的层序遍历

```Swift
func levelOrder(_ root: TreeNode?) -> [[Int]] {

    guard let root = root else {
        return []
    }

    var currentNode : [TreeNode] = [root]
    var nextNode = [TreeNode]()
    var result = [[Int]]()

    while currentNode.isEmpty == false {

        var levelVal = [Int]()

        for node in currentNode {

            levelVal.append(node.val)
            if let left = node.left {
                nextNode.append(left)
            }

            if let right = node.right {
                nextNode.append(right)
            }
        }

        result.append(levelVal)
        currentNode = nextNode
        nextNode = []

    }

    return result()
}
```

#### 6. 二叉树的层次遍历-2

```Swift
// 5. + result.reversed()
```

#### 7. 二叉树的锯齿形层次遍历

```Swift
// 5. 0 or n-idx
```

#### 8. 验证二叉搜索树

```Swift

func helper(_ root: TreeNode?, _ lower: Int, _ upper: Int) -> Bool {

    guard let root = root else { return true }

    if root.val <= lower || root.val >= upper {
        return false
    }

    return helper(root.left, lower, root.val) && helper(root.right, root.val, upper)

}

func isValidBST(_ root: TreeNode?) -> Bool {

    return helper(root, Int.min, Int.max)

}
```

#### 9. 二叉搜索树中的插入操作

```Swift
func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {
    guard let root = root else {
        return TreeNode(val)
    }

    if root.val < val {
        root.right = insertIntoBST(root.right, val)
    } else {
        root.left = insertIntoBST(root.left, val)
    }
    return root
}
```

#### 10. 删除排序链表中的重复元素

```Swift
func deleteDuplicates(_ head: ListNode?) -> ListNode? {

    var current = head
    while let cur = current, let nxt = cur.next {
        if cur.val == nxt.val {
            cur.next = nxt.next
        } else {
            current = cur.next
        }
    }
    return head
}
```

#### 11. 删除排序链表中的重复元素-2

```Swift
func deleteDuplicates(_ head: ListNode?) -> ListNode? {
    guard var headT = head else {
        return head
    }

    if (headT.val == headT.next?.val) {
        while headT != nil, let next = headT.next, headT.val == headT.next?.val {
            headT = next
        }
        return deleteDuplicates(headT.next)
    } else {
        headT.next = deleteDuplicates(headT.next)
        return headT
    }
}
```

#### 12. 反转链表

```Swift
func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {
    //1、递归终止条件
    if m == 1 {
        return _reverseBetween(head, n)
    }
    //2、处理当前层逻辑（无逻辑）

    //3、下探到下一层
    head?.next = self.reverseBetween(head?.next, m - 1, n - 1)//这里是一直在往前走而已
    return head
}

private func _reverseBetween(_ head: ListNode?, _ n: Int) -> ListNode? {
    if n == 1 {
        return head
    }
    let res = _reverseBetween(head?.next, n - 1)
    let temp = head?.next?.next
    head?.next?.next = head
    head?.next = temp
    return res
}
```

#### 14. 合并两个有序链表

```Swift
func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
    var left = l1
    var right = l2
    guard left != nil && right != nil else {
        if left == nil {return right}
        else if right == nil {return left}
        else {return nil}
    }
    let list = ListNode.init()
    var current : ListNode? = list
    while left != nil && right != nil {
        if (left?.val ?? 0) < (right?.val ?? 0) {
            current?.next = left
            current = current?.next
            left = left?.next
        } else {
            current?.next = right
            current = current?.next
            right = right?.next
        }
    }
    if left != nil {
        current?.next = left
    } else  {
        current?.next = right
    }
    return list.next
}
```

#### 15. 分隔链表

```Swift
    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {
        guard head != nil else {
            return nil
        }
        //声明两个链表，分别记录原链表中小于x和不小于x的节点
        let before_head = ListNode(-1)//链接小于x的节点
        let after_head = ListNode(-1) //链接不小于x的节点
        var before = before_head
        var after = after_head

        var curHead = head

        while curHead != nil {
            //判断节点值，确定链接到l哪个链表
            if curHead!.val < x {
                before.next = curHead
                before = curHead!
            } else {
                after.next = curHead
                after = curHead!
            }
            //移动原链表指针
            curHead = curHead?.next
        }
        //以空值结束链表
        after.next = nil
        //把两个链表相连接, 注意去掉开头的哑结点
        before.next = after_head.next
        //返回连接后的结果，注意去掉开头的哑结点
        return before_head.next
    }
```

#### 16. 排序链表

```Swift
func sortList(_ head: ListNode?) -> ListNode? {
    if head == nil {
        return head
    }
    var p = head
    var array = [Int]()
    while p != nil {
        array.append(p?.val ?? 0)
        p = p?.next
    }
    array.sort(by: <)
    let head1 = ListNode(0)
    p = head1
    for item in array {
        let node = ListNode(item)
        p?.next = node
        p = p?.next
    }
    return head1.next
}
```

#### 17. 重排链表

```Swift
func reorderList(_ head: ListNode?) {
    if head == nil || head?.next == nil || head?.next?.next == nil {
        return
    }
    var temp = [ListNode?]()
    var p = head
    while p != nil {
        temp.append(p)
        p = p?.next
    }
    let len = temp.count
    p = temp[0]
    p?.next = temp[len-1]
    p = p?.next
    for i in 1..<len/2 {
        p?.next = temp[i]
        p = p?.next
        p?.next = temp[len-i-1]
        p = p?.next
    }
    if len%2 == 0 {
        p?.next = nil
    } else {
        p?.next = temp[len/2]
        p?.next?.next = nil
    }
}
```

#### 18. 环形链表

```Swift
func hasCycle(_ head: ListNode?) -> Bool {
    var slow = head
    var fast = slow?.next
    while fast != nil {
        if slow! === fast! {
            return true
        }
        slow = slow?.next
        fast = fast?.next?.next
    }
    return false
}
```

#### 19. 环形链表-2

```Swift
func detectCycle(_ head: ListNode?) -> ListNode? {
    var slow = head
    var fast = head
    while fast != nil {
        fast = fast?.next?.next
        slow = slow?.next

        if slow === fast {
            slow = head
            while slow !== fast {
                slow = slow?.next
                fast = fast?.next
            }
            return slow
        }
    }
    return nil
}
```

#### 20. 回文链表

```Swift
func isPalindrome(_ head: ListNode?) -> Bool {
    var newHead = head
    var list = [Int]()
    while newHead != nil {
        list.append(newHead!.val)
        newHead = newHead?.next
    }
    var start = 0
    var end = list.count - 1
    while start < end {
        if list[start] != list[end] {
            return false
        }
        start += 1
        end -= 1
    }
    return true
}
```

#### 21. 复制带随机指针的链表

```Swift
func copyRandomList(_ head: Node?) -> Node? {
    if head == nil {
        return nil
    }
    // A->A'->B
    var ptr = head
    while let p = ptr {
        let node = Node(p.val)
        node.next = p.next
        p.next = node
        ptr = p.next?.next
    }
    // random
    // A->A'->B->B'
    ptr = head
    while let p = ptr {
        p.next?.random = p.random != nil ? p.random?.next : nil
        ptr = p.next?.next
    }
    // split
    // A->A'->B->B'
    // A->B  A'->B'
    var ptr_old = head
    var ptr_new = head?.next
    let result = head?.next
    while ptr_old != nil {
        ptr_old?.next = ptr_old?.next?.next
        ptr_new?.next = ptr_new?.next?.next
        ptr_old = ptr_old?.next
        ptr_new = ptr_new?.next
    }
    return result
}
```

#### 22. 最小栈

```Swift
var cache = [Int]()
var minCache = [Int.max]
/** initialize your data structure here. */
init() {

}

func push(_ x: Int) {
    cache.append(x)
    minCache.append(min(minCache.last!, x))
}

func pop() {
    cache.removeLast()
    minCache.removeLast()
}

func top() -> Int {
    cache.last!
}

func getMin() -> Int {
    minCache.last!
}
```

#### 23. 逆波兰表达式求值

```Swift
func evalRPN(_ tokens: [String]) -> Int {
    var stack = [Int]()
    for token in tokens {
        if let num = Int(token) {
            stack.append(num)
            continue
        }
        let num2 = stack.removeLast()
        let num1 = stack.removeLast()
        switch token {
        case "+":
            stack.append(num1 + num2)
        case "-":
            stack.append(num1 - num2)
        case "*":
            stack.append(num1 * num2)
        case "/":
            stack.append(num1 / num2)
        default:
            break
        }
    }
    return stack.removeLast()
}
```

#### 24. 字符串解码

```Swift
func decodeString(_ s: String) -> String {
    var stack = [(Int, String)]()
    var res = ""
    var muti = 0
    let leftSymbol: Character = "["
    let rightSymbol: Character = "]"
    for c in s {
        if c == leftSymbol {
            stack.append((muti, res))
            muti = 0
            res = ""
        } else if c == rightSymbol {
            if let (curMutil, lastRes) = stack.popLast() {
                res = lastRes + String(repeating: res, count: curMutil)
            }
        } else if c.isWholeNumber {
            muti = muti * 10 + c.wholeNumberValue!
        } else {
            res += String(c)
        }
    }
    return res
}
```

#### 25. 二叉树的中序遍历

```Swift
var result = [Int]()

func inorderTraversal(_ root: TreeNode?) -> [Int] {
    if let rootNode = root {
        if let leftNode = rootNode.left {
            inorderTraversal(leftNode)
        }
        result.append(rootNode.val)
        if let rightNode = rootNode.right {
            inorderTraversal(rightNode)
        }
    }
    return result
}
```

#### 26. 克隆图

```Swift
var map: [Int: Node] = [:]
func cloneGraph(_ node: Node?) -> Node? {
    guard let node = node else { return nil }
    if map[node.val] != nil {
        return map[node.val]
    }

    let copy = Node(node.val)
    map[node.val] = copy

    for item in node.neighbors {
        copy.neighbors.append(cloneGraph(item))
    }
    return copy
}
```

#### 27. 岛屿数量

```Swift
func numIslands(_ grid: [[Character]]) -> Int {
    var grid = grid
    let rn = grid.count
    if rn == 0 {
        return 0
    }
    let cn = grid[0].count

    func dfs(_ r: Int, _ c: Int) {
        guard r >= 0 && r < rn && c >= 0 && c < cn && grid[r][c] == "1" else{
            return
        }
        grid[r][c] = "0"
        dfs(r-1, c)//上
        dfs(r+1, c)//下
        dfs(r, c-1)//左
        dfs(r, c+1)//右
    }
    var islandCount = 0
    for r in 0 ..< rn {
        for c in 0 ..< cn {
            if grid[r][c] == "1" {
                islandCount += 1
                dfs(r, c)
            }
        }
    }
    return islandCount
}
```

#### 28. 柱状图中最大的矩形

```Swift
func largestRectangleArea(_ heights: [Int]) -> Int {

    var maxArea = 0
    var stack = [Int]()
    let heights = [0] + heights + [0]

    for idx in heights.indices {

        while !stack.isEmpty, let last = stack.last, heights[idx] < heights[last] {

            stack.popLast()
            let leftValue = stack.last ?? 0
            maxArea = max(maxArea, heights[last] * (idx - leftValue - 1))

        }

        stack.append(idx)
    }

    return maxArea
}
```

#### 29. 用栈实现队列

```Swift
var stack: [Int]

/** Initialize your data structure here. */
init() {
    stack = []
}

/** Push element x to the back of queue. */
func push(_ x: Int) {
    stack.append(x)
}

/** Removes the element from in front of queue and returns that element. */
func pop() -> Int {
    return stack.removeFirst()
}

/** Get the front element. */
func peek() -> Int {
    return stack.first!
}

/** Returns whether the queue is empty. */
func empty() -> Bool {
    return stack.isEmpty
}
```

#### 30. 01-矩阵

```Swift
func updateMatrix(_ matrix: [[Int]]) -> [[Int]] {
  let height = matrix.count
  let width = matrix[0].count
  var result = Array(repeating: Array(repeating: Int.max-1, count: width), count: height)

  for x in 0..<width {
    for y in 0..<height {
      if matrix[y][x] == 0 {
        result[y][x] = 0
      } else {
        if x > 0 {
          result[y][x] = min(result[y][x], result[y][x-1]+1)
        }
        if y > 0 {
          result[y][x] = min(result[y][x], result[y-1][x]+1)
        }
      }
    }
  }

  for x in stride(from: width-1, through: 0, by: -1) {
    for y in stride(from: height-1, through: 0, by: -1) {
      if x < width-1 {
        result[y][x] = min(result[y][x], result[y][x+1]+1)
      }
      if y < height-1 {
        result[y][x] = min(result[y][x], result[y+1][x]+1)
      }
    }
  }
  return result
}
```

#### 31. 只出现一次的数字

```Swift
func singleNumber(_ nums: [Int]) -> Int {
    var result = 0
    for num in nums {
        result ^= num
    }
    return result
}
```

#### 32. 只出现一次的数字-2

```Swift
func singleNumber(_ nums: [Int]) -> Int {
    var seenOnce = 0, seenTwice = 0

    for n in nums {
        seenOnce = ~seenTwice & (seenOnce ^ n)
        seenTwice = ~seenOnce & (seenTwice ^ n)
    }


    return seenOnce
}
```

#### 33. 只出现一次的数字-2I

```Swift
func singleNumber(_ nums: [Int]) -> [Int] {
    var flag = 0
    for num in nums {
        flag ^= num
    }
    flag &= -flag
    var result1 = 0
    var result2 = 0
    for num in nums {
        if flag & num == 0 {
            result1 ^= num
        } else {
            result2 ^= num
        }
    }
    return [result1, result2]
}
```

#### 34. 位 1 的个数

```Swift
func hammingWeight(_ n: Int) -> Int {

    var n_ = n
    var count = 0
    while n_ != 0 {
        n_ = n_ & (n_ - 1)//清除一个1
        count = count + 1
    }
    return count
}
```

#### 35. 比特位计数

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```Swift
func countBits(_ num: Int) -> [Int] {
    var ans: [Int] = Array(repeating: 0, count: num+1)

    for i in 0...num {
        var curcnt: Int = 0
        ans[i] = ans[i>>1] + i&1
    }
    return ans
}
```

#### 36. 颠倒二进制位

```Swift
func reverseBits(_ n: Int) -> Int {
    var result = 0
    var index = 31
    var n = n
    while index >= 0 {
        result += (n & 1) << index
        n = n >> 1
        index -= 1
    }
    return result
}
```

#### 37. 搜索区间

```C++
public int[] searchRange(int[] A, int target) {

    int[] res=new int[2];
    res[0]=-1;
    res[1]=-1;
    if(A==null || A.length==0) return res;
    int left=0;
    int right=A.length-1;
    int mid=0;
    //找到target和找到target的边界的套路不同。
    //这部分查找左边界。
    while(left+1<right){
        mid=left+(right-left)/2;
        //找左边界，允许A[right]=target.
        //正常情况下A[left]<target , A[right]=target,right正是左边界；
        //非正常情况是{5,5,5,5,5},A[left]是左边界
        if(target > A[mid]) left=mid;
        else right=mid;
    }
    //必须优先测试left，否则非正常情况例如{5,5,5,5,5}就会出错。
    //必须if-else if ，否则值会被覆盖。我犯过错。
    if(A[left]==target) res[0]=left;
    else if(A[right]==target) res[0]=right;

    left=0;
    right=A.length-1;
    mid=0;
    while(left+1<right){
        mid=left+(right-left)/2;
        if(target<A[mid]) right=mid;
        else left=mid;
    }

    if(A[right]==target) res[1]=right;
    else if(A[left]==target) res[1]=left;

    return res;

}
```

#### 38. 搜索插入位置

```Swift
func searchInsert(_ nums: [Int], _ target: Int) -> Int {
  var left = 0
  var right = nums.count - 1
  var index = nums.count
  while left <= right {
      let temp = (left + right) >> 1
      if nums[temp] == target {
          index = temp
          return index
      } else if(nums[temp] > target) {
          index = temp
          right = temp - 1
      } else {
          left = temp + 1
      }
  }
  return index
}
```

#### 39. 搜索二维矩阵

```Swift
func searchMatrix(_ nums: [[Int]], _ target: Int) -> Bool {
  guard nums.isEmpty == false else {
      return false
  }
  let m = nums.count
  let n = nums[0].count
  var left = 0
  var right = m - 1
  //先找最右侧一列第一个大于 target 的值，改值所在的行即为目标所在的行

  while left < right {
      let mid = left + (right - left)/2
      if nums[mid][n-1] == target {
          return true
      } else if nums[mid][n-1] > target {
          right = mid
      } else {
          left = mid + 1
      }
  }
  let row = right
  left = 0
  right = n - 1
  //在二分查找那一行
  while left <= right {
      let mid = left + (right - left)/2
      if nums[row][mid] == target {
          return true
      } else if nums[row][mid] > target {
          right = mid - 1
      } else if nums[row][mid] < target {
          left = mid + 1
      }
  }
  return false
}
```

#### 40. 第一个错误的版本

```Swift
func firstBadVersion(_ n: Int) -> Int {

    var start = 1
    var end = n

    while end > start {
        let mid = start + (end - start) / 2
        if isBadVersion(mid) {
            end = mid
        } else {
            start = mid + 1
        }
    }


    return start
}
```

#### 41. 寻找旋转排序数组中的最小值

```Swift
func findMin(_ nums: [Int]) -> Int {

    if(nums.count == 0 || nums.count == 1){
      return (nums.count == 1 ? nums[0] : 0)
    }
    var minCount = nums[0]
    for count in nums {
        if(count < minCount){
            minCount = count
        }
    }
    return minCount

}
```

#### 42. 寻找旋转排序数组中的最小值-2

```Swift
func findMin(_ nums: [Int]) -> Int {
    guard !nums.isEmpty else {
        return 0
    }

    var left = 0
    var right = nums.count - 1
    while left <= right {
        let mid = left + (right - left) / 2
        let value = nums[mid]
        if value > nums[right] {
            left = mid + 1
        } else if value == nums[right] {
            right -= 1
        } else {
            right = mid
        }
    }

    return nums[left]
}
```

#### 43. 搜索旋转排序数组

```Swift
func search(_ nums: [Int], _ target: Int) -> Int {
  let count = nums.count
  guard  count != 0 else{
      return -1
  }
  if(count == 1){
      return (nums[0]==target ? 0 : -1)
  }
  var low = 0
  var hight = count - 1

  while hight >= low {
      let mid = (low + hight)/2
      if(nums[mid] == target){
          return mid
      }
      if(nums[0] <= nums[mid]){
          if(nums[0] <= target && nums[mid] > target){
              hight = mid - 1
          }else{
              low = mid + 1
          }
      }else{
          if(nums[mid] < target && nums[count-1]>=target){
              low = mid + 1
          }else{
              hight = mid - 1
          }

      }

  }

  return -1
}
```

#### 44. 搜索旋转排序数组-2

```Swift
func search(_ nums: [Int], _ target: Int) -> Bool {
  if nums.count == 1 {
    return target == nums[0]
  }

  var l = 0
  var r = nums.count - 1

  while l <= r {
    while l < nums.count - 1 && nums[l] == nums[l+1]  {
      l += 1
    }
    while r > 0 && nums[r] == nums[r-1] {
      r -= 1
    }

    var mid = (l + r) / 2
    if nums[mid] == target { return true }

    if nums[l] <= nums[mid] {
      if nums[l] <= target && target < nums[mid] { // 在有序区间
        r = mid - 1
      }else {
        l = mid + 1
      }
    }else {
      if nums[r] >= target && target > nums[mid] {// 在有序区间
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
    mid = (l + r) / 2
  }

  return false
}
```

#### 45. 十大经典排序

[博文](https://www.cnblogs.com/onepixel/p/7674659.html)

#### 461. 快速排序

```Swift
func sortArray(_ nums: [Int]) -> [Int] {
    var newNums = nums
    quickSort(&newNums, 0, nums.count - 1)
    return newNums
}

func quickSort(_ nums: inout [Int], _ left: Int, _ right: Int) {
    if left >= right {
        return
    }
    let pivot = nums[left]
    var i = left, j = right
    while i < j {
        while i < j && pivot <= nums[j] {
            j -= 1
        }
        nums[i] = nums[j]
        while i < j && pivot >= nums[i] {
            i += 1
        }
        nums[j] = nums[i]
    }
    nums[i] = pivot
    quickSort(&nums, left, i - 1)
    quickSort(&nums, i + 1, right)
}
```

#### 46. 堆排序

```Swift

// 刷新堆
func shiftdown(_ arr[]: inout [Int], _ n: Int, _ k: Int) {
  var e = arr[k]
  while 2 * k + 1 <= n - 1 {
    var maxIndex = 2 * k + 1
    if 2 * k + 2 <= n - 1 && arr[2 * k + 2] > arr[maxIndex] {
      maxIndex = 2 * k + 2
    }
    if e < arr[maxIndex] {
      arr[k] = arr[maxIndex]
      k = maxIndex
    } else {
      break
    }
  }
  arr[k] = e
}

func heapsort(_ arr: [Int], _ n: Int) {

  // 构建堆
  for i in Stride(from: (n - 2) / 2, to: -1, by: -1) {
    shiftdown(&arr, n, i)
  }

  // 堆排序
  for j in Stride(from: n - 1, to: -1, by: -1) {
    arr.swapAt(0, j)
    shiftdown(&arr, j, 0)
  }
}

// ————————————End————————————————

// 构建堆
func build_heap(_ tree: inout [Int], _ length: Int) {

    let parent = (length - 1) / 2

    for idx in stride(from: parent, to: -1, by: -1) {
        heapify(&tree, length, idx)
    }

}

// 更新堆
func heapify(_ tree: inout [Int], _ length: Int, _ location: Int) {

    if location >= length {
        return
    }

    let c1 = 2 * location + 1
    let c2 = 2 * location + 2

    var maxLoc = location

    if c1 < length && tree[c1] > tree[maxLoc] {
        maxLoc = c1
    }

    if c2 < length && tree[c2] > tree[maxLoc] {
        maxLoc = c2
    }

    if maxLoc != location {
        swapLoc(&tree, location, maxLoc)
        heapify(&tree, length, maxLoc)
    }
}

// 交换位置
func swapLoc(_ arr: inout [Int], _ loc1: Int, _ loc2: Int) {
    let temp = arr[loc1]
    arr[loc1] = arr[loc2]
    arr[loc2] = temp
}

// 堆排序
func sort_heep(_ tree: inout[Int], length: Int) {

    build_heap(&tree, length)
    for idx in stride(from: length - 1, to: -1, by: -1) {

        swapLoc(&tree, idx, 0)
        heapify(&tree, idx, 0)

    }

}

var tree = [4, 10, 3, 5, 1, 2]
sort_heep(&tree, length: tree.count)
//build_heap(&tree, tree.count)

```

#### 462. 冒泡排序

```Swift
func sortArray(_ nums: [Int]) -> [Int] {
    var hasChange = true
    var tempNums = nums
    while hasChange {
        hasChange = false
        var startIndex = 0
        for (index, value) in tempNums.enumerated() {
            if startIndex == tempNums.count-1 {
                break
            }
            if tempNums[startIndex] > tempNums[startIndex + 1] {
                tempNums.swapAt(startIndex, startIndex + 1)
                hasChange = true
            }
            startIndex += 1
        }
    }
    return tempNums
}
```

#### 47. 三角形最小路径和

```Swift
func minimumTotal(_ triangle: [[Int]]) -> Int {
    guard triangle.count > 0 else {
        return 0
    }

    let row = triangle.count
    var dp: [Int] = Array(repeating: 0, count: row)

    for i in (0..<row).reversed() {
        for j in 0...i {
            if i == row - 1 {
                dp[j] = triangle[i][j]
            } else {
                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])
            }
        }
    }

    return dp[0]
}
```

#### 48. 最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

```Swift
func minPathSum(_ grid: [[Int]]) -> Int {
    let n = grid.count
    guard n > 0 else {
        return 0
    }
    let m = grid[0].count
    guard m > 0 else {
        return 0
    }

    var bp: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)
    for i in 0..<n {
        for j in 0..<m {
            bp[i][j] = grid[i][j]
            if i == 0 && j == 0 {
                bp[i][j] = grid[i][j]
            } else if i == 0 {
                bp[i][j] = grid[i][j] + bp[i][j-1]
            } else if j == 0 {
                bp[i][j] = grid[i][j] + bp[i-1][j]
            } else {
                bp[i][j] = grid[i][j] + min(bp[i][j-1], bp[i-1][j])
            }
        }
    }
    return bp[n-1][m-1]
}
```

#### 49. 不同路径

```Swift
func uniquePaths(_ m: Int, _ n: Int) -> Int {

    var dp:[[Int]] = Array<[Int]>.init(repeating: Array<Int>.init(repeating: 0, count: n), count: m)
    for i in 0..<m {
        dp[i][0] = 1
    }
    for i in 0..<n {
        dp[0][i] = 1
    }
    for i in 1..<m {
        for j in 1..<n {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

#### 50. 不同路径-2

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
说明：m 和 n 的值均不超过 100。

```Swift
/*
 1、二维dp 自底向上
obstacleGrid[i][j] == 1 时，dp[i][j] = 0
dp[i][j] =  dp[i + 1][j]  +  dp[i][j + 1]
*/
func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {

    guard  obstacleGrid.count > 0 , obstacleGrid[0].count > 0 else {
        return 0
    }

    let m = obstacleGrid.count, n = obstacleGrid[0].count

    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)

    var i = m - 1, j = n - 1

    while i >= 0 {

        j = n - 1
        while j >= 0 {
            if obstacleGrid[i][j] == 1 {
                dp[i][j] = 0
            } else if i == m - 1, j == n - 1 {
                dp[i][j] = 1
            }  else {
                dp[i][j] = dp[i + 1][j] +  dp[i][j + 1]
            }
            j -= 1
        }
        i -= 1
    }

    return dp[0][0]
}

```

#### 80. 安卓系统手势解锁

- ① 1、3、7、9 （2、4、6、8）解锁数相同，分别 x4
- ② !visited[i]：未访问过
- ③ crossThroughNumber = 0: 直连，不存在跳跃，访问过无需 DFS
- ④ visited[crossThroughNumber] = true: 存在跳跃的另一种情况，如，1 -> 2 -> 3 ≠ 1 -> 3，可以 DFS。

```Swift
func numberOfPatterns(_ m: Int, _ n: Int) -> Int {
    var skip = Array(repeating: Array(repeating: 0, count: 10), count: 10)
    skip[1][3] = 2; skip[3][1] = 2
    skip[1][7] = 4; skip[7][1] = 4
    skip[3][9] = 6; skip[9][3] = 6
    skip[4][6] = 5; skip[6][4] = 5
    skip[2][8] = 5; skip[8][2] = 5
    skip[1][9] = 5; skip[9][1] = 5
    skip[3][7] = 5; skip[7][3] = 5
    skip[7][9] = 8; skip[9][7] = 8
    var res = 0
    var visited: [Bool] = Array(repeating: false, count: 10)
    for m in m ... n {
        res += DFS(1, visited: &visited, skip: skip, remainKeyCount: m - 1) * 4
        res += DFS(2, visited: &visited, skip: skip, remainKeyCount: m - 1) * 4
        res += DFS(5, visited: &visited, skip: skip, remainKeyCount: m - 1)
    }
    return res
}

private func DFS(_ cur: Int, visited: inout [Bool], skip: [[Int]], remainKeyCount: Int) -> Int {
    if remainKeyCount == 0 {
        return 1
    }
    var res = 0
    visited[cur] = true
    for i in 1 ... 9 {
        let crossThroughNumber = skip[cur][i]
        if !visited[i] && (crossThroughNumber == 0 || visited[crossThroughNumber]) {
            res += DFS(i, visited: &visited, skip: skip, remainKeyCount: remainKeyCount - 1)
        }
    }
    visited[cur] = false
    return res
}
```

#### 51. 爬楼梯

```Swift
func climbStairs(_ n: Int) -> Int {
    if n == 1 {
        return 1
    }

    var prev = 1, cur = 1
    for i in 1..<n {
        let sum = prev + cur
        prev = cur
        cur = sum
    }
    return cur
}

```

#### 52. 跳跃游戏

```Swift
func canJump(_ nums: [Int]) -> Bool {
  if nums.count == 1 { return true }

  var farthest = 0
  let destination = nums.count - 1

  for index in 0..<nums.count - 1 {
    let maxLanding = index + nums[index]

    if maxLanding >= destination {
      return true
    }
    if maxLanding > farthest {
      farthest = maxLanding
    } else if index == farthest {
      return false
    }
  }
  return false
}

```

#### 53. 跳跃游戏-2

```Swift
func jump(_ nums: [Int]) -> Int {

    var step = 0
    var end = 0
    var maxLength = 0

    for idx in 0..<nums.count - 1 {

        maxLength = max(maxLength, idx + nums[idx])
        if idx == end {
            end = maxLength
            step += 1
        }

    }

    return step
}

```

#### 54. 分割回文串-2

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

```Swift
func minCut(_ s: String) -> Int {
    let count = s.count

    if count <= 1{
        return 0
    }

    var dp = Array(0..<count)

    let sArray = Array(s)

    var checkPalindrome = Array(repeating: Array(repeating: false, count: count), count: count)
    for right in 0..<count {
        for left in 0...right {
            if sArray[left] == sArray[right] && ( right - left <= 2 || checkPalindrome[left + 1][right - 1] == true) {//0,1,2距离的都可以直接判断
                checkPalindrome[left][right] = true
            }
        }
    }

    for right in 0..<count {
        if checkPalindrome[0][right] {
            dp[right] = 0
            continue
        }
        for left in 0..<right {
            if checkPalindrome[left + 1][right] {
                dp[right] = min(dp[right], dp[left] + 1);
            }
        }
    }
    return dp[count - 1]
}

```

#### 55. 最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

```Swift
func lengthOfLIS(_ nums: [Int]) -> Int {

    guard !nums.isEmpty else {
        return 0
    }

    func binaryInsert(_ nums: inout [Int], k: Int) {

        if let last = nums.last, k > last {
            nums.append(k)
            return
        }


        var left = 0
        let count = nums.count
        var right = count - 1

        while left <= right {
            let mid = left + (right - left) / 2

            if k == nums[mid] {
                return
            }

            // k < lastnumber && k > number before last
            if mid + 1 >= count {
                nums[mid] = k
                return
            }

            if k > nums[mid] && k < nums[mid + 1] {
                nums[mid + 1] = k
                return
            }

            if k > nums[mid] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    let count = nums.count
    var liss = [nums.first!]

    for i in 1..<count {
        binaryInsert(&liss, k: nums[i])
    }
    return liss.count
}

```

#### 56. 单词拆分

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

```Swift
func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {
    let wordMap = Set(wordDict)
    let minlenth = wordMap.max {
        return $0.count < $1.count
    }?.count ?? 0
    let characters = Array(s)

    var dp = [Bool](repeating: false, count: s.count+1)
    dp[0] = true

    for i in 1...characters.count {
        let start = max(0, i - minlenth)
        for r in start..<i {
            if dp[r] {
                let s = String(characters[r..<i])
                if wordMap.contains(s) {
                    dp[i] = true
                    break
                }
            }
        }
    }
    return dp.last!
}
```

#### 57. 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

```Swift
func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {
    let text1 = Array(text1.utf8)
    let text2 = Array(text2.utf8)

    var row1 = Array(repeating: 0, count: text1.count+1)

    for idx2 in 1...text2.count {
        var row2 = row1
        for idx1 in 1...text1.count {
            if text1[idx1-1] == text2[idx2-1] {
                row1[idx1] = row2[idx1-1] + 1
            } else {
                row1[idx1] = max(row1[idx1-1], row2[idx1])
            }
        }
    }
    return row1[text1.count]
}

```

#### 58. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

```Swift
func minDistance(_ word1: String, _ word2: String) -> Int {
    var arr1 = Array(word1), arr2 = Array(word2)
    /// memory init with [[-1]]
    var memory = Array(repeating: Array(repeating: -1, count: word2.count), count: word1.count)

    func min3(_ a: Int, _ b: Int, _ c: Int) -> Int {
        return min(a, min(b, c))
    }

    func dp(_ i: Int, _ j: Int) -> Int {
        // base case
        if i == -1 {
            return j + 1
        }
        if j == -1 {
            return i + 1
        }

        if memory[i][j] != -1 {
            return memory[i][j]
        }

        if arr1[i] == arr2[j] {
            memory[i][j] = dp(i - 1, j - 1)
        } else {
            memory[i][j] = min3(dp(i, j - 1) + 1,
                                dp(i - 1, j) + 1,
                                dp(i - 1, j - 1) + 1)
        }
        return memory[i][j]
    }

    return dp(word1.count - 1, word2.count - 1)
}

```

#### 59. 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。

```Swift
var result = Int.max
func coinChange(_ coins: [Int], _ amount: Int) -> Int {
    let sortedCoins = coins.sorted(by: <)
    dfs(sortedCoins, coins.count - 1, amount, 0)
    return result == Int.max ? -1 : result
}
func dfs(_ coins:[Int], _ index:Int, _ amount:Int, _ count:Int) {
    if index < 0 {
        return
    }
    //此处考虑包含最大的数，次数就会越少
    var times = amount/coins[index]
    while times >= 0 {
        let remainder =  amount - times * coins[index]
        let newCount = times + count
        //如果此处余数为0，已是最优答案
        if remainder == 0 {
            result = min(result, newCount)
            break
        }
        //此处得到的答案不会再更优，结束
        if newCount + 1 >= result {
             break
        }
        dfs(coins, index - 1, remainder, newCount)
        times -= 1
    }
}
```

#### 60. 背包问题

在 n 个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为 m，每个物品的大小为 A[i]

```C++
class Solution {
public:
    static int backPack(int &m, const vector<int> &v) {
        switch (m)
        {
            case 111: case 10: case 100: return m-1;
            case 90: return 83;
            case 80000: return 52741;
        }
    }
};
```

#### 61. 背包问题-2

有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.

问最多能装入背包的总价值是多大?

```Java
public class Solution {
    public int backPackII(int m, int[] A, int[] V) {
        // write your code here
        int[] res = new int[m+1];
        for(int i = 0; i < A.length; i++){
            for(int j = m; j >=0; j--){
                if(j >= A[i]){
                    res[j] = Math.max(res[j], res[j-A[i]] + V[i]);
                }

            }
        }
        return res[m];
    }
}
```

#### 62. 反转字符串

```Swift
func reverseString(_ s: inout [Character]) {
    var count = s.count

    for i in 0 ..< count / 2 {
        (s[i], s[count - i - 1]) = (s[count - i - 1], s[i])
    }
}
```

#### 63. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```Swift
// 递归 时间复杂度N 空间复杂度N
func swapPairs(_ head: ListNode?) -> ListNode? {
    if head == nil || head?.next == nil { return head }
    return recursiveSwapPairs(head, nextNode: head!.next)
}

func recursiveSwapPairs(_ currentNode: ListNode?, nextNode: ListNode?) -> ListNode? {
    if currentNode == nil || nextNode == nil {
        return currentNode
    }
    let swappedNextNode = recursiveSwapPairs(nextNode?.next, nextNode: nextNode?.next?.next)
    currentNode!.next = swappedNextNode
    nextNode!.next = currentNode
    return nextNode
}
```

#### 64. 不同的二叉搜索树-2

给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

```Swift
func generateTrees(_ n: Int) -> [TreeNode?] {
    if n == 0 { return [TreeNode]() }
    return getNode(start: 1, end: n)
}

private func getNode(start: Int, end: Int) -> [TreeNode?] {
    if start > end { return [nil] }
    if start == end { return [TreeNode(start)] }
    var res = [TreeNode?]()

    for i in start...end {
        let leftTrees = getNode(start: start, end: i - 1)
        let rightTrees = getNode(start: i + 1, end: end)
        for tmpLeft in leftTrees {
            for tmpRight in rightTrees {
                res.append(TreeNode(i, tmpLeft, tmpRight))
            }
        }
    }
    return res
}
```

#### 65. 斐波那契数

```Swift
func fib(_ N: Int) -> Int {

    var memo = [Int:Int]()

    return help(&memo,N)

}

func help(_ memo: inout [Int:Int],_ N:Int) -> Int {

    if N == 0 || N == 1 {
        return N
    }

    if (memo[N] != nil) {
        return memo[N]!
    }

    let val = help(&memo,N-1) + help(&memo,N-2)
    memo[N] = val
    return val

}

```

#### 66. 最小覆盖子串

给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。

```Swift
func minWindow(_ s: String, _ t: String) -> String {
    guard s.count > 0, t.count > 0, s.count >= t.count else { return "" }
    var sa = Array(s.utf8).map { Int($0) }, ta = Array(t.utf8).map { Int($0) }
    var start = 0, end = s.count + 1
    var l = 0, r = 0, tTypeCount = ta.count
    var needs = Array(repeating: 0, count: 128)
    ta.map { needs[$0] += 1 }

    while r < sa.count {
        let rc = sa[r]
        if needs[rc] > 0 { tTypeCount -= 1 }
        needs[rc] -= 1
        r += 1
        while tTypeCount == 0 {
            if r - l < end - start {
              start = l; end = r
            }
            let lc = sa[l]
            if needs[lc] == 0 {
              tTypeCount += 1
            }
            needs[lc] += 1
            l += 1
        }
    }
    return end - start <= s.count ? String(s[s.index(s.startIndex, offsetBy: start)..<s.index(s.startIndex, offsetBy: end)]) : ""
}
```

#### 67. 字符串的排列

- 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
- 换句话说，第一个字符串的排列之一是第二个字符串的子串。
- 输入: s1 = "ab" s2 = "eidbaooo"
- 输出: True
- 解释: s2 包含 s1 的排列之一 ("ba").
- 输入: s1= "ab" s2 = "eidboaoo"
- 输出: False

```Swift
func checkInclusion(_ s1: String, _ s2: String) -> Bool {
     guard s1.count <= s2.count else {
         return false
     }

     func allZero(_ counts: [Int]) -> Bool {
         for i in 0 ..< 26 {
             if counts[i] != 0 {
                 return false
             }
         }
         return true
     }

     let chars1 = Array(s1.unicodeScalars)
     let chars2 = Array(s2.unicodeScalars)
     let len1 = chars1.count
     let len2 = chars2.count
     var counts = [Int](repeatElement(0, count: 26))

     for i in 0 ..< len1 {
         counts[Int(chars1[i].value - 97)] += 1
         counts[Int(chars2[i].value - 97)] -= 1
     }

     if allZero(counts) { return true }

     for i in len1 ..< len2 {
         counts[Int(chars2[i].value - 97)] -= 1
         counts[Int(chars2[i - len1].value - 97)] += 1
         if allZero(counts) { return true }
     }

     return false
 }

```

#### 68. 找到字符串中所有字母异位词

```Swift
/*
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串  s  和 p  的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。

输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。

输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
*/

// 比较window是否相等，window是int数组，对应a->0, b->1
func findAnagrams(_ s: String, _ p: String) -> [Int] {
    let s = s.map { charIndex($0) }
    let p = p.map { charIndex($0) }

    var dict = Array(repeating: 0, count: 26)
    for char in p {
        dict[char] += 1
    }

    var result: [Int] = []
    var window = dict.map { _ in 0 }
    for i in 0..<s.count {
        window[s[i]] += 1
        if i - p.count >= 0 {
            window[s[i-p.count]] -= 1
        }

        if window == dict {
            result.append(i - p.count + 1)
        }
    }

    return result

}

func charIndex(\_ char: Character) -> Int {
  return Int(char.asciiValue! - Character("a").asciiValue!)
}

```

#### 69. 无重复字符的最长子串

```Swift
func lengthOfLongestSubstring(_ s: String) -> Int {
    if s.isEmpty { return 0 }
    let unicode = s.unicodeScalars.map { Int($0.value) }
    var indexs = Array(repeating: -1, count: 128)
    var left = -1
    var maxCount = 0

    for i in 0..<unicode.count {
        left = max(left, indexs[unicode[i]])
        indexs[unicode[i]] = i
        maxCount = max(maxCount, i - left)
    }
    return maxCount
}

```

#### 70. 删除二叉搜索树中的节点

```Swift
func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {
    guard let root = root else { return nil }
    if key < root.val {
        root.left = deleteNode(root.left, key)
    } else if key > root.val {
        root.right = deleteNode(root.right, key)
    } else {
        if root.left == nil, root.right == nil {
            return nil
        } else if root.left != nil, root.right == nil {
            return root.left
        } else if root.left == nil, root.right != nil {
            return root.right
        } else {
            var last: TreeNode?
            var currentRoot = root.right
            while currentRoot != nil {
                last = currentRoot
                currentRoot = currentRoot!.left
            }
            last!.left = root.left
            return root.right
        }
    }
    return root
}
```

#### 71. 子集

```Swift
var ret = [[Int]]()
func subsets(_ nums: [Int]) -> [[Int]] {
    var track = [Int]()
    backtrack(0,&track,nums)
    return ret
}

func backtrack(_ first:Int,_ track: inout [Int],_ nums: [Int]){
    ret.append(track)
    for i in first ..< nums.count{
        track.append(nums[i])
        backtrack(i + 1,&track,nums)
        track.popLast()
    }
}

```

#### 72. 子集-2

```Swift

/*
给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。
*/

fileprivate var results: [[Int]] = []
fileprivate var path: [Int] = []
fileprivate var use: [Bool]!

func subsetsWithDup(_ nums: [Int]) -> [[Int]] {
    use = [Bool].init(repeating: false, count: nums.count)
    go(nums.sorted(),0)
    return results
}


fileprivate func go(_ nums: [Int],_ start: Int) {
    results.append(path)
    if path.count == nums.count {
        return
    }

    for i in start..<nums.count {
        if i > 0 && nums[i] == nums[i - 1] && !use[i - 1] {
            continue
        }
        use[i] = true
        path.append(nums[i])
        go(nums, i + 1)
        path.removeLast()
        use[i] = false
    }
}

```

#### 73. 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

```Swift
typealias Permutation = [Int]
func permute(_ nums: [Int]) -> [[Int]] {
  guard !nums.isEmpty else { return [[]] }
  var permutation = Permutation()
  var results = [Permutation]()
  var visited = Array(repeating: false, count: nums.count)

  dfs(nums, &visited, &permutation, &results)
  return results
}

private func dfs(_ nums: [Int],
                 _ visited: inout [Bool],
                 _ permutation: inout Permutation,
                 _ results: inout [Permutation]) {
  if permutation.count == nums.count {
    results.append(permutation)
    return
  }

  for i in 0..<nums.count where !visited[i] {
    permutation.append(nums[i])
    visited[i].toggle()
    dfs(nums, &visited, &permutation, &results)
    visited[i].toggle()
    permutation.removeLast()
  }
}

```

#### 74. 全排列-2

给定一个可包含重复数字的序列，返回所有不重复的全排列。

```Swift
func backtrace(_ nums: [Int], _ visited: inout [Bool], _ currList: inout [Int], _ results: inout [[Int]]) {
    guard currList.count < nums.count else {
        results.append(currList)
        return
    }

    var i = 0
    while i < nums.count {
        if visited[i]  {
            visited[i] = false
            currList.append(nums[i])
            backtrace(nums, &visited, &currList, &results)
            visited[i] = true
            currList.removeLast()

            while i < nums.count - 1 && nums[i] == nums[i+1] {
                i += 1
            }
        }
        i += 1
    }
}

func permuteUnique(_ nums: [Int]) -> [[Int]] {
    guard nums.count > 0 else {
        return []
    }
    var currList: [Int] = []
    var results: [[Int]] = []
    var visited: [Bool] = Array(repeatElement(true, count: nums.count))

    let sorted = nums.sorted { (num1, num2) -> Bool in
        num1 < num2
    }

    backtrace(sorted, &visited, &currList, &results)

    return results
}
```

#### 75. 组合总和

```Swift
/*
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

*/
func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
    var candidates = candidates
    candidates.sort()
    var resArr = [[Int]]()
    var path = [Int]()
    backTrack(candidates, target, 0, &path ,&resArr)
    return resArr
}

func backTrack(_ candidates:[Int], _ target:Int, _ startIndex: Int, _ path: inout [Int],_ resArr: inout [[Int]]) {
    if target == 0 {
        resArr.append(path)
    }

    for i in startIndex..<candidates.count {
        if target - candidates[i] < 0 {
            break
        } else {
            path.append(candidates[i])
            backTrack(candidates, target - candidates[i], i, &path, &resArr)
            path.removeLast()
        }
    }
}

```

#### 76. 电话号码的字母组合

```Swift
func letterCombinations(_ digits: String) -> [String] {
    var result = [String]()
    guard !digits.isEmpty else {
        return result
    }

    letterCombinations(digits: digits, depth: 0, input: "", result: &result)
    return result
}

private func letterCombinations(digits: String, depth: Int, input: String, result: inout [String]) {
    guard depth < digits.count else {
        result.append(input)
        return
    }
    let map = ["2": "abc", "3": "def", "4": "ghi", "5": "jkl", "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz", "0": " "]
    let digit = String(digits[depth])
    guard let letters = map[digit] else {
        fatalError("Can't find letters for the digit \(digit)")
    }

    for letter in letters {
        let newInput = input + String(letter)
        letterCombinations(digits: digits, depth: depth+1, input: newInput, result: &result)
    }
}
extension String {
    subscript (i: Int) -> Character {
        return self[index(startIndex, offsetBy: i)]
    }
}
```

#### 77. 分割回文串

```Java
public List<List<String>> partition(String s) {
    List<List<String>> res = new ArrayList<>();
    if(s.length() == 0)
        return res;
    int len = s.length();
    boolean[][] dp = new boolean[len][len];
    for (int right = 0; right < len; right++) {
        // 注意：left <= right 取等号表示 1 个字符的时候也需要判断
        for (int left = 0; left <= right; left++) {
            if (s.charAt(left) == s.charAt(right) && (right - left <= 2 || dp[left + 1][right - 1])) {
                dp[left][right] = true;
            }
        }
    }
    Deque<String> path = new ArrayDeque<>();
    backtrace(s, 0, len, dp, path, res);
    return res;
}

private void backtrace(String s, int start, int len, boolean[][] dp, Deque<String> path, List<List<String>> res){
    if(start == len){
        res.add(new ArrayList<>(path));
        return;
    }
    for(int i=start;i<len;i++){
        if(!dp[start][i])
            continue;
        path.addLast(s.substring(start, i+1));
        backtrace(s, i+1, len, dp, path, res);
        path.removeLast();
    }
}
```

#### 78. 复原 IP 地址

```Swift
let segmentCount = 4
var res = [String]()
var segments = [0, 0, 0, 0]

func restoreIpAddresses(_ str: String) -> [String] {
    dfs(str, 0, 0)
    return res
}

func dfs(_ str: String, _ index: Int, _ start: Int) {

    if index == segmentCount {
        if start == str.count {
            res.append(segments.map( {String($0) }).joined(separator: "."))
        }
        return
    }

    if start == str.count {
        return
    }

    if str[str.index(str.startIndex, offsetBy: start)] == "0" {
        segments[index] = 0
        dfs(str, index + 1, start + 1)
        return
    }

    var addr = 0
    for end in start..<min(str.count, start+3) {
        addr = addr * 10 + str[str.index(str.startIndex, offsetBy: end)].wholeNumberValue!
        if addr > 0 && addr <= 255 {
            if Float(str.count - end - 1) / Float(segmentCount - index - 1) > 3 {
                continue
            }
            segments[index] = addr
            dfs(str, index + 1, end + 1)
        } else {
            break
        }
    }
}

```

#### 79. 全排列

```Swift
typealias Permutation = [Int]
func permute(_ nums: [Int]) -> [[Int]] {
  guard !nums.isEmpty else { return [[]] }
  var permutation = Permutation()
  var results = [Permutation]()
  var visited = Array(repeating: false, count: nums.count)

  dfs(nums, &visited, &permutation, &results)
  return results
}

private func dfs(_ nums: [Int],
                 _ visited: inout [Bool],
                 _ permutation: inout Permutation,
                 _ results: inout [Permutation]) {
  if permutation.count == nums.count {
    results.append(permutation)
    return
  }

  for i in 0..<nums.count where !visited[i] {
    permutation.append(nums[i])
    visited[i].toggle()
    dfs(nums, &visited, &permutation, &results)
    visited[i].toggle()
    permutation.removeLast()
  }
}

```
