---
layout: post
title: '经典算法-动态规划'
date: 2017-09-05
author: 李大鹏
cover: ''
tags: 算法
---

#### 5. 总结

- 确定状态
  - 研究最优策略的最后一步
  - 化为子问题
- 转移方程
  - 根据子问题定义直接得到
- 初始条件
  - 细心、考虑周全
- 计算顺序
  - 利用之前的计算结果

#### 1. 动态规划题目特点

- 计数
  - 有多少种方式走到右下角
  - 有多少种方法选出 k 个数使得和是 sum
- 求最大最小值
  - 从左上角走到右下角路径的最大数字和
  - 最长上升子序列长度
- 求存在性
  - 取石子游戏，先手是否必胜
  - 能不能选出 k 个数使得和是 sum

#### 2. 四个组成部分

- 确定状态
  - 解动态时需要开一个数组，数组的每个元素 f[i]或者 f[i][j]代表什么
    - 类似于解数学题中，X、Y、Z 代表什么
  - 确定状态需要两个意识：
    - 最后一步
    - 子问题
- 转移方程
- 初始条件和边界情况
- 计算顺序

#### 3. 例题

用最少的硬币拼出金额

- 确定状态
  - 最后一步（最优策略中使用的最后一枚硬币 ak）
  - 子问题（最少的硬币拼出更小的面值 27-ak）
- 转移方程
  - f[X] = min{f[X-2]+1, f[X-5]+1, f[x-7]+1}
- 初始条件和边界情况
  - f[0] = 0, 如果不能拼出 Y，f[Y] = 正无穷
- 计算顺序
  - f[0]，f[1]，f[2]，……

#### 4. 代码

```
                    // {2, 5, 7}   // 27
public init coinChange(int[] A, int M) {
  // 0...n: [n+1]
  // 0...n-1: [n]
  int[] f = new int[M + 1];
  int n = A.length; // 硬币的种类

  // 初始条件
  f[0] = 0;

  int i, j;

  for (i = 1; i <= M; ++i) {
    f[i] = Integer.MAX_VALUE;
    // 最后一枚硬币 A[j]
    // f[i] = min{f[i-A[0]]+1, ... , f[i-A[n-1]]+1}
    for (j = 0; j < n; ++j) {
      if (i >= A[j] && f[i - A[j]] != Integer.MAX_VALUE) {
        f[i] = Math.min(f[i - A[j]] + 1, f[i]);
      }
    }
  }

  if (f[M] == Integer.MAX_VALUE) {
    f[M] = -1;
  }

  return f[M];
}
```
