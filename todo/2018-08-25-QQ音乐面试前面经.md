---
layout: post
title: 'QQ音乐面试前面经'
date: 2018-08-25
author: 李大鹏
cover: ''
tags: iOS
---

#### 面经 1：腾讯 QQ 音乐项目组-iOS-2020-06-19 11:47

##### 1、自我介绍；

- 简介
  我叫李大鹏，14 年底正式参加 iOS 工作，至今有 6 年了，平时喜欢分析源码，阅读中英文技术书籍和文档，经常关注大厂技术团队博客，积累了持续学习的习惯。

- 擅长
  - iOS 生态中的各种 SDK 应用和 Debug，先后开发了两款包含 UGC 的应用，擅长 feed 流的优化，涉及到音视频的播放和采集，编码部分较少，比如商品视频的多角度拍摄、UGC 中的类似微信朋友圈的视频交互。
  - 对各种架构模式的能够灵活运用。比如在现在项目中订单流程管理中，使用了 vuex 常用的 view-state 状态管理器模式，解决订单生成流程中的耦合问题。
  - 对全栈的兴趣，大学时独立用 Java 写过 Web 项目。在面试邀约前我正在用业余时间写一个音乐播放器的项目，原因有两个：
    - 实验新的架构方式和完善音频开发技术栈，大学时毕业论文就是音乐播放器，一直想探索音频深层技术栈；
    - 我日常使用场景只有运动、学习、工作，现在的音乐软件干扰太多，计划实现打开就选择场景的效果。
    - 包含管理后台和移动端，后端已经用 Go 和 vue 写好了，面试通知后就暂时搁置复习了。
  - 快速的学习和实践能力，刚才提到的 Go 和 vue，我在边学边用的基础上，一周业余时间就完成了一套包含 rbac 的基础后台管理系统。
- 经验
  - 我先后在 3 家公司从事 iOS 开发工作，现在公司是时间最久的，从 15 年到现在。公司的项目是由我从零到一搭建的，iOS 团队也逐渐的扩大到 5 人，在架构方面积累了挺多经验，也给了我很多实践的空间提升自己。

##### 2、现在在做项目的难点是什么，一些细节延伸；

- 关于架构和设计模式，现在主要的架构模式主要有 5 中，MVC、MVVM-C、MVP、MVC-VS、Clean，Tea 和 MAVB。
  - 订单业务流。我们的项目设计的 Usecase 比较复杂，而且延伸比较长，选择钻石、款式、定制信息、客户信息等等，最初采用 MVC 的方式开发，导致业务非常紊乱，尤其是在版本迭代的时候，效率很低。我引入了 MVC+VS 的设计模式，将所有控制器中的 View State 独立出来并且下沉，合并父类，多个控制器共同存取。在此基础上引入 Coordinate（协调器），对定制流程的路由进行控制。
  - 珠宝定制键盘，支持多种字体、文字输入，与页面依赖较低，考虑到后期 iPhone 版的开发，使用 CTMediator 进行组件化开发。将该模块打包成 Pods，通过添加分类和运行时，实现组件之间的引用和关联。后期计划大规模使用组件化，将 UGC 、定制、管理等模块拆分，壳化后细分手机端，在考虑引入 Tea（Elm）架构和去 model 模式，reducer 出 json 进行组件的衔接。

##### 3、直播室聊天模块怎么设计，难点在哪里；

##### 4、怎么从 100 万条数据中选出排在前面的 100 条数据（topK 问题）；

- Hash 去重
- 小顶堆或分治
  - 小顶堆。取 100 条元素，构建小顶堆，顺序往后对比，遇到更大的数则替换堆顶，重新构建小顶堆。O((N-M)logM)，空间复杂度是 M，I/O 比较高；
  - 分治法。分 100 份 1 万的组，取前 100，排序后合并重拍。
- 重拍后，进行合并操作，返回结果。

##### 5、网络-dns，长连接，httpDNS；

- DNS 是网络域名解析服务，当我们对一个域名进行请求时，负责域名解析成 IP 地址。客户端发出请求后，DNS 首先请求本地 DNS 服务器，一般 80%几率能够命中并返回。如果本地 DNS 服务器没有缓存，则往根服务器请求，并逐级请求，命中后返回。使用解析后的 IP 地址进行后续请求。
- HttpDNS，防止 DNS 劫持，因为在域名请求过程中，由于运营商的问题或者黑客篡改 DNS 等风险的存在，导致解析到钓鱼的 DNS 上，存在安全隐患。我们在开发时，一般使用 IP 直连的方式，进行规避。使用 HttpDNS 时需要将域名放入 head 字段，post 时也需要将数据放入，在集成就项目时，可替换 URLProtocol，AFN 需要使用 Runtime 替换。
- 长连接，有状态
  - HTTP 每次请求完成，就会把 TCP 断开，是短链接。用 socket 编程使用 TCP，可以通过代码区控制关闭时间，连接和状态在客户端和服务的进行中一直存在。
  - 三次握手，采用 SYN 握手信号、ACK 消息响应、seq 序列号来进行三次确认连接
  - 四次挥手，握手的 SYN 信号换成了 FIN 信号，最后服务器收到客户机的关闭确认后立即关闭，客户机在时间等待状态结束后关闭，防止收到的 ACK 是上次的确认信号。
  - 套接字是 TCP 协议的封装，调用接口（API）。
  - 实现：通过 Socket 实现，基于 CocoaAsyncSocket 框架，借鉴了 NSURLSession 的设计模式，对 Request、Response 进行封装、序列化，对 Socket 实现了线程常驻、任务式调用和粘包处理等功能。

##### 6、快排实现过程及复杂度，二叉树的遍历前序、后续遍历；

##### 8、聊下性能优化；

- 安装包瘦身
  - 使用 Linked-Map 工具，查看.o 目标文件大小，针对性合并静态库、减少工程类和方法。
  - 如果 Swift 用的少，就删除，纯 OC 编程
  - Assets Catalogs 可以提高 I/O 性能，和一些方便功能，安装包会选择合适的图片倍率下载，但是会增加包体积和缓存占用，视情况选择。
  - 删除无用多媒体文件，包括图片，优先网络请求，使用占位图，尽量用 jpg，不能用的使用 tinypng 有损压缩，定期更新资源包，LSUnusedResources 排查图片， 利用 tint color 精简单色图标。
  - 使用 strip -x 命令处理动态库。
  - Build Settings 中的 Link-Time Optimization=Incremental。
- 性能优化
  - 性能检测
    - 全局，采用 AOP 的方式，在生命周期函数中使用 swizzle 添加统计代码。
    - 局部，使用埋点的方式，针对业务流进行用户路径和漏斗埋点。
    - 代码实时检测内存、CPU、刷新帧率。
    - 使用真机进行测试。
  - 代码优化
    - 选择合适的集合类型，字典和 Set 操作元素都是 O(1)，数组针对对象复杂度是 O(n)，针对索引 O(1)，二分查找 O（log n）。
    - 使用 GCD 将耗时操作放到非主线程上，要控制线程数，防止线程爆炸和死锁。
    - I/O 对性能消耗很大，减少 I/O 次数，合理使用 NSCache，之前 SDWebImage 在 iPad 中未释放内存导致闪退，我还提了 bugfix。
    - 控制 App 的 Wake 次数，如：通知、VoIP、定位、蓝牙都会从 Standby 状态唤起，消耗很大。
  - 启动优化
    - 利用 DYLD_PRINT_STATISTICS 分析 main()函数之前的耗时。
    - Page Fault 重排，减少签名认证时间。
    - 在编译时注册启动优先级，根据不同的优先级，选择在 FinishLaunch/首页/加载完成三种情况下执行。
    - 首页采用预排版，从后台唤醒的冷启动，可以不加载根控制器
  - 网络优化
    - 服务器在香港，网络经常不稳定，有的时候 DNS 无法解析。自建钻石云数据库，金价变动较快，对实时性要求高。
    - 两种重连方式：IP 直连和网关代理服务；
    - 两种重试方式：非关键义务，使用 Http 重试，消除 SSL 风险；原请求重试。
  - Instrument 优化

##### 9、如何保障 App 的数据安全；

- 安装包，防止逆向、反编译
  - 代码混淆，关键字符串混淆、关键文件伪装，如伪装成图片
  - main 函数前关闭 ptrace，防止黑客使用 gdb 或 lldb 调试
  - 越狱检测，高安全应用禁止越狱使用，越狱可使用 Cycript 类语言直接执行库函数
  - 自检，生成 md5，与服务器对比
  - 敏感业务使用 C 或汇编，防止 OC 被注入
- 编码过程，保护敏感信息
  - 对敏感信息加密，存储到 keychain
  - 对敏感信息，使用后清空
  - 敏感信息防止键盘缓存，关闭自动纠错
  - 设置信息获取状态，如：必须解锁后才能获取敏感信息
  - 进入后台时替换截图，防止窥屏
- 网络通信，加密传输
  - 使用 Https
  - 客户端使用 RSA，服务端使用 AES 或 DES
  - 敏感信息分类加密，依次使用 AES、3DES、DES、散列函数等
  - 使用 HttpDNS 防止中间人攻击
  - 关键信息使用二进制协议或自建协议

##### 10、runLoop，和 runloop 的运用，实现细节；

- RunLoop 是通过内部维护的时间来对时间/消息进行管理的一个对象。
- 正常运行在用户态，没有消息管理时会切换到内核态，有消息处理时切换到用户态，用户线程被唤醒。
- main 函数在启动时调用 UIApplication.main 启动主线程的 RunLoop。

##### 11、现在做过的项目哪个最难，对自己的成长帮助最大；

##### 12、多线程与线程同步锁。

#### 自我补充

##### 你的 app 架构是什么，有什么优缺点、为什么这么做、怎么改进

##### Feed 流优化

- 预排版

  - 当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。

  - 对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：FDTemplateLayoutCell。

- 预渲染
  微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。

对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。

- 异步绘制

  - 我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：YYAsyncLayer。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。

  - 当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。

  - 目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。

- 全局并发控制
  当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：

ios_dispatch_blocked_1 ios_dispatch_blocked_2

大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：SocialAppLayout，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。

使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 YYDispatchQueuePool，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。

- 更高效的异步图片加载
  SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。

其他可以改进的地方
上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：

- 列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。
- 再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。
- 目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。
- 把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。
