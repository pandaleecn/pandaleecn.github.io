I"¹<h4 id="1-åˆ†ç±»çš„ç”¨é€”">1. åˆ†ç±»çš„ç”¨é€”</h4>
<p>å£°æ˜ç§æœ‰æ–¹æ³•ã€åˆ†è§£ä½“ç§¯åºå¤§çš„ç±»æ–‡ä»¶ã€æŠŠFrameworkçš„ç§æœ‰æ–¹æ³•å…¬å¼€ã€‚</p>
<h4 id="2-åˆ†ç±»çš„ç‰¹ç‚¹">2. åˆ†ç±»çš„ç‰¹ç‚¹</h4>
<ul>
  <li>è¿è¡Œæ—¶å†³è®®</li>
  <li>å¯ä»¥ä¸ºç³»ç»Ÿç±»æ·»åŠ åˆ†ç±»</li>
</ul>

<h4 id="3-åˆ†ç±»ä¸­çš„å†…å®¹">3. åˆ†ç±»ä¸­çš„å†…å®¹</h4>
<ul>
  <li>å®ä¾‹æ–¹æ³•</li>
  <li>ç±»æ–¹æ³•</li>
  <li>åè®®</li>
  <li>å±æ€§ï¼Œåªå£°æ˜å¯¹åº”çš„getæ–¹æ³•å’Œsetæ–¹æ³•ï¼Œå¹¶æ²¡æœ‰æ·»åŠ å®ä¾‹å˜é‡ã€‚é€šè¿‡å…³è”å¯¹è±¡æ·»åŠ ã€‚</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// objc4-680
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta) {
        if (isMeta) return nil; // classProperties;
        else return instanceProperties;
    }
};
</code></pre></div></div>
<h4 id="4-åŠ è½½è°ƒç”¨æ ˆ">4. åŠ è½½è°ƒç”¨æ ˆ</h4>
<p><img src="http://files.pandaleo.cn/258a5665967ab16c59548fdb65a258cb.png" alt="" />
images: é•œåƒ</p>
<h4 id="5-æºç åˆ†æ">5. æºç åˆ†æ</h4>

<ul>
  <li>åˆ†ç±»æ–¹æ³•å­˜åœ¨é‡åçš„æƒ…å†µä¸‹ï¼Ÿ<br />
æœ€åç¼–è¯‘åˆ†ç±»çš„æ–¹æ³•ä¼šæœ€ç»ˆç”Ÿæ•ˆã€‚</li>
  <li>åˆ†ç±»ä¸ºä»€ä¹ˆæ˜¯è¿è¡Œæ—¶å®ç°ï¼Ÿ<br />
è¿è¡Œæ—¶å°†attachListçš„å†…å®¹æ‹¼æ¥åˆ°rwå¯¹è±¡çš„methodä¸Šã€‚</li>
  <li>
    <p>åˆ†ç±»æ–¹æ³•å†…å­˜è¦†ç›–çš„æ–¹å¼ï¼Ÿ<br />
å°†åŸæœ‰åˆ†ç±»åœ¨å†…å­˜ä¸­çš„ä½ç½®æ•´ä½“åç§»ï¼Œæ–°çš„åˆ†ç±»æ’å…¥åœ¨å‰é¢æ–°å¼€è¾Ÿçš„å†…å­˜ç©ºé—´ã€‚</p>
  </li>
  <li>æ€»ç»“ï¼š
    <ul>
      <li>åˆ†ç±»æ·»åŠ çš„æ–¹æ³•æ˜¯å¯ä»¥â€œè¦†ç›–â€åŸç±»æ–¹æ³•ï¼Œæ•ˆæœä¸Šè¦†ç›–ï¼ŒåŸæ–¹æ³•ä»åœ¨ï¼›</li>
      <li>åŒååˆ†ç±»æ–¹æ³•è°èƒ½ç”Ÿæ•ˆå–å†³äºç¼–è¯‘é¡ºåºï¼Œæœ€åè¢«ç¼–è¯‘çš„åˆ†ç±»ä¼šæœ€ä¼˜å…ˆç”Ÿæ•ˆï¼›</li>
      <li>åå­—ç›¸åŒçš„åˆ†ç±»ä¼šå¼•èµ·ç¼–è¯‘æŠ¥é”™ï¼Œä¼šæ·»åŠ åˆ°å®¿ä¸»ç±»ï¼Œå’ŒåŒåå˜é‡ç±»ä¼¼ã€‚</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void remethodizeClass(Class cls)
{

            â€¦â€¦

        // åªåˆ†ææ·»åŠ å®ä¾‹æ–¹æ³•ï¼ŒisMeta = NO
        isMeta = cls-&gt;isMetaClass();

        // è·å–clsä¸­æœªå®Œæˆæ•´åˆçš„æ‰€æœ‰åˆ†ç±»
        if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {
        if (PrintConnecting) {
            _objc_inform("CLASS: attaching categories to class '%s' %s",
                         cls-&gt;nameForLogging(), isMeta ? "(meta)" : "");
        }

        // å°†åˆ†ç±»catsæ‹¼æ¥åˆ°clsä¸Š
        attachCategories(cls, cats, true /*flush caches*/);        
        free(cats);
    }

            â€¦â€¦

}

// Attach method lists and properties and protocols from categories to a class.
// Assumes the categories in cats are all loaded and sorted by load order,
// oldest categories first.
static void
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return;
    if (PrintReplacedMethods) printReplacements(cls, cats);

    bool isMeta = cls-&gt;isMetaClass();

    // fixme rearrange to remove these intermediate allocations

    // method_list_tæ ¼å¼ï¼š[[method_t, method_t, â€¦], [method_t], [method_t, method_t, method_t],â€¦]

    method_list_t **mlists = (method_list_t **)
        malloc(cats-&gt;count * sizeof(*mlists));
    property_list_t **proplists = (property_list_t **)
        malloc(cats-&gt;count * sizeof(*proplists));
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats-&gt;count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int propcount = 0;
    int protocount = 0;
    int i = cats-&gt;count;  // å®¿ä¸»ç±»åˆ†ç±»çš„æ€»æ•°
    bool fromBundle = NO;
    while (i--) { // å€’åºéå†ï¼Œæœ€å…ˆè®¿é—®æœ€åç¼–è¯‘çš„åˆ†ç±»
        auto&amp; entry = cats-&gt;list[i];

        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi-&gt;isBundle();
        }

        property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);
        if (proplist) {
            proplists[propcount++] = proplist;
        }

        protocol_list_t *protolist = entry.cat-&gt;protocols;
        if (protolist) {
            protolists[protocount++] = protolist;
        }
    }

    auto rw = cls-&gt;data();

    /*
        rwä»£è¡¨ç±»ï¼Œmethodsä»£è¡¨ç±»çš„æ–¹æ³•åˆ—è¡¨ï¼ŒattachListsæ–¹æ³•å°†å¤šä¸ªmlistsæ‹¼æ¥åˆ°rwçš„methodsä¸Š
    */
    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    rw-&gt;methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

    rw-&gt;properties.attachLists(proplists, propcount);
    free(proplists);

    rw-&gt;protocols.attachLists(protolists, protocount);
    free(protolists);
}

/*

addedLists=method_list_tæ ¼å¼ï¼š[[method_t, method_t, â€¦], [method_t], [method_t, method_t, method_t],â€¦]
addedCount=3, åˆ†ç±»æ•°

*/
void attachLists(List* const * addedLists, uint32_t addedCount) {

    if (hasArray()) {
            // many lists -&gt; many lists
            uint32_t oldCount = array()-&gt;count;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
            array()-&gt;count = newCount;

            /* åŸæœ‰å…ƒç´ åç§»ï¼Œå¼€è¾Ÿæ–°ç©ºé—´ï¼Œæ·»åŠ å…ƒç´ æ”¾åœ¨å‰é¢
            [
                [method_t, method_t, â€¦], // addedListsä¸­ç¬¬ä¸€ä¸ªåˆ†ç±»çš„æ–¹æ³•åˆ—è¡¨
                [method_t],
                [method_t, method_t, method_t],
                åŸæœ‰ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œ
                åŸæœ‰ç¬¬äºŒä¸ªå…ƒç´ ï¼Œ
                â€¦â€¦
            ]
            */

            memmove(array()-&gt;lists + addedCount, array()-&gt;lists,
                    oldCount * sizeof(array()-&gt;lists[0]));
            memcpy(array()-&gt;lists, addedLists,
                   addedCount * sizeof(array()-&gt;lists[0]));
    }

                        â€¦â€¦

}



</code></pre></div></div>
:ET