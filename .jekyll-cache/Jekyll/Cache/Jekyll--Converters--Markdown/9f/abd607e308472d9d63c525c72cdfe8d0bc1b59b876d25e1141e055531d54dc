I")<h3 id="一内存管理的数据结构">一、内存管理的数据结构</h3>

<h4 id="1-spinlock_t自旋锁">1. Spinlock_t，自旋锁</h4>
<ul>
  <li>Spinlock_t是“忙等”的锁。
如果当前锁已被其他线程获取，当前线程会不断探测锁是否被释放，如果释放会第一时间获取。正常信号量获取不到锁时，会把自我线程阻塞休眠，等其他线程释放时，会唤醒自我线程。</li>
  <li>适用于轻量访问。
SideTable表，对某对象进行引用计数操作时，+1和-1类轻量访问可以使用自选所。</li>
  <li>更多自旋锁内容会在后续多线程中分析。</li>
</ul>

<h4 id="2-refcountmap引用计数表">2. RefcountMap，引用计数表</h4>
<p><img src="http://files.pandaleo.cn/23b5f3afa646a4859ab255eb896ac2ba.png" alt="" /></p>
<ul>
  <li>哈希表。哈希算法，通过同一个方法生成和获取value，避免遍历操作，能够直接查找到对应值。
ptr，指针。</li>
  <li>size_t
<img src="http://files.pandaleo.cn/2a36370243607a14599b9e7bfae335fe.png" alt="" />
    <ul>
      <li>RC，实际引用计数值。实际使用时，需要右移，减去后两位的使用。</li>
    </ul>
  </li>
</ul>

<h4 id="3-weak_table_t弱引用表">3. weak_table_t，弱引用表</h4>
<p><img src="http://files.pandaleo.cn/09d1da213bac4275a9727aa54d849aaf.png" alt="" /></p>

<h3 id="二引用计数管理">二、引用计数管理</h3>

<h4 id="1-mrc手动引用计数">1. MRC，手动引用计数</h4>
<p><img src="http://files.pandaleo.cn/47a6faa832e0d9272b73f8b3bad52adf.png" alt="" /></p>
<ul>
  <li>alloc，分配对象内存空间</li>
  <li>retain，对对象的引用计数+1</li>
  <li>release，对对象的引用计数-1</li>
  <li>retainCount， 获取当前对象的引用计数值</li>
  <li>autorelease，当前对象autoreleasePool结束时，调用release操作，进行引用计数-1</li>
  <li>dealloc，MRC需要显式调用super.dealloc，释放父类的相关成员变量。MRC需要使用红色方法，ARC使用时会报错。</li>
</ul>

<h4 id="2-arc自动引用计数">2. ARC，自动引用计数</h4>
<ul>
  <li>ARC是LLVM(编译器)和Runtime协作的结果，来实现自动引用计数的管理。</li>
  <li>ARC中禁止手动调用retail/release/retainCount/dealloc。</li>
  <li>ARC中新增weak、strong属性关键字。</li>
</ul>

<h4 id="3-引用计数管理实现原理分析">3. 引用计数管理(实现原理分析)</h4>
<ul>
  <li>alloc实现
    <ul>
      <li>经过一系列调用，最终调用了C函数calloc。</li>
      <li>此时并没有设置引用计数为1。</li>
    </ul>
  </li>
  <li>retain实现
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 两次哈希查找
SideTable&amp; table = SideTables()[this];
size_t&amp; refcntStorage = table.refcnts[this];

// SIDE_TABLE_RC_ONE，包含偏移量，最终含义是+1操作。
recntStorage += SIDE_TABLE_RC_ONE；
</code></pre></div>    </div>
  </li>
  <li>release实现
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SideTable&amp; table = SideTables()[this];
RefcountMap::iterator it = table.refcnts.find(this);
it-&gt;second -= SIDE_TABLE_RC_ONE;
</code></pre></div>    </div>
  </li>
  <li>retainCount实现
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SideTable&amp; table = SideTables()[this];
// alloc时没设置，获取时初始值为1。
size_t refcnt_result = 1;
RefcountMap::iterator it = table.refcnts.find(this);
refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;
</code></pre></div>    </div>
  </li>
  <li>dealloc实现
<img src="http://files.pandaleo.cn/66ba2da1d0cfdd232c6cc214c6e4a909.png?imageMogr2/thumbnail/!70p" alt="" /></li>
  <li>object_dispose()实现
<img src="http://files.pandaleo.cn/b8b1cd1b9a7ce50b1d42816d8d96b351.png" alt="" /></li>
  <li>objc_destructInstance()实现
<img src="http://files.pandaleo.cn/364674963eb25a9eccf074a5199cfbe2.png?imageMogr2/thumbnail/!70p" alt="" /></li>
  <li>clearDeallocation()实现
<img src="http://files.pandaleo.cn/4e4db0db011e599754c5eb328e57245f.png?imageMogr2/thumbnail/!70p" alt="" /></li>
</ul>

<h4 id="4-弱引用管理">4. 弱引用管理</h4>
<p><img src="http://files.pandaleo.cn/60f887f03cb8b5b0d7f46cf6122add85.png" alt="" /></p>
<ul>
  <li>添加weak变量
<img src="http://files.pandaleo.cn/0eefe73afc05cd5e5012525c21b04d03.png?imageMogr2/thumbnail/!50p" alt="" />
具体添加位置，通过弱引用对象进行哈希算法的计算。<br />
调用weak_register_no_lock方法，将weak ptr的地址记录到newObj对应的weak_entry_t中</li>
  <li>清除weak变量，同时设置指向为nil
<img src="http://files.pandaleo.cn/2a93fa68333eb321eb61a4c66c66aab0.png?imageMogr2/thumbnail/!50p" alt="" />
根据当前对象指针，查找引用表，把当前对象相对应的弱引用数组取出，遍历指针，分别置位nil。</li>
</ul>

<h4 id="5-自动释放池">5. 自动释放池</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- （void)viewDidLoad
{
    [super viewDidLoad];
    NSMutableArray *array = [NSMutableArray array];
    NSLog(@"%@“,array);
}
// array对象的内存何时释放？当次runloop将要结束调用AutoreleasePoolPage::pop()时释放。
</code></pre></div></div>
<ul>
  <li>AutoreleasePool实现原理
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 编译器会将@autoreleasepool{}改写为：
Void *ctx = objc_autoreleasePoolPush();
{}中的代码
objc_autoreleasePoolPop(ctx);
</code></pre></div>    </div>
  </li>
  <li>objc_autoreleasePoolPush
<img src="http://files.pandaleo.cn/5ee9a07b874c725fa533d77b6f02ada5.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>AutoreleasePoolPop
<img src="http://files.pandaleo.cn/4787bb17211c3c7d4ddc5784c5d544e7.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>实现结构
    <ul>
      <li>是以栈为节点通过双向链表的形式组合而成。
<img src="http://files.pandaleo.cn/8920b4605f0b9155eee3692453badbc5.png?imageMogr2/thumbnail/!60p" alt="" />
<img src="http://files.pandaleo.cn/c135345c0044cc506e6a05d3613fdbce.png?imageMogr2/thumbnail/!60p" alt="" /></li>
      <li>是和线程一一对应。</li>
    </ul>
  </li>
  <li>AutoreleasePoolPage
<img src="http://files.pandaleo.cn/93ebff49dad99bad66def3111e73276d.png?imageMogr2/thumbnail/!50p" alt="" />
<img src="http://files.pandaleo.cn/e60618f524c6d087f313ec52ebf022e9.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>AutoreleasePoolPange::push
<img src="http://files.pandaleo.cn/e3bec2c894a5a0e97951d322344d1d65.png?imageMogr2/thumbnail/!50p" alt="" />
每次push会不断地插入哨兵对象</li>
  <li>[obj autorelease]
<img src="http://files.pandaleo.cn/c0c8b6a96403b19bbadc7fb420830e18.png?imageMogr2/thumbnail/!50p" alt="" />
<img src="http://files.pandaleo.cn/49b9b56abd6202fb9e60a1329b16fdcf.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>AutoreleasePoolPage::pop
    <ul>
      <li>根据传入的哨兵对象找到对应位置</li>
      <li>给上次push操作之后添加的对象依次发送release消息</li>
      <li>回退next指针到正确位置
<img src="http://files.pandaleo.cn/91104c73af8de4f2b3598dcc887da018.png?imageMogr2/thumbnail/!50p" alt="" /></li>
    </ul>
  </li>
  <li>自动释放池总结
    <ul>
      <li>在当次runloop将要结束的时候调用AutoreleasePoolPage::pop()。</li>
      <li>多层嵌套就是多次插入哨兵对象。</li>
      <li>在for循环中alloc图片数据等内存你消耗较大的场景手动插入autoreleasePool，降低内存峰值。</li>
    </ul>
  </li>
</ul>

<h4 id="6-三种循环引用">6. 三种循环引用</h4>
<ul>
  <li>自循环引用，强持有的成员变量，赋值给原对象
<img src="http://files.pandaleo.cn/e61f3a8f6aadecf6fe7ce32efaa344e7.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>相互循环引用
<img src="http://files.pandaleo.cn/8f100ee7fa96daf0bbadf171db440927.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>多循环引用
<img src="http://files.pandaleo.cn/54dc4f064f8576491e41eec88c4ff2a9.png?imageMogr2/thumbnail/!50p" alt="" /></li>
  <li>常见循环引用：代理、Block、NSTimer、大环引用</li>
  <li>破除方式
    <ul>
      <li>避免产生循环引用</li>
      <li>在合适的实际手动断环</li>
    </ul>
  </li>
  <li>解决方案
    <ul>
      <li>__weak，代理和block时使用
<img src="http://files.pandaleo.cn/374dbf153dd0d991d0861f65d567abf0.png?imageMogr2/thumbnail/!50p" alt="" /></li>
      <li>__block，block时使用
        <ul>
          <li>MRC下，__block修饰对象不会增加其引用计数，避免了循环引用</li>
          <li>ARC下，__block修饰的对象会被引用，无法避免循环引用，需手动解环</li>
        </ul>
      </li>
      <li>__unsafe_unretained = __weak，不建议使用。
        <ul>
          <li>修饰对象不会增加其引用计数，避免了循环引用。</li>
          <li>如果被修饰对象在某一时机被释放，会产生悬垂指针！</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>常见示例
    <ul>
      <li>block在后面章节分析</li>
      <li>NSTimer循环引用
<img src="http://files.pandaleo.cn/625ea36e362336d039c870fa614c0198.png" alt="" />
        <ul>
          <li>单次循环，在结束回调中置空</li>
          <li>多次循环
<img src="http://files.pandaleo.cn/fb19304e294885567bf0bf3272cba59d.png" alt="" /></li>
          <li>代码实现</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<pre>
// 在中间对象中，判断对象为空时回收timer
- （void)fire:(NSTimer *)timer
{
    if (self.target) {
        if (self.target respondsToSelector:self.selector]) {
            [self performSelector: self.selector withObject:timer.userInfo];
        }
    } else {
        [self.timer invalidate];
    }
}
</pre>
<h4 id="7-总结">7. 总结</h4>
<ul>
  <li>什么是ARC？
ARC是由LLVM编译器和Runtime共同协作实现自动引用计数的管理。</li>
  <li>为什么weak指针指向的对象在废弃之后会被自动置位nil？
当对象被废弃之后，dealloc方法的内部实现当中会调用清除弱引用方法，在方法中会通过哈希算法查找被废弃对象在弱引用表中的位置，提取被废弃对象在弱引用表中的列表数组，进行for循环遍历，把每个weak指针都置位nil。</li>
  <li>苹果是如何实现AutoreleasePool的？
AutoreleasePool是以栈为节点，由双向列表合成的数据结构。</li>
</ul>
:ET