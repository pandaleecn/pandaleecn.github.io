I".<h3 id="一六大设计原则">一、六大设计原则</h3>
<h4 id="1-单一职责原则">1. 单一职责原则</h4>
<ul>
  <li>一个类只负责一件事</li>
  <li>如：UIView和CALayer，UIView只负责时间传递和响应，CALayer只负责动画和视图的显示</li>
</ul>

<h4 id="2-开闭原则">2. 开闭原则</h4>
<ul>
  <li>对修改关闭、对扩展开放</li>
  <li>对类的定义应该考虑其扩展性和灵活性，对需求应该考虑后续的版本和迭代，谨慎定义成员变量，尽量避免对类的反复修改。</li>
  <li>对扩展开放，定义好数据结构，后续只需要添加接口和子类集成。</li>
</ul>

<h4 id="3-接口隔离原则">3. 接口隔离原则</h4>
<ul>
  <li>使用多个专门的协议、而不是一个庞大臃肿的协议。</li>
  <li>如：UITableViewDelegate专门处理UITableView的代理事件，UITableViewDataSource专门UITableView的获取数据源</li>
  <li>协议中的方法应当尽量少</li>
</ul>

<h4 id="4-依赖倒置原则">4. 依赖倒置原则</h4>
<ul>
  <li>抽象不应该依赖于具体实现，具体实现可以依赖于抽象</li>
  <li>如：定义数据访问，增删改查接口方法时，所有上层的业务调用都应该依赖定义的抽象接口。接口内部的接口实现，用文件或数据库等，对上层业务实现是感知不到的。通过抽象接口，反转依赖。</li>
</ul>

<h4 id="5-里氏替换原则">5. 里氏替换原则</h4>
<ul>
  <li>父类可以被子类无缝替换，且原有功能不受任何影响。</li>
  <li>如：KVO实现原理，当调用addObserver方法时，系统对动态运行时创建子类，使用的类被系统无感替换成子类。</li>
</ul>

<h4 id="6-迪米特法则">6. 迪米特法则</h4>
<ul>
  <li>一个对象应当对其他对象有尽可能少的了解</li>
  <li>高内聚、低耦合</li>
</ul>

<h3 id="二五大设计模式">二、五大设计模式</h3>
<h4 id="1-责任链">1. 责任链</h4>
<ul>
  <li>一个关于需求变更的问题
<img src="http://files.pandaleo.cn/d17f04e8013182603a8b798b15867521.png?imageMogr2/thumbnail/!68p" alt="" />
<img src="http://files.pandaleo.cn/560646087b2926a195e215037e33f5bf.png?imageMogr2/thumbnail/!68p" alt="" /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// BusinessObject.h
#import &lt;Foundation/Foundation.h&gt;
@class BusineessObject;
typedef void(^CompletionBlock)(BOOL handled);
typedef void(^ResultBlock)(BusinessObject *handler, BOOL handled);

@interface BusinessObject : NSObject

// 下一个响应者（响应链构成的关键）
@property (nonatomic, strong) BusinessObject *nextBusiness;
// 响应者的处理方法
// 入口/节点函数
- (void)handle:(ResultBlock)result;

// 各个业务在该方法当中做实际业务处理
// Block在业务涉及到异步网络请求，如图片查询操作逻辑时使用
- (void)handleBusiness:(CompletionBlock)completion;
@end

# import “BusinessObject.h”
@implementation BusinessObject

// 责任链入口方法
- (void)handle:(ResultBlock)result
{
    CompletionBlock completion = ^(BOOL handled) {
        // 当前业务处理掉了，上抛结果
        if (handled) {
            result(self, handled);
        }
        else {
            // 沿着责任链，指派给下一个业务处理
            if (self.nextBusiness) {
                [self.nextBusiness handle:result];
            }
            else {
                // 找到责任链末尾，没有业务处理，上抛
                result(nil, NO);
            }
        }
    }

    // 当前业务处理
    [self handleBusiness:completion];
}

- (void)handleBusiness:(CompletionBlock)completion
{
    /*
    业务逻辑处理
    如网络请求、本地图库查询等
    */

}

@end
</code></pre></div></div>
<ul>
  <li>解决方案：
<img src="http://files.pandaleo.cn/a5989905206d172b41eca9029cc5628d.png?imageMogr2/thumbnail/!68p" alt="" />
    <ul>
      <li>调整优先级时，只需要调整对应nextResponder指向，或改为Server动态下发</li>
      <li>实现业务需求的动态调整：
        <ul>
          <li>为业务定义业务号，每个业务号对应类。</li>
          <li>将对应关系制作成plist文件，通过服务端下发，调整相应顺序。</li>
          <li>通过代码的class反射，解析对应类，按数组顺序制定下一响应者。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-桥接">2. 桥接</h4>
<ul>
  <li>一个关于业务解耦的问题
<img src="http://files.pandaleo.cn/709a5acca7a41cc343f782f6db6a1961.png?imageMogr2/thumbnail/!68p" alt="" /></li>
  <li>类构成
<img src="http://files.pandaleo.cn/e33df49f378015a0602b64df232ec9ba.png?imageMogr2/thumbnail/!68p" alt="" /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 桥接A
@interface BaseObjectA : NSObject

// 桥接模式的核心实现
@property (nonatomic, strong) BaseObjectB *objB;

// 获取数据
- (void)handle;

@end

@implementation BaseObjectA

/*
    A1 —&gt; B1、B2、B3   3种
    A2 —&gt; B1、B2、B3   3种
    A3 —&gt; B1、B2、B3   3种
*/

- (void)handle
{
    // override to subclass
    [self.objB fetchData];
}

@implementation ObjectA1

- (void)handle
{
    // before 业务逻辑操作

    [super handle];

    // after 业务逻辑操作
}

@end

// 桥接B
@interface BaseObjectB : NSObject

- (void)fetchData;

@end

@implementation BaseObjectB

- (void)fetchData
{
    // override to subclass
    // 抽象类，提供服务
}

@end

@interface BaseObjectB1 : NSObject

@end

@implementation ObjectB1

- (void)fetchData {
    // 具体的逻辑处理
}
@end

// 桥接模式适用房
@interface BridgeDemo()
@property (nonatomic, strong) BaseObjectA *objA;
@end

@implentation BridgeDemo

/*
    根据实际业务判断使用哪套具体数据
    A1 —&gt; B1、B2、B3   3种
    A2 —&gt; B1、B2、B3   3种
    A3 —&gt; B1、B2、B3   3种
*/

- (void)fetch
{
    // 创建一个具体ClassA
    _objA = [[ObjectA1 alloc] init];

    // 创建一个具体的ClassB
    BaseObjectB *b1 = [[ObjectB1 alloc] init];
    // 将一个具体的ClassB1 指定给抽象的ClassB
    _objA.objB = b1;

    // 获取数据
    [_objA handle];
}
</code></pre></div></div>
<ul>
  <li>应用场景：网络请求时，使用不同的接口请求参数，返回不同的对象模型</li>
</ul>

<h4 id="3-适配器">3. 适配器</h4>
<ul>
  <li>一个现有类需要适应变化的问题</li>
  <li>文件产生已久，经过需求迭代类文件比较成熟和稳定，对类成员变量和方法修改时风险很大。</li>
  <li>对象适配器
<img src="http://files.pandaleo.cn/52d9eb4f79a8635df69571d6bde9bd58.png?imageMogr2/thumbnail/!68p" alt="" /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)request {
    // 适配逻辑
    [被适配对象 某方法];
    // 适配逻辑
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 具体实现

// 被适配对象
@interface Target : Object

- (void)operation;

@end

@implementation Target

- (void)operation
{
    // 原有的具体业务逻辑
}

@end

// 适配对象
@interface CoolTarget : Object

// 被适配对象
@property (nonatomic, strong) Target *target;

// 对原有方法包装
- (void)request;

@end


@implementation CoolTarget


- (void)request
{
    // 额外处理
    [self.target operation];
    // 额外处理
}


@end
</code></pre></div></div>
<ul>
  <li>类适配器</li>
</ul>

<h4 id="4-单例">4. 单例</h4>
<ul>
  <li>可能用的并不正确</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@implementation Panda

+ (id)sharedInstance
{
    // 静态局部变量
    static Panda *instance = nil;

    // 通过dispatch_once方式，确保instance在多线程环境下只被创建一次
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 创建实例
        // 注意1：重写allocWithZone时，会调用self的sharedInstance，如果使用self的allocWithZone时，初始化会引起循环调用。
        instance = [[super allocWithZone:NULL] init];
    });
    return instance;
}

// 注意2：重写方法【必不可少】，不通过sharedInstance创建方法时，如alloc init。
+ (id)allocWithZone:(struct _NSZone *)zone{
    return [self sharedInstance];
}

// 注意3：重写方法【必不可少】，通过对当前实例通过copy操作创建。
+ (id)copyWithZone:(nullable NSZone *)zone{
    return self;
}
</code></pre></div></div>

<h4 id="5-命令">5. 命令</h4>
<ul>
  <li>行为参数化，定义</li>
  <li>降低代码重合度，作用</li>
  <li>如：微博，转发、评论、赞，在不同页面产生行为，封装成行为参数化形式，执行命令</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@class Command;
typedef void(^CommandCompletionCallBack)(Command* cmd);

@interface Command : NSObject
@property (nonatomic, copy) CommandCompletionCallBack completon;

- (void)execute;
- (void)cancel;
- (void)done;

@end

@inplementation Command

- (void)execute {

    // override to subclass;

    [self done];

}

- (void)cancel {

    self.completion = nil;
}

- (void)done {

    // 不能确定命令是否在子线程，需要异步回到主队列通知调用方
    dispatch_async(dispatch_get_main_queue(), ^{

        if (_completion) {
            _completion(self);
        }

        // 释放
        self.cmpletion = nil;

        [[CommandManager shareInstance].arrayCommands removeObject:self];

    });

}

@end

// 命令管理者
@interface CommandManager : NSObject

// 命令管理容器
@property (nonatomic, strong) NSMutableArray &lt;Command*&gt; *arrayCommands;

// 命令管理者以单例方式呈现
+ (instancetype)sharedInstance;

// 执行命令
+ (void)executeCommand:(Command *)cmd completion: (CommandCompletionCallBack)completion;

// 取消命令
+ (void)cancelCommand:(Command *)cmd;

@end

@implementation CommandManager

+ (instancetype)sharedInstance
{
    static CommandManager *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        instance = [[super allocWithZone:NULL] init];
    });
    return instance;
}

+ (id)allocWithZone:(struct _NSZone *)zone{
    return [self sharedInstance];
}

+ (id)copyWithZone:(nullable NSZone *)zone{
    return self;
}

+ (void)executeCommand:(Command *)cmd completion: (CommandCompletionCallBack)completion
{
    if(cmd) {
        // 如果命令正在执行不做处理，否则添加并执行命令
        if (![self _isExecutingCommand:cmd]) {
            // 添加到命令容器当中
            [[self sharedInstance] arrayCommands] addObject:cmd];
            // 设置命令执行完成的回调
            cmd.completion = completion;
            // 执行命令
            [cmd execute];
        }
    }
}

+ (void)cancelCommand:(Command *)cmd
{
    if (cmd) {
        // 从命令容器当中移除
        [[self sharedInstance] arrayCommands] removeObject:cmd];
        // 取消命令执行
        [cmd cancel];
    }
}

// 判断当前命令是否正在执行
+ (BOOL)_isExecuingCommand:(Command *)cmd
{
    if (cmd) {
        NSArray *cmds = [[self sharedInstance] arrayCommands];
        for (Command *aCmd in cmds) {
            // 当前命令正在执行
            if (cmd == aCmd) {
                return YES;
            }
        }
    }
}
</code></pre></div></div>
:ET