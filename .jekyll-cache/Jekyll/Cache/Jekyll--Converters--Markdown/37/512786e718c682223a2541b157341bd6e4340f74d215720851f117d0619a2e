I"à\<p>Swift 4 çš„ä¸€ä¸ªä¸»è¦ç‰¹æ€§å°±æ˜¯å®šä¹‰äº†ä¸€å¥—æ ‡å‡†çš„ç¼–ç å’Œè§£ç æ•°æ®çš„æ–¹æ³•ï¼Œæ‰€æœ‰çš„è‡ªå®šä¹‰ç±»å‹éƒ½èƒ½é€‰æ‹©ä½¿ç”¨è¿™å¥—æ–¹æ³•ã€‚</p>
<ul>
  <li>ç¼–ç ï¼Œå°†ç¨‹åºå†…éƒ¨çš„æ•°æ®ç»“æ„åºåˆ—åŒ–ä¸ºä¸€äº›å¯äº¤æ¢çš„æ•°æ®æ ¼å¼ã€‚</li>
  <li>è§£ç ï¼Œåè¿‡æ¥å°†é€šç”¨çš„æ•°æ®æ ¼å¼ååºåˆ—åŒ–ä¸ºå†…éƒ¨ä½¿ç”¨çš„æ•°æ®ç»“æ„ã€‚</li>
</ul>

<h3 id="ä¸€æ¦‚è§ˆ">ä¸€ã€æ¦‚è§ˆ</h3>
<h4 id="1-codable-ç³»ç»Ÿçš„ä¸‰ä¸ªæ ¸å¿ƒç›®æ ‡">1. Codable ç³»ç»Ÿçš„ä¸‰ä¸ªæ ¸å¿ƒç›®æ ‡</h4>
<ul>
  <li>æ™®éæ€§ - å®ƒå¯¹ç»“æ„ä½“ï¼Œæšä¸¾å’Œç±»éƒ½é€‚ç”¨ã€‚</li>
  <li>ç±»å‹å®‰å…¨ - ä»£ç éœ€è¦ä½¿ç”¨å¼ºç±»å‹çš„æ•°æ®ï¼Œè€Œ JSON ç±»å¯äº¤æ¢æ ¼å¼é€šå¸¸éƒ½æ˜¯å¼±ç±»å‹ã€‚</li>
  <li>å‡å°‘æ¨¡æ¿ä»£ç  - åŠ å…¥è‡ªå®šä¹‰ç±»å‹ï¼Œå¼€å‘è€…å°½å¯èƒ½å°‘åœ°å†™é‡å¤çš„â€œé€‚é…ä»£ç â€ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆã€‚</li>
</ul>

<h4 id="2-æŸä¸ªç±»å‹é€šè¿‡å£°æ˜è‡ªå·±éµå®ˆ-encodable-å’Œæˆ–-decodable-åè®®æ¥è¡¨æ˜è‡ªå·±å…·å¤‡è¢«åºåˆ—åŒ–å’Œæˆ–ååºåˆ—åŒ–çš„èƒ½åŠ›">2. æŸä¸ªç±»å‹é€šè¿‡å£°æ˜è‡ªå·±éµå®ˆ Encodable å’Œ/æˆ– Decodable åè®®æ¥è¡¨æ˜è‡ªå·±å…·å¤‡è¢«åºåˆ—åŒ–å’Œ/æˆ–ååºåˆ—åŒ–çš„èƒ½åŠ›ã€‚</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// æŸä¸ªç±»å‹å¯ä»¥å°†è‡ªèº«ç¼–ç ä¸ºä¸€ç§å¤–éƒ¨è¡¨ç¤ºã€‚
public protocol Encodable {
  /// å°†å€¼ç¼–ç åˆ°ç»™å®šçš„ encoder ä¸­ã€‚
  public func encode(to encoder: Encoder) throws
}
/// æŸä¸ªç±»å‹å¯ä»¥ä»å¤–éƒ¨è¡¨ç¤ºä¸­è§£ç å¾—åˆ°è‡ªèº«ã€‚
public protocol Decodable {
  /// é€šè¿‡ä»ç»™å®šçš„ decoder ä¸­è§£ç æ¥åˆ›å»ºæ–°çš„å®ä¾‹ã€‚
  public init(from decoder: Decoder) throws
}
</code></pre></div></div>
<h4 id="3-æ ‡å‡†åº“æä¾›äº†-codable-ç±»å‹åˆ«åä½œä¸ºä¸¤ä¸ªåè®®çš„ç»„åˆ">3. æ ‡å‡†åº“æä¾›äº† Codable ç±»å‹åˆ«åï¼Œä½œä¸ºä¸¤ä¸ªåè®®çš„ç»„åˆ</h4>
<p>public typealias Codable = Decodable &amp; Encodable</p>
<h4 id="4-æ ‡å‡†åº“ä¸­-codable-ç±»å‹">4. æ ‡å‡†åº“ä¸­ Codable ç±»å‹</h4>
<ul>
  <li>Boolï¼Œæ•°å€¼ç±»å‹å’Œ String ç­‰æ‰€æœ‰åŸºæœ¬ç±»å‹ã€‚</li>
  <li>å«æœ‰ Codable å…ƒç´ çš„å¯é€‰å€¼ï¼Œæ•°ç»„ï¼Œå­—å…¸å’Œé›†åˆã€‚</li>
  <li>Dataï¼ŒDateï¼ŒURLï¼ŒCGPoint å’Œ CGRect åœ¨å†…çš„è®¸å¤š Apple æ¡†æ¶ä¸­çš„å¸¸ç”¨æ•°æ®ç±»å‹ã€‚</li>
</ul>

<h4 id="5-æ‹¥æœ‰-codable-ç±»å‹çš„å€¼å¯ä»¥åˆ›å»ºä¸€ä¸ªç¼–ç å™¨å’Œä¸€ä¸ªè§£ç å™¨">5. æ‹¥æœ‰ codable ç±»å‹çš„å€¼å¯ä»¥åˆ›å»ºä¸€ä¸ªç¼–ç å™¨å’Œä¸€ä¸ªè§£ç å™¨ã€‚</h4>
<ul>
  <li>ç¼–ç å™¨å°†å€¼è½¬åŒ–ä¸º JSON ç±»çš„ç›®æ ‡æ ¼å¼ï¼Œè§£ç å™¨å°†åºåˆ—åçš„æ•°æ®è½¬å›åŸç±»å‹çš„å®ä¾‹ã€‚</li>
  <li>Encoder å’Œ Decoder åè®®å¹¶æ²¡æœ‰æ¯” Encodable å’Œ Decodable å¤æ‚å¤ªå¤šã€‚</li>
  <li>ç¼–ç å™¨å’Œè§£ç å™¨çš„æ ¸å¿ƒä»»åŠ¡æ˜¯ç®¡ç†é‚£äº›ç”¨æ¥å­˜å‚¨åºåˆ—åçš„æ•°æ®çš„å®¹å™¨çš„å±‚æ¬¡ã€‚é™¤éä½ æƒ³è¦åˆ›å»ºè‡ªå·±çš„ç¼–è§£ç å™¨ï¼Œå¦åˆ™ä½ å¾ˆå°‘æœ‰éœ€è¦å’Œ Encoder åŠ Decoder åè®®ç›´æ¥æ‰“äº¤é“ï¼Œä¸è¿‡ï¼Œå¦‚æœä½ æƒ³è¦è‡ªå®šä¹‰ä½ è‡ªå·±ç±»å‹çš„ç¼–è§£ç è¿‡ç¨‹ï¼Œç†è§£è¿™äº›ç»“æ„ä»¥åŠä¸‰ç§ç±»å‹çš„å®¹å™¨è¿˜æ˜¯æœ‰å¿…è¦çš„ã€‚</li>
</ul>

<h3 id="äºŒæœ€å°çš„ä¾‹å­">äºŒã€æœ€å°çš„ä¾‹å­</h3>
<h4 id="1-è‡ªåŠ¨éµå¾ªåè®®">1. è‡ªåŠ¨éµå¾ªåè®®</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åªè¦ç±»å‹æ»¡è¶³ Codable åè®®ï¼Œå°±ç¼–ç¨‹å¯å˜è§£ç çš„ç±»å‹äº†ã€‚
// Swift ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®ä½ ç”Ÿæˆä¸å¯è§çš„ä»£ç ï¼Œæ¥å®ç° Encodable å’Œ Decodable åè®®ã€‚

struct Coordinate: Codable {
  var latitude: Double
  var longitude: Double
  // ä¸éœ€è¦å®ç°
}

struct Placemark: Codable {
  var name: String
  var coordinate: Coordinate
}
</code></pre></div></div>
<h4 id="2-encoding-ä¸-decoding">2. Encoding ä¸ Decoding</h4>
<p>Swift è‡ªå¸¦ä¸¤ä¸ªç¼–ç å™¨ï¼Œåˆ†åˆ«æ˜¯ JSONEncoder å’Œ PropertyListEncoderï¼Œå®ƒä»¬å­˜åœ¨äº Foundation ä¸­ï¼Œè€Œæ²¡æœ‰è¢«å®šä¹‰åœ¨æ ‡å‡†åº“é‡Œã€‚å¯¹äºæ»¡è¶³ Codable çš„ç±»å‹ï¼Œå®ƒä»¬ä¹Ÿå°†è‡ªåŠ¨é€‚é… Cocoa çš„ NSKeyedArchiverã€‚</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let places = [
  Placemark(name: "Berlin", coordinate:
    Coordinate(latitude: 52, longitude: 13)),
  Placemark(name: "Cape Town", coordinate:
    Coordinate(latitude: -34, longitude: 18))
]

do {
  let encoder = JSONEncoder()
  let jsonData = try encoder.encode(places) // 129 bytes
  let jsonString = String(decoding: jsonData, as: UTF8.self)
  /*
  [{"name":"Berlin","coordinate":{"longitude":13,"latitude":52}},
  {"name":"Cape Town","coordinate":{"longitude":18,"latitude":-34}}]
  */
} catch {
  print(error.localizedDescription)
}

do {
  let decoder = JSONDecoder()
  let decoded = try decoder.decode([Placemark].self, from: jsonData)
  // [Berlin (lat: 52.0, lon: 13.0), Cape Town (lat: -34.0, lon: 18.0)]
  type(of: decoded) // Array&lt;Placemark&gt;
  decoded == places // true
} catch {
  print(error.localizedDescription)
}
</code></pre></div></div>
<ul>
  <li>JSONEncoder è¿˜æ”¯æŒå¯¹äºæ—¥æœŸ (åŒ…æ‹¬ ISO 8601 æˆ–è€… Unix epoch æ—¶é—´æˆ³)ï¼ŒData å€¼ (æ¯”å¦‚ Base64 æ–¹å¼) ä»¥åŠå¦‚ä½•åœ¨å‘ç”Ÿå¼‚å¸¸æ—¶å¤„ç†æµ®ç‚¹å€¼ (ä½œä¸ºæ— é™æˆ–æ˜¯ not a number) è¿›è¡Œè‡ªå®šä¹‰ã€‚è¿™äº›é€‰é¡¹å°†åœ¨æ•´ä¸ªå€¼çš„è§£ç ä¸­é€šç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä½ ä¸èƒ½ä¸ºä¸€ä¸ªç±»å‹æŒ‡å®šä¸€ç§ Date çš„è§£ç æ–¹å¼ï¼Œè€Œä¸ºå¦ä¸€ç§ç±»å‹ä¸­æŒ‡å®šç”¨åˆ«çš„æ–¹å¼ã€‚å¦‚æœä½ éœ€è¦åœ¨è¿™æ ·çš„ç²’åº¦ä¸Šè¿›è¡Œæ§åˆ¶ï¼Œä½ éœ€è¦å¯¹å—å½±å“çš„ç±»å‹åˆ›å»ºè‡ªå®šä¹‰çš„ Codable å®ç°ã€‚</li>
  <li>JSONEncoder ç”šè‡³éƒ½æ²¡æœ‰å®ç° Encoder åè®®ã€‚å®ƒåªæ˜¯ä¸€ä¸ªå«åš _JSONEncoder çš„ç§æœ‰ç±»çš„å°è£…ï¼Œè¿™ä¸ªç±»å®ç°äº† Encoder åè®®ï¼Œå¹¶ä¸”è¿›è¡Œå®é™…çš„ç¼–ç å·¥ä½œã€‚è¿™ä¹ˆè®¾è®¡çš„åŸå› æ˜¯ï¼Œé¡¶å±‚çš„ç¼–ç å™¨åº”è¯¥æä¾›çš„æ˜¯å®Œå…¨ä¸åŒçš„ API (æˆ–è€…è¯´ï¼Œæä¾›ä¸€ä¸ªæ–¹æ³•æ¥å¼€å§‹ç¼–ç çš„è¿‡ç¨‹)ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåœ¨ç¼–ç è¿‡ç¨‹ä¸­ç”¨æ¥ä¼ é€’ç»™ codable ç±»å‹çš„ Encoder å¯¹è±¡ã€‚å°†è¿™äº›ä»»åŠ¡æ¸…æ™°åœ°åˆ†è§£å¼€ï¼Œæ„å‘³ç€åœ¨ä»»æ„ç»™å®šçš„æƒ…æ™¯ä¸‹ï¼Œä½¿ç”¨ç¼–ç å™¨çš„ä¸€æ–¹åªèƒ½è®¿é—®åˆ°é€‚å½“çš„ APIã€‚æ¯”å¦‚ï¼Œå› ä¸ºå…¬å¼€çš„é…ç½® API åªæš´éœ²åœ¨é¡¶å±‚ç¼–ç å™¨çš„å®šä¹‰ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ª codable ç±»å‹ä¸èƒ½åœ¨ç¼–ç è¿‡ç¨‹ä¸­é‡æ–°å¯¹ç¼–ç å™¨è¿›è¡Œé…ç½®ã€‚</li>
</ul>

<h3 id="ä¸‰ç¼–ç è¿‡ç¨‹">ä¸‰ã€ç¼–ç è¿‡ç¨‹</h3>
<h4 id="1-å®¹å™¨">1. å®¹å™¨</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// èƒ½å°†å€¼ç¼–ç ä¸ºå¤–éƒ¨è¡¨ç¤ºçš„åŸç”Ÿæ ¼å¼çš„ç±»å‹ã€‚
public protocol Encoder {
  /// ç¼–ç è¿‡ç¨‹ä¸­åˆ°å½“å‰ç‚¹çš„ç¼–ç é”®è·¯å¾„ã€‚
  var codingPath: [CodingKey] { get }
  /// ç”¨æˆ·ä¸ºç¼–ç è®¾ç½®çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚
  var userInfo: [CodingUserInfoKey : Any] { get }
  /// è¿”å›ä¸€ä¸ªåˆé€‚ç”¨æ¥å­˜æ”¾ä»¥ç»™å®šé”®ç±»å‹ä¸ºé”®çš„å¤šä¸ªå€¼çš„ç¼–ç å®¹å™¨ã€‚
  func container&lt;Key: CodingKey&gt;(keyedBy type: Key.Type)
  -&gt; KeyedEncodingContainer&lt;Key&gt;
  /// è¿”å›ä¸€ä¸ªåˆé€‚ç”¨æ¥å­˜æ”¾å¤šä¸ªæ— é”®å€¼çš„ç¼–ç å®¹å™¨ã€‚
  func unkeyedContainer() -&gt; UnkeyedEncodingContainer
  /// è¿”å›ä¸€ä¸ªåˆé€‚ç”¨æ¥å­˜æ”¾ä¸€ä¸ªåŸå§‹å€¼çš„ç¼–ç å®¹å™¨ã€‚
  func singleValueContainer() -&gt; SingleValueEncodingContainer
}
</code></pre></div></div>
<p>Encoder çš„æ ¸å¿ƒåŠŸèƒ½å°±æ˜¯æä¾›ä¸€ä¸ªç¼–ç å®¹å™¨ã€‚å®¹å™¨æ˜¯ç¼–ç å™¨å­˜å‚¨çš„ä¸€ç§æ²™ç›’è¡¨ç°å½¢å¼ï¼Œé€šè¿‡ä¸ºæ¯ä¸ªè¦ç¼–ç çš„å€¼åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨ï¼Œç¼–ç å™¨èƒ½å¤Ÿç¡®ä¿æ¯ä¸ªå€¼éƒ½ä¸ä¼šè¦†ç›–å½¼æ­¤çš„æ•°æ®ã€‚</p>

<p>å®¹å™¨æœ‰ä¸‰ç§ç±»å‹ï¼š</p>
<ul>
  <li>é”®å®¹å™¨ (Keyed Container) å¯ä»¥å¯¹é”®å€¼å¯¹è¿›è¡Œç¼–ç ï¼Œç±»ä¼¼å­—å…¸ï¼Œç›®å‰æœ€å¸¸è§çš„å®¹å™¨ã€‚
åœ¨åŸºäºé”®çš„ç¼–ç å®¹å™¨ä¸­ï¼Œé”®æ˜¯å¼ºç±»å‹çš„ï¼Œè¿™ä¸ºæˆ‘ä»¬æä¾›äº†ç±»å‹å®‰å…¨å’Œè‡ªåŠ¨è¡¥å…¨çš„ç‰¹æ€§ã€‚ç¼–ç å™¨æœ€ç»ˆä¼šåœ¨å†™å…¥ç›®æ ‡æ ¼å¼ (æ¯”å¦‚ JSON) æ—¶ï¼Œå°†é”®è½¬æ¢ä¸ºå­—ç¬¦ä¸² (æˆ–è€…æ•°å­—)ï¼Œä¸è¿‡è¿™å¯¹å¼€å‘è€…æ¥è¯´æ˜¯éšè—çš„ã€‚è‡ªå®šä¹‰ç¼–ç æ–¹å¼çš„æœ€ç®€å•çš„åŠæ³•å°±æ˜¯æ›´æ”¹ä½ çš„ç±»å‹æ‰€æä¾›çš„é”®ã€‚æˆ‘ä»¬é©¬ä¸Šä¼šåœ¨ä¸‹é¢çœ‹åˆ°ä¸€ä¸ªä¾‹å­ã€‚</li>
  <li>æ— é”®å®¹å™¨ (Unkeyed Container) å°†å¯¹ä¸€ç³»åˆ—å€¼è¿›è¡Œç¼–ç ï¼Œè€Œä¸éœ€è¦å¯¹åº”çš„é”®ï¼Œå¯ä»¥å°†å®ƒæƒ³åƒæˆè¢«ç¼–ç å€¼çš„æ•°ç»„ã€‚å› ä¸ºæ²¡æœ‰å¯¹åº”çš„é”®æ¥ç¡®å®šæŸä¸ªå€¼ï¼Œæ‰€ä»¥å¯¹äºåœ¨å®¹å™¨ä¸­çš„å€¼è¿›è¡Œè§£ç çš„æ—¶å€™ï¼Œéœ€è¦éµå®ˆå’Œç¼–ç æ—¶åŒæ ·çš„é¡ºåºã€‚</li>
  <li>å•å€¼å®¹å™¨å¯¹ä¸€ä¸ªå•ä¸€å€¼è¿›è¡Œç¼–ç ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥å¤„ç†æ•´ä¸ªæ•°æ®è¢«å®šä¹‰ä¸ºå•ä¸ªå±æ€§çš„é‚£ç±»ç±»å‹ã€‚å•å€¼å®¹å™¨åº”ç”¨çš„ä¾‹å­åŒ…æ‹¬åƒæ˜¯ Int è¿™æ ·çš„åŸå§‹ç±»å‹ï¼Œæˆ–è€…æ˜¯åº•å±‚ç”±åŸå§‹ç±»å‹çš„ RawRepresentable æ‰€è¡¨è¾¾çš„æšä¸¾å€¼ç±»å‹ã€‚</li>
</ul>

<p>æ¯ç§ç±»å‹çš„å®¹å™¨éƒ½å¯¹åº”ä¸€ä¸ªåè®®ï¼ŒSingleValueEncodingContainer</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// å¯ä»¥æ”¯æŒå­˜å‚¨å’Œç›´æ¥ç¼–ç ä¸€ä¸ªå•ä¸€æ— é”®å€¼çš„å®¹å™¨ã€‚
public protocol SingleValueEncodingContainer {
  /// ç¼–ç è¿‡ç¨‹ä¸­åˆ°å½“å‰ç‚¹çš„ç¼–ç é”®è·¯å¾„ã€‚
  var codingPath: [CodingKey] { get }
  /// å¯¹ null ç¼–ç ã€‚
  mutating func encodeNil() throws
  /// åŸºç¡€ç±»å‹
  mutating func encode(_ value: Bool) throws
  mutating func encode(_ value: Int) throws
  mutating func encode(_ value: Int8) throws
  mutating func encode(_ value: Int16) throws

  â€¦â€¦

  mutating func encode(_ value: String) throws
  mutating func encode&lt;T: Encodable&gt;(_ value: T) throws
}
</code></pre></div></div>
<ul>
  <li>é€šè¿‡å¯¹ encode(_:) è¦†ç›–æ‰€æœ‰ç¼–ç å™¨å’Œè§£ç å™¨éƒ½å¿…é¡»æ”¯æŒçš„åŸå§‹ç±»å‹ï¼ŒEncodable ç±»å‹ä»æ ¹æœ¬ä¸Šä¹Ÿéƒ½å½’ç»“åˆ°è¿™äº›ç±»å‹ä¸­ã€‚</li>
  <li>å…¶ä»–ä¸å±äºåŸºç¡€ç±»å‹çš„å€¼ï¼Œæœ€åéƒ½ä¼šè½åˆ°æ³›å‹çš„ encode&lt;T: Encodable&gt; é‡è½½ä¸­ã€‚</li>
  <li>å¦å¤–ä¸¤ç§å®¹å™¨æ‹¥æœ‰ç›¸åŒçš„ç»“æ„ï¼Œå…·å¤‡æ›´å¤šçš„èƒ½åŠ›ã€‚</li>
</ul>

<h4 id="2-å€¼æ—¶å¦‚ä½•å¯¹è‡ªå·±ç¼–ç çš„">2. å€¼æ—¶å¦‚ä½•å¯¹è‡ªå·±ç¼–ç çš„</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Array&lt;Placemark&gt; è¯·æ±‚é™„ä»¶å®¹å™¨è¿›è¡Œç¼–ç 
extension Array: Encodable where Element: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.unkeyedContainer()
    for element in self {
      try container.encode(element)
    }
  }
}
</code></pre></div></div>
<h3 id="å››ç”Ÿæˆçš„ä»£ç ">å››ã€ç”Ÿæˆçš„ä»£ç </h3>
<h4 id="1-coding-keys">1. Coding Keys</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Placemark {
  // é¦–å…ˆé’ˆå¯¹å­—ç¬¦ä¸²çš„é”®ç¼–ç ç”Ÿæˆç§æœ‰çš„åµŒå¥—æšä¸¾ç±»å‹
  private enum CodingKeys: CodingKey {
    case name
    case coordinate
  }
}

/// è¯¥ç±»å‹ä½œä¸ºç¼–ç å’Œè§£ç æ—¶ä½¿ç”¨çš„é”®
public protocol CodingKey {
  /// åœ¨ä¸€ä¸ªå‘½åé›†åˆ (æ¯”å¦‚ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºé”®çš„å­—å…¸) ä¸­çš„å­—ç¬¦ä¸²å€¼ã€‚
  var stringValue: String { get }
  /// åœ¨ä¸€ä¸ªæ•´æ•°ç´¢å¼•é›†åˆ (æ¯”å¦‚ä¸€ä¸ªæ•´æ•°ä½œä¸ºé”®çš„å­—å…¸) ä¸­ä½¿ç”¨çš„å€¼ã€‚
  var intValue: Int? { get }
  init?(stringValue: String)
  init?(intValue: Int)
}
// å¿…é¡»æä¾›å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œå¯é€‰æ•´æ•°ã€‚ç¼–ç å™¨æœ‰äº‹ä¼šå¿½ç•¥æ•´æ•°é”®ï¼Œå¦‚JSONEncoderã€‚ç¼–è¯‘å™¨ç”Ÿæˆçš„é»˜è®¤ä»£ç åªåŒ…å«å­—ç¬¦ä¸²é”®ã€‚
</code></pre></div></div>
<h4 id="2-encodetoæ–¹æ³•">2. encode(to:)æ–¹æ³•</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ç¼–è¯‘å™¨ä¸º Placemark ç»“æ„ä½“ç”Ÿæˆçš„ encode(to:) æ–¹æ³•
struct Placemark: Codable {
  // å°†è‡ªå·±ç¼–ç åˆ°ä¸€ä¸ªé”®å®¹å™¨ä¸­ï¼Œå¾—åˆ°ä¸€é¢—åµŒå¥—çš„å®¹å™¨æ ‘ï¼Œç¼–ç å™¨æ®æ­¤å°†å€¼è½¬åŒ–ä¸ºç›®æ ‡æ ¼å¼
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(name, forKey: .name)
    try container.encode(coordinate, forKey: .coordinate)
  }
}
</code></pre></div></div>
<h4 id="3-initfrom-åˆå§‹åŒ–æ–¹æ³•">3. init(from:) åˆå§‹åŒ–æ–¹æ³•</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Placemark: Codable {
  // è§£ç å™¨é€’å½’å‘ä¸‹è®¿é—®å®¹å™¨çš„å±‚çº§ï¼Œå°†è§£ç å‡ºçš„å€¼åˆå§‹åŒ–ä¸ºå¯¹åº”å±æ€§
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    name = try container.decode(String.self, forKey: .name)
    coordinate = try container.decode(Coordinate.self, forKey: .coordinate)
  }
}
</code></pre></div></div>
<h3 id="äº”æ‰‹åŠ¨éµå®ˆåè®®">äº”ã€æ‰‹åŠ¨éµå®ˆåè®®</h3>
<h4 id="1-è‡ªå®šä¹‰-coding-keys">1. è‡ªå®šä¹‰ Coding Keys</h4>
<p>è‡ªå®šä¹‰ç¼–ç é”®æ—¶ä¸€ç§ç®€å•ã€å£°æ˜å¼æ”¹å˜ç±»å‹ç¼–ç çš„æ–¹å¼ï¼Œä¸¤ç§ç”¨æ³•ï¼š</p>
<ul>
  <li>ä½¿ç”¨æ˜ç¡®ç»™å®šçš„å­—ç¬¦ä¸²å€¼ï¼Œåœ¨ç¼–ç åçš„è¾“å‡ºä¸­é‡å‘½åå­—æ®µã€‚</li>
  <li>å°†æŸä¸ªé”®ä»æšä¸¾ä¸­ç§»é™¤ï¼Œä»¥æ­¤å®Œå…¨è·³è¿‡å­—æ®µã€‚</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä¿®æ”¹é”®åæ—¶ï¼Œå¿…é¡»å°†æšä¸¾çš„åº•å±‚ç±»å‹è®¾ç½®ä¸ºString
struct Placemark2: Codable {
  var name: String
  var coordinate: Coordinate
  private enum CodingKeys: String, CodingKey {
    // å°† name åœ¨ JSON è¾“å‡ºä¸­æ˜ å°„ä¸º "label"
    case name = "label"
    case coordinate
  }
  // ç¼–è¯‘å™¨ç”Ÿæˆçš„ç¼–ç å’Œè§£ç æ–¹æ³•å°†ä½¿ç”¨é‡è½½åçš„ CodingKeys
}

struct Placemark3: Codable {
  // æšä¸¾ä¸­ä¸åŒ…å« name é”®ï¼Œç¼–ç æ˜¯å°†è¢«è·³è¿‡
  // name èµ‹äº†é»˜è®¤å€¼ï¼Œå¦åˆ™ Decodable ç”Ÿæˆçš„ä»£ç ä¼šç¼–è¯‘å¤±è´¥ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šå‘ç°åœ¨åˆå§‹åŒ–ä¸­æ— æ³•æ”¾ç»™ name å±æ€§æ­£ç¡®èµ‹å€¼
  var name: String = "(Unknown)"
  var coordinate: Coordinate
  private enum CodingKeys: CodingKey {
  case coordinate
}
// åº”ç”¨ï¼šç¼“å­˜æˆ–å­˜å‚¨ä»£ä»·å¤§çš„å€¼ï¼Œå¯ä»¥é€šè¿‡è®¡ç®—å¾—å‡ºï¼Œå¯ä»¥æš‚æ—¶è·³è¿‡ã€‚
// ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¿‡æ»¤ lazy çš„å±æ€§ã€‚
</code></pre></div></div>
<h4 id="2-è‡ªå®šä¹‰çš„-encodeto-å’Œ-initfrom-å®ç°">2. è‡ªå®šä¹‰çš„ encode(to:) å’Œ init(from:) å®ç°</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Placemark4: Codable {
  var name: String
  var coordinate: Coordinate?
}

let validJSONInput = """
[
{ "name" : "Berlin" },
{ "name" : "Cape Town" }
]
"""

let invalidJSONInput = """
[
{
"name" : "Berlin",
"coordinate": {}
}
]
""

do {
  let inputData = invalidJSONInput.data(using: .utf8)!
  let decoder = JSONDecoder()
  let decoded = try decoder.decode([Placemark4].self, from: inputData)
} catch {
  print(error.localizedDescription)
  // The data couldnâ€™t be read because it is missing.
}

// è§£å†³ä¸Šé¢ç”±äº  "latitude" å’Œ "longitude" ä¸å­˜åœ¨è§¦å‘çš„ .keyNotFound é”™è¯¯
// é‡åˆ°å…¶ä»–è§£ç é”™è¯¯æ‰”ä¼šæŠ›å‡ºå¼‚å¸¸
struct Placemark4: Codable {
  var name: String
  var coordinate: Coordinate?
  // encode(to:) ä¾ç„¶ç”±ç¼–è¯‘å™¨ç”Ÿæˆ
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.name = try container.decode(String.self, forKey: .name)
    do {
      self.coordinate = try container.decodeIfPresent(Coordinate.self,
      forKey: .coordinate)
    } catch DecodingError.keyNotFound {
      self.coordinate = nil
    }
  }
}

do {
  let inputData = invalidJSONInput.data(using: .utf8)!
  let decoder = JSONDecoder()
  let decoded = try decoder.decode([Placemark4].self, from: inputData)
  decoded // [Berlin (nil)]
} catch {
  print(error.localizedDescription)
}
</code></pre></div></div>
<h3 id="å…­å¸¸è§çš„ç¼–ç ä»»åŠ¡">å…­ã€å¸¸è§çš„ç¼–ç ä»»åŠ¡</h3>
<h4 id="1-è®©å…¶ä»–äººçš„ä»£ç æ»¡è¶³-codable">1. è®©å…¶ä»–äººçš„ä»£ç æ»¡è¶³ Codable</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import CoreLocation
struct Placemark5: Codable {
  var name: String
  var coordinate: CLLocationCoordinate2D
}
// é”™è¯¯ï¼šæ— æ³•è‡ªåŠ¨ç”Ÿæˆ 'Decodable'/'Encodable' çš„é€‚é…ä»£ç ï¼Œ
// å› ä¸º 'CLLocationCoordinate2D' ä¸éµå®ˆç›¸å…³åè®®

extension CLLocationCoordinate2D: Codable { }
// error: 'Decodable'/'Encodable' çš„å®ç°è¿˜ä¸èƒ½åœ¨æ‰©å±•ä¸­è‡ªåŠ¨ç”Ÿæˆã€‚

extension Placemark5 {
  private enum CodingKeys: String, CodingKey {
    case name
    case name
    case latitude = "lat"
    case longitude = "lon"
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(name, forKey: .name)
    // åˆ†åˆ«ç¼–ç çº¬åº¦å’Œç»åº¦
    try container.encode(coordinate.latitude, forKey: .latitude)
    try container.encode(coordinate.longitude, forKey: .longitude)
  }
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.name = try container.decode(String.self, forKey: .name)
    // ä»çº¬åº¦å’Œç»åº¦é‡æ–°æ„å»º CLLocationCoordinate2D
    self.coordinate = CLLocationCoordinate2D(
    latitude: try container.decode(Double.self, forKey: .latitude),
    longitude: try container.decode(Double.self, forKey: .longitude)
    )
  }
}
// å½“ç¼–è¯‘å™¨ä¸èƒ½ç”Ÿæˆæ¨¡æ¿ä»£ç æ—¶ï¼Œå¿…é¡»ä¸ºæ¯ä¸ªç±»å‹è‡ªå®šä¹‰ä»£ç 
</code></pre></div></div>
<ul>
  <li>åµŒå¥—å®¹å™¨</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// KeyedDecodingContainer æœ‰ä¸€ä¸ªå«åš nestedContainer(keyedBy:forKey:) çš„æ–¹æ³•
struct Placemark6: Encodable {
  var name: String
  var coordinate: CLLocationCoordinate2D
  private enum CodingKeys: CodingKey {
    case name
    case coordinate
  }
  // åµŒå¥—å®¹å™¨çš„ç¼–ç é”®
  private enum CoordinateCodingKeys: CodingKey {
    case latitude
    case longitude
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(name, forKey: .name)
    var coordinateContainer = container.nestedContainer(
    keyedBy: CoordinateCodingKeys.self, forKey: .coordinate)
    try coordinateContainer.encode(coordinate.latitude, forKey: .latitude)
    try coordinateContainer.encode(coordinate.longitude, forKey: .longitude)
  }
}

</code></pre></div></div>
<ul>
  <li>ä½¿ç”¨è®¡ç®—å±æ€§ç»•å¼€é—®é¢˜</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Placemark7: Codable {
  var name: String
  private var _coordinate: Coordinate
  var coordinate: CLLocationCoordinate2D {
    get {
      return CLLocationCoordinate2D(latitude: _coordinate.latitude, longitude: _coordinate.longitude)
    }
    set {
      _coordinate = Coordinate(latitude: newValue.latitude, longitude: newValue.longitude)
    }
  }
  private enum CodingKeys: String, CodingKey {
    case name
    case _coordinate = "coordinate"
  }
}

</code></pre></div></div>
<h4 id="2-è®©ç±»æ»¡è¶³-codable">2. è®©ç±»æ»¡è¶³ Codable</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åœ¨ Swift 4 ä¸­ï¼Œæ— æ³•ä¸ºä¸€ä¸ªé final çš„ç±»æ·»åŠ  Codable ç‰¹æ€§
// ä¸ºä¸æ‹¥æœ‰çš„ç±»æ·»åŠ  Codable éå¸¸å›°éš¾
extension UIColor {
  var rgba: (red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)? {
    var red: CGFloat = 0.0
    var green: CGFloat = 0.0
    var blue: CGFloat = 0.0
    var alpha: CGFloat = 0.0
    if getRed(&amp;red, green: &amp;green, blue: &amp;blue, alpha: &amp;alpha) {
      return (red: red, green: green, blue: blue, alpha: alpha)
    } else {
      return nil
    }
  }

  struct CodableWrapper: Codable {
    var value: UIColor
    init(_ value: UIColor) {
      self.value = value
    }
    enum CodingKeys: CodingKey {
      case red
      case green
      case blue
      case alpha
    }
    func encode(to encoder: Encoder) throws {
      // å¦‚æœé¢œè‰²ä¸èƒ½è½¬ä¸º RGBAï¼Œåˆ™æŠ›å‡ºé”™è¯¯
      guard let (red, green, blue, alpha) = value.rgba else {
        let errorContext = EncodingError.Context(
          codingPath: encoder.codingPath,
          debugDescription:
          "Unsupported color format: \(value)"
        ) throw EncodingError.invalidValue(value, errorContext)
      }
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(red, forKey: .red)
      try container.encode(green, forKey: .green)
      try container.encode(blue, forKey: .blue)
      try container.encode(alpha, forKey: .alpha)
    }
    init(from decoder: Decoder) throws {
      let container = try decoder.container(keyedBy: CodingKeys.self)
      let red = try container.decode(CGFloat.self, forKey: .red)
      let green = try container.decode(CGFloat.self, forKey: .green)
      let blue = try container.decode(CGFloat.self, forKey: .blue)
      let alpha = try container.decode(CGFloat.self, forKey: .alpha)
      self.value = UIColor(red: red, green: green, blue: blue, alpha: alpha)
    }
  }
}

struct ColoredRect: Codable {
  var rect: CGRect
  // å¯¹é¢œè‰²è¿›è¡Œå­˜å‚¨
  private var _color: UIColor.CodableWrapper
  var color: UIColor {
    get { return _color.value }
    get { return _color.value }
    set { _color.value = newValue }
  }
  init(rect: CGRect, color: UIColor) {
    self.rect = rect
    self._color = UIColor.CodableWrapper(color)
  }
  private enum CodingKeys: String, CodingKey {
    case rect
    case _color = "color"
  }
}

let rects = [ColoredRect(rect: CGRect(x: 10, y: 20, width: 100, height: 200),
color: .yellow)]
do {
  let encoder = JSONEncoder()
  let jsonData = try encoder.encode(rects)
  let jsonString = String(decoding: jsonData, as: UTF8.self)
  // [{"color":{"red":1,"alpha":1,"blue":0,"green":1},"rect":[[10,20],[100,200]]}]
} catch {
  print(error.localizedDescription)
}
</code></pre></div></div>
<h4 id="3-è®©æšä¸¾æ»¡è¶³-codable">3. è®©æšä¸¾æ»¡è¶³ Codable</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum Either&lt;A: Codable, B: Codable&gt;: Codable {
  case left(A)
  case right(B)
  private enum CodingKeys: CodingKey {
    case left
    case right
  }
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    switch self {
      case .left(let value):
      try container.encode(value, forKey: .left)
      case .right(let value):
      try container.encode(value, forKey: .right)
    }
  }
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    if let leftValue = try container.decodeIfPresent(A.self, forKey: .left) {
      self = .left(leftValue)
    } else {
      let rightValue = try container.decode(B.self, forKey: .right)
      self = .right(rightValue)
    }
  }
}

let values: [Either&lt;String, Int&gt;] = [
  .left("Forty-two"),
  .right(42)
]
do {
  let encoder = PropertyListEncoder()
  encoder.outputFormat = .xml
  let xmlData = try encoder.encode(values)
  let xmlString = String(decoding: xmlData, as: UTF8.self)
  /*
  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
  &lt;plist version="1.0"&gt;
  &lt;array&gt;
  &lt;dict&gt;
  &lt;key&gt;left&lt;/key&gt;
  &lt;string&gt;Forty-two&lt;/string&gt;
  &lt;/dict&gt;
  &lt;dict&gt;
  &lt;key&gt;right&lt;/key&gt;
  &lt;integer&gt;42&lt;/integer&gt;
  &lt;/dict&gt;
  &lt;/array&gt;
  &lt;/plist&gt;
  */
  let decoder = PropertyListDecoder()
  let decoded = try decoder.decode([Either&lt;String, Int&gt;].self, from: xmlData)
  /*
  [Either&lt;Swift.String, Swift.Int&gt;.left("Forty-two"),
  Either&lt;Swift.String, Swift.Int&gt;.right(42)]
  */
} catch {
  print(error.localizedDescription)
}

</code></pre></div></div>
<h4 id="4-è§£ç å¤šæ€é›†åˆ">4. è§£ç å¤šæ€é›†åˆ</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å‡è®¾ç°åœ¨ UIView å’Œå®ƒçš„å­ç±»ç°åœ¨éƒ½æ»¡è¶³ Codable
let views: [UIView] = [label, imageView, button]

// ä¸ºæ¯ä¸ªæ”¯æŒçš„å­ç±»åˆ›å»ºä¸€ä¸ªæšä¸¾æˆå‘˜ï¼Œå…³è”å€¼ä¸­å­˜å‚¨å®é™…å¯¹è±¡
enum View {
  case view(UIView)
  case label(UILabel)
  case imageView(UIImageView)
  // ...
}
</code></pre></div></div>
<p>æ‰‹å†™ Codable å®ç°ï¼Œéµå¾ªæšä¸¾åŒæ ·çš„æ¨¡å¼</p>
<ul>
  <li>åœ¨ç¼–ç è¿‡ç¨‹ä¸­ï¼Œå¯¹è¦ç¼–ç çš„å¯¹è±¡åœ¨æ‰€æœ‰æšä¸¾æˆå‘˜ä¸Šåš switch æ¥æ‰¾åˆ°æˆ‘ä»¬è¦ç¼–ç çš„ç±»å‹ã€‚ç„¶åå°†å¯¹è±¡çš„ç±»å‹å’Œå¯¹è±¡æœ¬èº«ç¼–ç åˆ°å®ƒä»¬çš„é”®ä¸­ã€‚</li>
  <li>åœ¨è§£ç è¿‡ç¨‹ä¸­ï¼Œå…ˆè§£ç ç±»å‹ä¿¡æ¯ï¼Œç„¶åæ ¹æ®å…·ä½“çš„ç±»å‹é€‰æ‹©åˆé€‚çš„åˆå§‹åŒ–æ–¹æ³•ã€‚</li>
</ul>
:ET