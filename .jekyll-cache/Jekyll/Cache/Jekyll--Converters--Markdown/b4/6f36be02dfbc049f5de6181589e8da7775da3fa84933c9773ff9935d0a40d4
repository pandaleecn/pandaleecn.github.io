I"£a<h3 id="ä¸€æ•°ç»„">ä¸€ã€æ•°ç»„</h3>
<h4 id="1-æ•°ç»„å’Œå¯å˜æ€§">1. æ•°ç»„å’Œå¯å˜æ€§</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let fibs = [0, 1, 1, 2, 3, 5]
var mutableFibs = [0, 1, 1, 2, 3, 5]
mutableFibs.append(8)
mutableFibs.append(contentsOf: [13, 21])
mutableFibs // [0, 1, 1, 2, 3, 5, 8, 13, 21]

let a = NSMutableArray(array: [1,2,3])
// æˆ‘ä»¬ä¸æƒ³è®© b å‘ç”Ÿæ”¹å˜
let b: NSArray = a
// ä½†æ˜¯äº‹å®ä¸Šå®ƒä¾ç„¶èƒ½å¤Ÿè¢« a å½±å“å¹¶æ”¹å˜
a.insert(4, at: 3)
b // ( 1, 2, 3, 4 )

// æ­£ç¡®çš„æ–¹å¼æ˜¯åœ¨èµ‹å€¼æ—¶ï¼Œå…ˆæ‰‹åŠ¨è¿›è¡Œå¤åˆ¶ï¼š
let c = NSMutableArray(array: [1,2,3])
// æˆ‘ä»¬ä¸æƒ³è®© d å‘ç”Ÿæ”¹å˜
let d = c.copy() as! NSArray
c.insert(4, at: 3)
d // ( 1, 2, 3 )

</code></pre></div></div>
<ul>
  <li>æ•°ç»„åªæœ‰ä¸€ç§ç»Ÿä¸€çš„ç±»å‹ï¼Œå¯ä»¥é€šè¿‡åœ¨å£°æ˜æ—¶ä½¿ç”¨ var è€Œé let æ¥å°†æ•°ç»„å®šä¹‰ä¸ºå¯å˜çš„ã€‚</li>
  <li>å½“ä½ ä½¿ç”¨ let å£°æ˜ç¬¬äºŒä¸ªæ•°ç»„ï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªæ•°ç»„èµ‹å€¼ç»™å®ƒæ—¶ï¼Œå¯ä»¥ä¿è¯è¿™ä¸ªæ–°çš„æ•°ç»„æ˜¯ä¸ä¼šæ”¹å˜çš„ï¼Œå› ä¸ºè¿™é‡Œæ²¡æœ‰å…±ç”¨çš„å¼•ç”¨ã€‚</li>
  <li>åˆ›å»ºå¦‚æ­¤å¤šçš„å¤åˆ¶æœ‰å¯èƒ½é€ æˆæ€§èƒ½é—®é¢˜ï¼Œä¸è¿‡å®é™…ä¸Š Swift æ ‡å‡†åº“ä¸­çš„æ‰€æœ‰é›†åˆç±»å‹éƒ½ä½¿ç”¨äº†â€œå†™æ—¶å¤åˆ¶â€è¿™ä¸€æŠ€æœ¯ï¼Œå®ƒèƒ½å¤Ÿä¿è¯åªåœ¨å¿…è¦çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œå¤åˆ¶ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œç›´åˆ° y.append è¢«è°ƒç”¨çš„ä¹‹å‰ï¼Œx å’Œ y éƒ½å°†å…±äº«å†…éƒ¨çš„å­˜å‚¨ã€‚</li>
</ul>

<h4 id="2-æ•°ç»„å’Œå¯é€‰å€¼">2. æ•°ç»„å’Œå¯é€‰å€¼</h4>
<ul>
  <li>æ•°ç»„ç´¢å¼•çš„ä½¿ç”¨æ–¹å¼
    <ul>
      <li>æƒ³è¦è¿­ä»£æ•°ç»„ï¼Ÿ for x in array</li>
      <li>æƒ³è¦è¿­ä»£é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä»¥å¤–çš„æ•°ç»„å…¶ä½™éƒ¨åˆ†ï¼Ÿ for x in array.dropFirst()</li>
      <li>æƒ³è¦è¿­ä»£é™¤äº†æœ€å 5 ä¸ªå…ƒç´ ä»¥å¤–çš„æ•°ç»„ï¼Ÿ for x in array.dropLast(5)</li>
      <li>æƒ³è¦åˆ—ä¸¾æ•°ç»„ä¸­çš„å…ƒç´ å’Œå¯¹åº”çš„ä¸‹æ ‡ï¼Ÿ for (num, element) in collection.enumerated()</li>
      <li>æƒ³è¦å¯»æ‰¾ä¸€ä¸ªæŒ‡å®šå…ƒç´ çš„ä½ç½®ï¼Ÿ if let idx = array.index { someMatchingLogic($0) }</li>
      <li>æƒ³è¦å¯¹æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œå˜å½¢ï¼Ÿ array.map { someTransformation($0) }</li>
      <li>æƒ³è¦ç­›é€‰å‡ºç¬¦åˆæŸä¸ªæ ‡å‡†çš„å…ƒç´ ï¼Ÿ array.filter { someCriteria($0) &gt; }</li>
    </ul>
  </li>
  <li>å°†ç»“æœè¿›è¡Œå¼ºåˆ¶è§£åŒ…æ˜¯ä¸€ä¸ªåä¹ æƒ¯ï¼Œå¾ˆå¯èƒ½å¼ºåˆ¶è§£åŒ…äº†æœ¬æ¥ä¸åº”è¯¥è§£åŒ…çš„ä¸œè¥¿ï¼Œä¸ºäº†é¿å…ï¼Œæ•°ç»„æ²¡æœ‰ç»™å¯é€‰å€¼çš„é€‰é¡¹ã€‚</li>
  <li>first å’Œ last å±æ€§æœ¬èº«æ˜¯å¯é€‰å€¼ç±»å‹ï¼Œå½“æ•°ç»„ä¸ºç©ºæ—¶ï¼Œå®ƒä»¬è¿”å› nilã€‚å¦‚æœæ•°ç»„ä¸ºç©ºæ—¶ï¼ŒremoveLast å°†ä¼šå¯¼è‡´å´©æºƒï¼Œè€Œ popLast å°†åœ¨æ•°ç»„ä¸ä¸ºç©ºæ—¶åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ å¹¶è¿”å›å®ƒï¼Œåœ¨æ•°ç»„ä¸ºç©ºæ—¶ï¼Œå®ƒå°†ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œç›´æ¥è¿”å› nilã€‚</li>
</ul>

<h4 id="3-æ•°ç»„å˜å½¢">3. æ•°ç»„å˜å½¢</h4>
<ul>
  <li>Mapçš„ä¸‰å¤§ä¼˜åŠ¿
    <ul>
      <li>å¾ˆçŸ­ï¼Œä»£ç æ¸…æ™°ã€‚</li>
      <li>ä¸ä¼šæ”¹å˜å€¼ï¼Œå¯ç›´æ¥å£°æ˜ä¸ºletã€‚</li>
      <li>mapå‡½æ•°åˆ›å»ºç®€å•ï¼Œå¯é€šè¿‡æ³›å‹å‡½æ•°å°è£…ã€‚</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var squared: [Int] = []
for fib in fibs {
squared.append(fib * fib)
}
squared // [0, 1, 1, 4, 9, 25]

let squares = fibs.map { fib in fib * fib }
squares // [0, 1, 1, 4, 9, 25]

extension Array {
  func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] {
    var result: [T] = []
    result.reserveCapacity(count)
    for x in self {
      result.append(transform(x))
    }
    return result
  }
}
</code></pre></div></div>
<ul>
  <li>ä½¿ç”¨å‡½æ•°å°†è¡Œä¸ºå‚æ•°åŒ–
    <ul>
      <li>map å’Œ flatMap â€” å¦‚ä½•å¯¹å…ƒç´ è¿›è¡Œå˜æ¢</li>
      <li>filter â€” å…ƒç´ æ˜¯å¦åº”è¯¥è¢«åŒ…å«åœ¨ç»“æœä¸­</li>
      <li>reduce â€” å¦‚ä½•å°†å…ƒç´ åˆå¹¶åˆ°ä¸€ä¸ªæ€»å’Œçš„å€¼ä¸­</li>
      <li>sequence â€” åºåˆ—ä¸­ä¸‹ä¸€ä¸ªå…ƒç´ åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ</li>
      <li>forEach â€” å¯¹äºä¸€ä¸ªå…ƒç´ ï¼Œåº”è¯¥æ‰§è¡Œæ€æ ·çš„æ“ä½œ</li>
      <li>sortï¼ŒlexicographicCompare å’Œ partition â€” ä¸¤ä¸ªå…ƒç´ åº”è¯¥ä»¥æ€æ ·çš„é¡ºåºè¿›è¡Œæ’åˆ—</li>
      <li>indexï¼Œfirst å’Œ contains â€” å…ƒç´ æ˜¯å¦ç¬¦åˆæŸä¸ªæ¡ä»¶</li>
      <li>min å’Œ max â€” ä¸¤ä¸ªå…ƒç´ ä¸­çš„æœ€å°/æœ€å¤§å€¼æ˜¯å“ªä¸ª</li>
      <li>elementsEqual å’Œ starts â€” ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸ç­‰</li>
      <li>split â€” è¿™ä¸ªå…ƒç´ æ˜¯å¦æ˜¯ä¸€ä¸ªåˆ†å‰²ç¬¦</li>
      <li>prefix - å½“åˆ¤æ–­ä¸ºçœŸçš„æ—¶å€™ï¼Œå°†å…ƒç´ æ»¤å‡ºåˆ°ç»“æœä¸­ã€‚ä¸€æ—¦ä¸ä¸ºçœŸï¼Œå°±å°†å‰©ä½™çš„æŠ›å¼ƒã€‚å’Œ filter ç±»ä¼¼ï¼Œä½†æ˜¯ä¼šæå‰é€€å‡ºã€‚è¿™ä¸ªå‡½æ•°åœ¨å¤„ç†æ— é™åºåˆ—æˆ–è€…æ˜¯å»¶è¿Ÿè®¡ç®— (lazily-computed) çš„åºåˆ—æ—¶ä¼šéå¸¸æœ‰ç”¨ã€‚</li>
      <li>drop - å½“åˆ¤æ–­ä¸ºçœŸçš„æ—¶å€™ï¼Œä¸¢å¼ƒå…ƒç´ ã€‚ä¸€æ—¦ä¸ä¸ºçœŸï¼Œè¿”å›å°†å…¶ä½™çš„å…ƒç´ ã€‚å’Œ prefix(while:) ç±»ä¼¼ï¼Œä¸è¿‡è¿”å›ç›¸åçš„é›†åˆã€‚</li>
    </ul>
  </li>
  <li>å‡½æ•°å‚æ•°åŒ–çš„å¥½å¤„
    <ul>
      <li>æ‘†è„±ä»£ç ä¸­æ‚ä¹±æ— ç”¨éƒ¨åˆ†ï¼Œé€»è¾‘æ›´åŠ æ¸…æ™°ã€‚</li>
      <li>ä¸€äº›å‡½æ•°çš„é»˜è®¤è¡Œä¸ºä½¿å‡½æ•°æ›´æ˜“è¯»ã€‚</li>
    </ul>
  </li>
  <li>å…¶ä»–å®ç”¨å‡½æ•°
    <ul>
      <li>accumulate â€” ç´¯åŠ ï¼Œå’Œ reduce ç±»ä¼¼ï¼Œä¸è¿‡æ˜¯å°†æ‰€æœ‰å…ƒç´ åˆå¹¶åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œå¹¶ä¿ç•™åˆå¹¶æ—¶æ¯ä¸€æ­¥çš„å€¼ã€‚</li>
      <li>all(matching:) å’Œ none(matching:) â€” æµ‹è¯•åºåˆ—ä¸­æ˜¯ä¸æ˜¯æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³æŸä¸ªæ ‡å‡†ï¼Œä»¥åŠæ˜¯ä¸æ˜¯æ²¡æœ‰ä»»ä½•å…ƒç´ æ»¡è¶³æŸä¸ªæ ‡å‡†ã€‚å®ƒä»¬å¯ä»¥é€šè¿‡ contains å’Œå®ƒè¿›è¡Œäº†ç²¾å¿ƒå¯¹åº”çš„å¦å®šå½¢å¼æ¥æ„å»ºã€‚</li>
      <li>count(where:) â€” è®¡ç®—æ»¡è¶³æ¡ä»¶çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œå’Œ filter ç›¸ä¼¼ï¼Œä½†æ˜¯ä¸ä¼šæ„å»ºæ•°ç»„ã€‚</li>
      <li>indices(where:) â€” è¿”å›ä¸€ä¸ªåŒ…å«æ»¡è¶³æŸä¸ªæ ‡å‡†çš„æ‰€æœ‰å…ƒç´ çš„ç´¢å¼•çš„åˆ—è¡¨ï¼Œå’Œ index(where:) ç±»ä¼¼ï¼Œä½†æ˜¯ä¸ä¼šåœ¨é‡åˆ°é¦–ä¸ªå…ƒç´ æ—¶å°±åœæ­¢ã€‚</li>
    </ul>
  </li>
  <li>è‡ªå®šä¹‰æ‰©å±•çš„å°è£…</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let names = ["Paula", "Elena", "Zoe"]
var lastNameEndingInA: String?
for name in names.reversed() where name.hasSuffix("a") {
  lastNameEndingInA = name
  break
}
lastNameEndingInA // Optional("Elena")

extension Sequence {
  func last(where predicate: (Element) -&gt; Bool) -&gt; Element? {
    for element in reversed() where predicate(element) {
      return element
    }
    return nil
  }
}

guard let match = someSequence.last(where: { $0.passesTest() })
else { return }

</code></pre></div></div>
<ul>
  <li>å¯å˜çš„å¸¦æœ‰çŠ¶æ€çš„é—­åŒ…</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Array {

    // åˆ›å»ºä¸€ä¸ªä¸­é—´å˜é‡å­˜å‚¨æ¯ä¸€æ­¥çš„å€¼ï¼Œç„¶åä½¿ç”¨mapä»ä¸­é—´å€¼é€æ­¥è®¡ç®—ç»“æœæ•°ç»„
    func accumulate&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) -&gt; Result) -&gt; [Result]
    {
        var running = initialResult

        return map { next in
            running = nextPartialResult(running, next)
            return running
        }
    }
}

arr.accumulate(0) { (lastRe, no) -&gt; Int in
    return lastRe + no
}

arr.accumulate(0) { lastRe, no in
    lastRe + no
}

arr.accumulate(0, +)

</code></pre></div></div>

<ul>
  <li>Filter</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å¯¹ 0..&lt;10 è¿›è¡Œ map æ¥å¾—åˆ°æ‰€æœ‰å¹³æ–¹æ•°ï¼Œç„¶åå†ç”¨ filter è¿‡æ»¤å‡ºå…¶ä¸­çš„å¶æ•°
(1..&lt;10).map { $0 * $0 }.filter { $0 % 2 == 0 } // [4, 16, 36, 64]

// é”™è¯¯
bigArray.filter { someCondition }.count &gt; 0
// æ­£ç¡®
bigArray.contains { someCondition }

// å°è£… !sequence.contains { !condition }
extension Sequence {
    public func all(matching predicate: (Element) -&gt; Bool) -&gt; Bool {
        // å¯¹äºä¸€ä¸ªæ¡ä»¶ï¼Œå¦‚æœæ²¡æœ‰å…ƒç´ ä¸æ»¡è¶³å®ƒçš„è¯ï¼Œé‚£æ„å‘³ç€æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³å®ƒï¼š
        return !contains { !predicate($0) }
    }
}
let evenNums = nums.filter { $0 % 2 == 0 } // [2, 4, 6, 8, 10]
evenNums.all { $0 % 2 == 0 } // true

</code></pre></div></div>

<ul>
  <li>Reduce<br />
reduceæ–¹æ³•ï¼šå°†ä¸€ä¸ªåˆå§‹å€¼å’Œä¸€ä¸ªå°†ä¸­é—´å€¼ä¸åºåˆ—ä¸­çš„å…ƒç´ è¿›è¡Œåˆå¹¶çš„å‡½æ•°è¿›è¡ŒæŠ½è±¡ã€‚</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let fibs = [0, 1, 1, 2, 3, 5]
var total = 0
for num in fibs {
  total = total + num
}
total // 12

// æ”¹å†™
let sum = fibs.reduce(0) { total, num in total + num } // 12
fibs.reduce(0, +) // 12

fibs.reduce("") { str, num in str + "\(num), " } // 0, 1, 1, 2, 3, 5,

// reduceçš„å®ç°
extension Array {
    func reduce&lt;Result&gt;(_ initialResult: Result,
                        _ nextPartialResult: (Result, Element) -&gt; Result) -&gt; Result
    {
        var result = initialResult
        for x in self {
            result = nextPartialResult(result, x)
        }
        return result
    }
}

// ç”¨reduceå®ç°mapå’Œfilterï¼Œå¤æ‚åº¦ï¼šO(n2)
extension Array {
    func map2&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] {
        return reduce([]) {
            $0 + [transform($1)]
        }
    }
    func filter2(_ isIncluded: (Element) -&gt; Bool) -&gt; [Element] {
        return reduce([]) {
            isIncluded($1) ? $0 + [$1] : $0
        }
    }
}

// ä¼˜åŒ–ï¼Œå¤æ‚åº¦ï¼šO(n)
public func reduce&lt;Result&gt;(into initialResult: Result,
                           _ updateAccumulatingResult:
    (_ partialResult: inout Result, Element) throws -&gt; ()
) rethrows -&gt; Result

extension Array {
    func filter3(_ isIncluded: (Element) -&gt; Bool) -&gt; [Element] {
        return reduce(into: []) { result, element in
            if isIncluded(element) {
                result.append(element)
            }
        }
    }
}
</code></pre></div></div>

<ul>
  <li>flatMap</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func extractLinks(markdownFile: String) -&gt; [URL]
let markdownFiles: [String] = // ...
let nestedLinks = markdownFiles.map(extractLinks)
let links = nestedLinks.joined()

// å°†mapå’Œjoinedæ“ä½œåˆäºŒä¸ºä¸€
markdownFiles.flatMap(links)

extension Array {
  func flatMap&lt;T&gt;(_ transform: (Element) -&gt; [T]) -&gt; [T] {
      var result: [T] = []
      for x in self {
        result.append(contentsOf: transform(x))
      }
      return result
    }
}

// å°†ä¸åŒæ•°ç»„çš„å…ƒç´ é…å¯¹åˆå¹¶
let suits = ["â™ ï¸", "â™¥ï¸", "â™£ï¸", "â™¦ï¸"]
let ranks = ["J","Q","K","A"]
let result = suits.flatMap { suit in
  ranks.map { rank in
    (suit, rank)
  }
}
/*
[("â™ ï¸", "J"), ("â™ ï¸", "Q"), ("â™ ï¸", "K"), ("â™ ï¸", "A"), ("â™¥ï¸", "J"), ("â™¥ï¸",
"Q"), ("â™¥ï¸", "K"), ("â™¥ï¸", "A"), ("â™£ï¸", "J"), ("â™£ï¸", "Q"), ("â™£ï¸", "K"),
("â™£ï¸", "A"), ("â™¦ï¸", "J"), ("â™¦ï¸", "Q"), ("â™¦ï¸", "K"), ("â™¦ï¸", "A")]
*/

</code></pre></div></div>

<ul>
  <li>forEach</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for element in [1,2,3] {
  print(element)
}

[1,2,3].forEach { element in
  print(element)
}

extension Array where Element: Equatable {
  func index(of element: Element) -&gt; Int? {
    for idx in self.indices where self[idx] == element {
      return idx
    }
    return nil
  }
}

// é”™è¯¯ï¼ŒforEachä¸­çš„returnå¹¶ä¸èƒ½è¿”å›åˆ°å¤–éƒ¨ç•ªè–¯çš„ä½œç”¨åŸŸä¹‹å¤–ï¼Œäº§ç”Ÿè­¦å‘Š
extension Array where Element: Equatable {
  func index_foreach(of element: Element) -&gt; Int? {
    self.indices.filter { idx in
    self[idx] == element
    }.forEach { idx in
      return idx
    }
    return nil
  }
}

// é”™è¯¯ï¼Œä»…ä»…ä»é—­åŒ…ä¸­è¿”å›ï¼Œå¹¶ä¸ä¼šç»ˆæ­¢å¾ªç¯
(1..&lt;10).forEach { number in
  print(number)
  if number &gt; 2 { return }
}

</code></pre></div></div>

<h4 id="4-æ•°ç»„ç±»å‹">4. æ•°ç»„ç±»å‹</h4>
<ul>
  <li>åˆ‡ç‰‡<br />
<img src="http://files.pandaleo.cn/f63b30887af7b9e47d198158a37466ea.png?imageMogr2/thumbnail/!50p" alt="" /></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é€šè¿‡åˆ‡ç‰‡è·å–æŸä¸ªèŒƒå›´ä¸­çš„å…ƒç´ 
let slice = fibs[1...]
slice // [1, 1, 2, 3, 5]
type(of: slice) // ArraySlice&lt;Int&gt;

// åˆ‡ç‰‡ç±»å‹æ˜¯æ•°ç»„çš„ä¸€ç§è¡¨ç¤ºæ–¹å¼ï¼Œæ•°æ®ä¸€æ ·ï¼Œå¯ä»¥ç”¨Arrayæ„å»ºæ–¹æ³•è½¬åŒ–ã€‚
let newArray = Array(slice)
type(of: newArray) // Array&lt;Int&gt;

</code></pre></div></div>
<ul>
  <li>æ¡¥æ¥<br />
Swiftæ•°ç»„å¯ä»¥æ¡¥æ¥åˆ°OCå’ŒCä¸­ï¼Œç”±äºNSArrayåªèƒ½æŒæœ‰å¯¹è±¡ï¼Œåœ¨æ¡¥æ¥è½¬æ¢æ—¶ï¼Œç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶ä¼šå°†ä¸å…¼å®¹çš„å€¼ï¼ˆæ¯”å¦‚Swiftçš„æšä¸¾ï¼‰ç”¨ä¸€ä¸ªä¸é€æ˜çš„boxå¯¹è±¡åŒ…è£…èµ·æ¥ã€‚å€¼ç±»å‹ä¹Ÿä¼šè‡ªåŠ¨æ¡¥æ¥åˆ°OCä¸­å¯¹åº”çš„ç±»å‹ï¼Œå¦‚ Intï¼ŒBool å’Œ Stringï¼Œç”šè‡³ Dictionary å’Œ Setã€‚</li>
</ul>

<h3 id="äºŒå­—å…¸dictionary">äºŒã€å­—å…¸Dictionary</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å®šä¹‰appè®¾ç½®ç•Œé¢ï¼Œä½¿ç”¨å­—å…¸ä½œä¸ºæ•°æ®æ¨¡å‹
enum Setting {
  case text(String)
  case int(Int)
  case bool(Bool)
}
let defaultSettings: [String:Setting] = [
  "Airplane Mode": .bool(false),
  "Name": .text("My iPhone"),
]
defaultSettings["Name"] // Optional(Setting.text("My iPhone"))

</code></pre></div></div>
<h4 id="1å®šä¹‰">1.å®šä¹‰</h4>
<ul>
  <li>å­—å…¸åŒ…å«å»ºå’Œå¯¹åº”çš„å€¼ï¼Œä¸€ä¸ªå­—å…¸ä¸­ï¼Œæ¯ä¸ªé”®åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚</li>
  <li>å’Œæ•°ç»„çš„åŒºåˆ«
    <ul>
      <li>è€—æ—¶ä¸åŒã€‚é€šè¿‡é”®æ¥è·å–å€¼æ‰€èŠ±è´¹çš„å¹³å‡æ—¶é—´æ˜¯å¸¸æ•°é‡çº§çš„ã€‚ä½œä¸ºå¯¹æ¯”ï¼Œåœ¨æ•°ç»„ä¸­æœå¯»ä¸€ä¸ªç‰¹å®šå…ƒç´ æ‰€èŠ±çš„æ—¶é—´å°†ä¸æ•°ç»„å°ºå¯¸æˆæ­£æ¯”ã€‚</li>
      <li>é¡ºåºä¸åŒã€‚å­—å…¸æ˜¯æ— åºçš„ï¼Œä½¿ç”¨ for å¾ªç¯æ¥æšä¸¾å­—å…¸ä¸­çš„é”®å€¼å¯¹æ—¶ï¼Œé¡ºåºæ˜¯ä¸ç¡®å®šçš„ã€‚</li>
      <li>è¿”å›ä¸åŒã€‚å­—å…¸æŸ¥æ‰¾å°†è¿”å›çš„æ˜¯å¯é€‰å€¼ï¼Œå½“ç‰¹å®šé”®ä¸å­˜åœ¨æ—¶ï¼Œä¸‹æ ‡æŸ¥è¯¢è¿”å› nilã€‚åœ¨æ•°ç»„ä¸­ï¼Œä½¿ç”¨è¶Šç•Œä¸‹æ ‡è¿›è¡Œè®¿é—®å°†ä¼šå¯¼è‡´ç¨‹åºå´©æºƒã€‚</li>
      <li>ä½¿ç”¨æ–¹å¼ä¸åŒã€‚å­—å…¸çš„é”®ä»å…¶ä»–æ¸ é“è·å–ï¼Œæ•°ç»„è¾ƒå°‘ä½¿ç”¨ç´¢å¼•ã€‚</li>
    </ul>
  </li>
</ul>

<h4 id="2å¯å˜æ€§">2.å¯å˜æ€§</h4>
<ul>
  <li>letå®šä¹‰ä¸å¯å˜ï¼Œvarå£°æ˜å¯å˜</li>
  <li>ç§»é™¤æ–¹å¼
    <ul>
      <li>ä¸‹æ ‡å€¼è®¾ä¸ºnil</li>
      <li>removeValue(forKey:)ï¼Œä¼šå°†åˆ é™¤å€¼è¿”å›ï¼Œä¸å­˜åœ¨è¿”å›nil</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ”¹å˜ä¸å¯å˜å­—å…¸æ—¶ï¼Œå…ˆè¿›è¡Œå¤åˆ¶ï¼ŒåŸå­—å…¸ä¸ä¼šæ”¹å˜
var userSettings = defaultSettings
userSettings["Name"] = .text("Jared's iPhone")
userSettings["Do Not Disturb"] = .bool(true)

// updateValue(_:forKey:)æ›´æ–°æ—¶ï¼Œä¼šè¿”å›æ›´æ–°å‰çš„å€¼
let oldName = userSettings.updateValue(.text("Jane's iPhone"), forKey: "Name")
userSettings["Name"] // Optional(Setting.text("Jane\'s iPhone"))
oldName // Optional(Setting.text("Jared\'s iPhone"))
</code></pre></div></div>

<h4 id="3æœ‰ç”¨çš„å­—å…¸æ–¹æ³•">3.æœ‰ç”¨çš„å­—å…¸æ–¹æ³•</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// mergeï¼Œåˆå¹¶å­—å…¸
// åˆå¹¶é”®å€¼å¯¹ï¼Œä½¿ç”¨äº† { $1 } æ¥ä½œä¸ºåˆå¹¶ä¸¤ä¸ªå€¼çš„ç­–ç•¥ã€‚
// æŸä¸ªé”®åŒæ—¶å­˜åœ¨äº settings å’Œ overriddenSettings ä¸­æ—¶ï¼Œä½¿ç”¨ overriddenSetttings ä¸­çš„å€¼ã€‚

var settings = defaultSettings
let overriddenSettings: [String:Setting] = ["Name": .text("Jane's iPhone")]
settings.merge(overriddenSettings, uniquingKeysWith: { $1 })
settings
// ["Name": Setting.text("Jane\'s iPhone"), "Airplane Mode": Setting.bool(false)]

// è®¡ç®—åºåˆ—ä¸­æŸä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œé‡åˆ°ç›¸åŒé”®ä½¿ç”¨â€œ+ç­–ç•¥â€åˆå¹¶
extension Sequence where Element: Hashable {
  var frequencies: [Element:Int] {
    let frequencyPairs = self.map { ($0, 1) }
    return Dictionary(frequencyPairs, uniquingKeysWith: +)
  }
}
let frequencies = "hello".frequencies // ["e": 1, "o": 1, "l": 2, "h": 1]
frequencies.filter { $0.value &gt; 1 } // ["l": 2]

// ä¿æŒå­—å…¸ç»“æ„ï¼Œåªå¯¹å€¼è¿›è¡Œæ˜ å°„
let settingsAsStrings = settings.mapValues { setting -&gt; String in
  switch setting {
    case .text(let text): return text
    case .int(let number): return String(number)
    case .bool(let value): return String(value)
  }
}
settingsAsStrings // ["Name": "Jane\'s iPhone", "Airplane Mode": "false"]

</code></pre></div></div>

<h4 id="4hashableè¦æ±‚">4.Hashableè¦æ±‚</h4>
<ul>
  <li>å­—å…¸å°±æ˜¯å“ˆå¸Œè¡¨ï¼Œé€šè¿‡é”®çš„hashValueä¸ºæ¯ä¸ªé”®æŒ‡å®šä¸€ä¸ªä½ç½®ï¼Œå’Œå¯¹åº”çš„å­˜å‚¨ã€‚å› æ­¤Keyç±»å‹éœ€è¦éµå®ˆHashableåè®®ï¼Œæ ‡å‡†åº“ä¸­æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»å‹éƒ½éµå®ˆHashableåè®®ï¼ŒåŒ…æ‹¬ï¼šå­—ç¬¦ä¸²ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼ã€‚ä¸å¸¦å…³è”å€¼çš„æšä¸¾ç±»å‹è‡ªåŠ¨éµå®ˆHashableã€‚</li>
  <li>å°†è‡ªå®šä¹‰çš„ç±»å‹ç”¨ä½œå­—å…¸çš„é”®ï¼Œå¿…é¡»æ‰‹åŠ¨æ·»åŠ  Hashable å¹¶æ»¡è¶³å®ƒï¼Œå®ç° hashValue å±æ€§ã€‚å¦å¤–ï¼Œå› ä¸º Hashable æœ¬èº«æ˜¯å¯¹ Equatable çš„æ‰©å±•ï¼Œå› æ­¤ä½ è¿˜éœ€è¦ä¸ºä½ çš„ç±»å‹é‡è½½ == è¿ç®—ç¬¦ï¼Œå¿…é¡»ä¿è¯å“ˆå¸Œä¸å˜åŸåˆ™ã€‚
    <ul>
      <li>ä¸¤ä¸ªåŒæ ·çš„å®ä¾‹ (ç”±ä½ å®ç°çš„ == å®šä¹‰ç›¸åŒ)ï¼Œå¿…é¡»æ‹¥æœ‰åŒæ ·çš„å“ˆå¸Œå€¼ã€‚ä¸è¿‡åè¿‡æ¥ä¸å¿…ä¸ºçœŸï¼šä¸¤ä¸ªç›¸åŒå“ˆå¸Œå€¼çš„å®ä¾‹ä¸ä¸€å®šéœ€è¦ç›¸ç­‰ã€‚ä¸åŒçš„å“ˆå¸Œå€¼çš„æ•°é‡æ˜¯æœ‰é™çš„ï¼Œç„¶è€Œå¾ˆå¤šå¯ä»¥è¢«å“ˆå¸Œçš„ç±»å‹ (æ¯”å¦‚å­—ç¬¦ä¸²) çš„ä¸ªæ•°æ˜¯æ— ç©·çš„ã€‚</li>
      <li>å“ˆå¸Œå€¼å¯èƒ½é‡å¤è¿™ä¸€ç‰¹æ€§ï¼Œæ„å‘³ç€ Dictionary å¿…é¡»èƒ½å¤Ÿå¤„ç†å“ˆå¸Œç¢°æ’ã€‚</li>
      <li>ä¸€ä¸ªå…³äºè‡ªåŠ¨æ»¡è¶³ Equatable å’Œ Hashable çš„ææ¡ˆå·²ç»è¢«æ¥å—äº†ã€‚ä¸€æ—¦è¿™ä¸ªç‰¹æ€§è¢«å®ç°å¹¶ä¸”åˆå¹¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®©ç¼–è¯‘å™¨è‡ªåŠ¨ä¸ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹ç”Ÿæˆæ»¡è¶³ Equatable å’Œ Hashable åè®®çš„ä»£ç ã€‚</li>
      <li>å¦‚æœä½ åœ¨å°†ä¸€ä¸ªå¯¹è±¡ç”¨ä½œå­—å…¸é”®åï¼Œæ”¹å˜äº†å®ƒçš„å†…å®¹ï¼Œå®ƒçš„å“ˆå¸Œå€¼å’Œ/æˆ–ç›¸ç­‰ç‰¹æ€§å¾€å¾€ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ã€‚è¿™æ—¶å€™ä½ å°†æ— æ³•å†åœ¨å­—å…¸ä¸­æ‰¾åˆ°å®ƒã€‚è¿™æ—¶å­—å…¸ä¼šåœ¨é”™è¯¯çš„ä½ç½®å­˜å‚¨å¯¹è±¡ï¼Œè¿™å°†å¯¼è‡´å­—å…¸å†…éƒ¨å­˜å‚¨çš„é”™è¯¯ã€‚</li>
    </ul>
  </li>
</ul>

<h3 id="ä¸‰set">ä¸‰ã€Set</h3>
<h4 id="1å®šä¹‰-1">1.å®šä¹‰</h4>
<p>é›†åˆæ˜¯ä¸€ç»„æ— åºçš„å…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ åªä¼šå‡ºç°ä¸€æ¬¡ï¼Œå¯ä»¥å°†é›†åˆæƒ³åƒä¸ºä¸€ä¸ªåªå­˜å‚¨äº†é”®è€Œæ²¡æœ‰å­˜å‚¨å€¼çš„å­—å…¸ã€‚</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Set éµå®ˆ ExpressibleByArrayLiteral åè®®ï¼Œå¯ä»¥ç”¨æ•°ç»„å­—é¢é‡çš„æ–¹å¼åˆå§‹åŒ–ä¸€ä¸ªé›†åˆ
let naturals: Set = [1, 2, 3, 2]
naturals // [2, 3, 1]
naturals.contains(3) // true
naturals.contains(0) // false
</code></pre></div></div>
<h4 id="2é›†åˆä»£æ•°">2.é›†åˆä»£æ•°</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åœ¨ä¸€ä¸ªé›†åˆä¸­æ±‚å¦ä¸€ä¸ªé›†åˆçš„è¡¥é›†
let iPods: Set = ["iPod touch", "iPod nano", "iPod mini",
"iPod shuffle", "iPod Classic"]
let discontinuedIPods: Set = ["iPod mini", "iPod Classic",
"iPod nano", "iPod shuffle"]
let currentIPods = iPods.subtracting(discontinuedIPods) // ["iPod touch"]

// ä¸¤ä¸ªé›†åˆçš„äº¤é›†ï¼Œæ‰¾å‡ºä¸¤ä¸ªé›†åˆä¸­éƒ½å«æœ‰çš„å…ƒç´ 
let touchscreen: Set = ["iPhone", "iPad", "iPod touch", "iPod nano"]
let iPodsWithTouch = iPods.intersection(touchscreen)
// ["iPod touch", "iPod nano"]

// ä¸¤ä¸ªé›†åˆçš„å¹¶é›†ï¼Œå°†ä¸¤ä¸ªé›†åˆåˆå¹¶ä¸ºä¸€ä¸ª (å½“ç„¶ï¼Œç§»é™¤é‚£äº›é‡å¤å¤šä½™çš„)
// å‡ ä¹æ‰€æœ‰çš„é›†åˆæ“ä½œéƒ½æœ‰ä¸å¯å˜ç‰ˆæœ¬ä»¥åŠå¯å˜ç‰ˆæœ¬çš„å½¢å¼ï¼Œåä¸€ç§éƒ½ä»¥ form... å¼€å¤´
var discontinued: Set = ["iBook", "Powerbook", "Power Mac"]
discontinued.formUnion(discontinuedIPods)
discontinued
/*
["iBook", "Powerbook", "Power Mac", "iPod Classic", "iPod mini",
"iPod shuffle", "iPod nano"]
*/

</code></pre></div></div>
<h4 id="3ç´¢å¼•é›†åˆå’Œå­—ç¬¦é›†åˆ">3.ç´¢å¼•é›†åˆå’Œå­—ç¬¦é›†åˆ</h4>
<ul>
  <li>IndexSet è¡¨ç¤ºäº†ä¸€ä¸ªç”±æ­£æ•´æ•°ç»„æˆçš„é›†åˆï¼Œä¼šå­˜å‚¨è¿ç»­çš„èŒƒå›´ï¼Œåªå­˜å‚¨é€‰æ‹©çš„é¦–ä½å’Œæœ«ä½ä¸¤ä¸ªæ•´æ•°å€¼
ï¼Œæ¯”Set<Int>æ›´åŠ é«˜æ•ˆã€‚</Int></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var indices = IndexSet()
indices.insert(integersIn: 1..&lt;5)
indices.insert(integersIn: 11..&lt;15)
let evenIndices = indices.filter { $0 % 2 == 0 } // [2, 4, 12, 14]
</code></pre></div></div>
<ul>
  <li>CharacterSet æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„å­˜å‚¨ Unicode ç ç‚¹ (code point) çš„é›†åˆï¼Œä¸æ˜¯é›†åˆç±»å‹ï¼Œåå­—æ˜¯OCå¯¼å…¥æ—¶ç”Ÿæˆçš„ï¼ŒUnicodeScalarSetå‘½åä¼šæ›´åŠ å‡†ç¡®ã€‚</li>
</ul>

<h4 id="4åœ¨é—­åŒ…ä¸­ä½¿ç”¨é›†åˆ">4.åœ¨é—­åŒ…ä¸­ä½¿ç”¨é›†åˆ</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æŒ‰åŸæ¥é¡ºåºæ‰¾åˆ°åºåˆ—ä¸­æ‰€æœ‰ä¸é‡å¤çš„å…ƒç´ 
extension Sequence where Element: Hashable {
  func unique() -&gt; [Element] {
    var seen: Set&lt;Element&gt; = []
    return filter { element in
      if seen.contains(element) {
        return false
      } else {
        seen.insert(element)
        return true
      }
    }
  }
}
[1,2,3,12,1,3,4,5,6,4,6].unique() // [1, 2, 3, 12, 4, 5, 6]

</code></pre></div></div>
<h3 id="å››range">å››ã€Range</h3>
<h4 id="1å®šä¹‰-2">1.å®šä¹‰</h4>
<ul>
  <li>èŒƒå›´ä»£è¡¨çš„æ˜¯ä¸¤ä¸ªå€¼çš„åŒºé—´ï¼Œå®ƒç”±ä¸Šä¸‹è¾¹ç•Œè¿›è¡Œå®šä¹‰ã€‚</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é€šè¿‡ ..&lt; æ¥åˆ›å»ºä¸€ä¸ªä¸åŒ…å«ä¸Šè¾¹ç•Œçš„åŠå¼€èŒƒå›´ï¼Œæˆ–è€…ä½¿ç”¨ ... åˆ›å»ºåŒæ—¶åŒ…å«ä¸Šä¸‹è¾¹ç•Œçš„é—­åˆèŒƒå›´ï¼š
// 0 åˆ° 9, ä¸åŒ…å« 10
let singleDigitNumbers = 0..&lt;10
Array(singleDigitNumbers) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// åŒ…å« "z"
let lowercaseLetters = Character("a")...Character("z")

// è¿™äº›æ“ä½œç¬¦è¿˜æœ‰ä¸€äº›å‰ç¼€å’Œåç¼€çš„å˜å‹ç‰ˆæœ¬ï¼Œç”¨æ¥è¡¨ç¤ºå•è¾¹çš„èŒƒå›´ï¼š
let fromZero = 0...
let upToZ = ..&lt;Character("z")
</code></pre></div></div>
<ul>
  <li>å…±æœ‰å…«ç§ä¸åŒçš„ç‹¬ç«‹ç±»å‹å¯ä»¥ç”¨æ¥è¡¨ç¤ºèŒƒå›´ï¼Œæ¯ç§ç±»å‹éƒ½ä»£è¡¨äº†å¯¹å€¼çš„ä¸åŒçš„çº¦æŸã€‚
    <ul>
      <li>æœ€å¸¸ç”¨çš„ä¸¤ç§ç±»å‹æ˜¯ Range (ç”± ..&lt; åˆ›å»ºçš„åŠå¼€èŒƒå›´) å’Œ ClosedRange (ç”± â€¦ åˆ›å»ºçš„é—­åˆèŒƒå›´)ã€‚</li>
      <li>ä¸¤è€…éƒ½æœ‰ä¸€ä¸ª Bound çš„æ³›å‹å‚æ•°ï¼šå¯¹äº Bound çš„å”¯ä¸€çš„è¦æ±‚æ˜¯å®ƒå¿…é¡»éµå®ˆ Comparable åè®®ã€‚</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä¸èƒ½å¯¹ Range æˆ–è€… ClosedRange è¿›è¡Œè¿­ä»£
// å¯ä»¥æ£€æŸ¥æŸä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨äºèŒƒå›´
singleDigitNumbers.contains(9) // true
lowercaseLetters.overlaps("c"..&lt;"f") // true
</code></pre></div></div>
<ul>
  <li>åŠå¼€èŒƒå›´å’Œé—­åˆèŒƒå›´å„æœ‰æ‰€ç”¨
    <ul>
      <li>åªæœ‰åŠå¼€èŒƒå›´èƒ½è¡¨è¾¾ç©ºé—´éš” (ä¹Ÿå°±æ˜¯ä¸‹ç•Œå’Œä¸Šç•Œç›¸ç­‰çš„æƒ…å†µï¼Œæ¯”å¦‚ 5..&lt;5)ã€‚</li>
      <li>åªæœ‰é—­åˆèŒƒå›´èƒ½åŒ…æ‹¬å…¶å…ƒç´ ç±»å‹æ‰€èƒ½è¡¨è¾¾çš„æœ€å¤§å€¼ (æ¯”å¦‚ 0â€¦Int.max)ã€‚è€ŒåŠå¼€èŒƒå›´åˆ™è¦æ±‚èŒƒå›´ä¸Šç•Œæ˜¯ä¸€ä¸ªæ¯”è‡ªèº«æ‰€åŒ…å«çš„æœ€å¤§å€¼è¿˜è¦å¤§ 1 çš„å€¼ã€‚</li>
    </ul>
  </li>
</ul>

<h4 id="2å¯æ•°èŒƒå›´">2.å¯æ•°èŒƒå›´</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in 0..&lt;10 {
  print("\(i)", terminator: " ")
} // 0 1 2 3 4 5 6 7 8 9
</code></pre></div></div>
<ul>
  <li>å¯æ•°èŒƒå›´ï¼š0..&lt;10 çš„ç±»å‹å…¶å®æ˜¯ä¸€ä¸ª CountableRange<Int>ï¼Œå®ƒçš„å…ƒç´ ç±»å‹éœ€è¦éµå®ˆ Strideable åè®® (ä»¥æ•´æ•°ä¸ºæ­¥é•¿)ï¼Œåªæœ‰è¿™ç±»èŒƒå›´å¯ä»¥è¢«è¿­ä»£ã€‚</Int></li>
  <li>å¯æ•°èŒƒå›´çš„è¾¹ç•Œå¯ä»¥æ˜¯æ•´æ•°æˆ–è€…æŒ‡é’ˆç±»å‹ï¼Œä½†ä¸èƒ½æ˜¯æµ®ç‚¹æ•°ç±»å‹ï¼Œè¿™æ˜¯ç”±äº Stride ç±»å‹ä¸­æœ‰ä¸€ä¸ªæ•´æ•°çš„çº¦æŸã€‚å¦‚æœä½ æƒ³è¦å¯¹è¿ç»­çš„æµ®ç‚¹æ•°å€¼è¿›è¡Œè¿­ä»£çš„è¯ï¼Œä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ stride(from:to:by) å’Œ stride(from:through:by) æ–¹æ³•æ¥åˆ›å»ºåºåˆ—ç”¨ä»¥è¿­ä»£ã€‚Strideable çš„çº¦æŸä½¿å¾— CountableRange å’Œ CountableClosedRange éµå®ˆ RandomAccessCollectionï¼Œäºæ˜¯æˆ‘ä»¬å°±èƒ½å¤Ÿå¯¹å®ƒä»¬è¿›è¡Œè¿­ä»£äº†ã€‚</li>
</ul>

<table>
  <thead>
    <tr>
      <th>æ•´æ•°æ­¥é•¿</th>
      <th>åŠå¼€èŒƒå›´</th>
      <th>é—­åˆèŒƒå›´</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>å…ƒç´ æ»¡è¶³ Comparable</td>
      <td>Range</td>
      <td>ClosedRange</td>
    </tr>
    <tr>
      <td>å…ƒç´ æ»¡è¶³ Strideable</td>
      <td>CountableRange</td>
      <td>CountableClosedRange</td>
    </tr>
  </tbody>
</table>

<h4 id="3éƒ¨åˆ†èŒƒå›´">3.éƒ¨åˆ†èŒƒå›´</h4>
<p>éƒ¨åˆ†èŒƒå›´ (partial range) æŒ‡çš„æ˜¯å°† â€¦ æˆ– ..&lt; ä½œä¸ºå‰ç½®æˆ–è€…åç½®è¿ç®—ç¬¦æ¥ä½¿ç”¨æ—¶æ‰€æ„é€ çš„èŒƒå›´ã€‚</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Boundä¸æ»¡è¶³Strideableï¼Œæ— æ³•è¿­ä»£
let fromA: PartialRangeFrom&lt;Character&gt; = Character("a")...

// æ²¡æœ‰ä¸‹ç•Œï¼Œæ— æ³•å¼€å§‹è¿­ä»£
let throughZ: PartialRangeThrough&lt;Character&gt; = ...Character("z")
let upto10: PartialRangeUpTo&lt;Int&gt; = ..&lt;10

// å”¯ä¸€èƒ½è¢«è¿­ä»£ï¼Œä¸æ–­é‡å¤è°ƒç”¨advanced(by:1)ï¼Œéœ€è¦æ·»åŠ breaké€€å‡ºæ¡ä»¶
let fromFive: CountablePartialRangeFrom&lt;Int&gt; = 5...
</code></pre></div></div>
<h4 id="4èŒƒå›´è¡¨è¾¾å¼">4.èŒƒå›´è¡¨è¾¾å¼</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// RangeExpression åè®®
public protocol RangeExpression {
  associatedtype Bound: Comparable
  func contains(_ element: Bound) -&gt; Bool
  func relative&lt;C: _Indexable&gt;(to collection: C) -&gt; Range&lt;Bound&gt; where C.Index == Bound
}

let arr = [1,2,3,4]
arr[2...] // [3, 4]
arr[..&lt;1] // [1]
arr[1...2] // [2, 3]
arr[...] // [1, 2, 3, 4]
type(of: arr) // Array&lt;Int&gt;

</code></pre></div></div>
:ET