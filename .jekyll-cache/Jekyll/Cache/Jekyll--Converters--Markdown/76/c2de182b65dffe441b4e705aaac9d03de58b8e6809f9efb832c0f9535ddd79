I"<h4 id="一-简述block">一. 简述Block</h4>
<ul>
  <li>Block 是将函数和上下文封装起来的对象；</li>
  <li>Block 对局部变量进行捕获，如果是对象类型，会捕获其所有权修饰符；
对全局全局局部变量，捕获引用；对全局变量和全局静态便令不捕获；</li>
  <li>在 Block 内部修改捕获对象时，需要使用 __Block 修饰符；</li>
  <li>ARC下使用强引用成员变量时，存在自引用型循环引用，需要添加 weak 修饰符；
MAC是直接复制，不存在该问题。</li>
  <li>MRC 中的 Block 在对象中传递时，需要使用 copy 方法，将其从栈区复制到堆区；
ARC 不需要，其本身就在堆区。</li>
</ul>

<h4 id="二-多线程">二. 多线程</h4>
<h5 id="1-gcd">1. GCD</h5>
<ul>
  <li>同步，新任务需要等待添加的任务执行完才能执行，不能开新线程；</li>
  <li>异步，可以多个任务同时执行，具备开辟新线程的能力；</li>
  <li>串行队列，同时只执行一个线程，所有的线程一个接一个执行；</li>
  <li>并发队列，同时可执行多个线程;</li>
  <li>同步串行会引起循环等待，产生死锁；</li>
  <li>异步串行，多个线程一个接一个执行，同时只执行一个；</li>
  <li>同步并发，可在同步任务上，同时执行多个线程；</li>
  <li>异步并发，多个线程同时执行；</li>
  <li>异步栅栏调用，实现多读单写的功能。</li>
</ul>

<h5 id="2-nsoperation">2. NSOperation</h5>
<ul>
  <li>可以对线程添加依赖；</li>
  <li>可以控制线程的状态，Ready、Excute、Cancel、Finish;</li>
  <li>默认系统控制，当使用 start 启动时，需要手动控制；</li>
  <li>通过 KVO 的方式结束 isCancel 的线程。</li>
</ul>

<h5 id="3-nsthread">3. NSThread</h5>
<p>start，创建 pThread， 启动 main 函数，target.performSelector，加入到 runloop，执行完 exit。</p>

<h5 id="4-常用锁">4. 常用锁</h5>
<ul>
  <li>synchronized 创建单例对象时，保证唯一；</li>
  <li>自旋锁，简单的增减操作；</li>
  <li>atomic，保证声明对象线程安全，但不能保证使用时安全；</li>
  <li>互斥锁 NSLock，重入时会产生死锁；</li>
  <li>递归所，解决互斥锁重入问题，适用于递归调用。</li>
  <li>dispathch_semaphore_t，记录信号量，共享资源互斥。</li>
</ul>

<h4 id="三-内存管理">三. 内存管理</h4>
<h5 id="1-内存布局从上到下">1. 内存布局：从上到下</h5>
<ul>
  <li>栈（方法调用）</li>
  <li>堆（alloc 分配的对象）</li>
  <li>未初始化数据区（全局变量）</li>
  <li>已初始化数据区</li>
  <li>代码段、保留区</li>
</ul>

<h5 id="2-管理方案">2. 管理方案</h5>
<ul>
  <li>taggedPointer，小对象，NSNumber；</li>
  <li>NOPOINTER_ISA，官方文档，未自定义 retain/release 或者 allocWithZone 的类型；</li>
  <li>SideTables，包含多张散列表，每张散列表包含自旋锁、引用计数表、弱引用表。优点
    <ul>
      <li>解决多个线程操作对象的停等的效率问题。</li>
      <li>分离锁，多个对象如果使用一张表需要顺序访问，将一张表分为多张，通过指针，Hash查找对应表，提高效率。</li>
    </ul>
  </li>
</ul>

<h4 id="四-引用计数">四. 引用计数</h4>
<h5 id="1-数据结构">1. 数据结构</h5>
<ul>
  <li>自旋锁，忙等，负责引用计数的增减操作；</li>
  <li>引用计数表，记录当前对象的引用计数；</li>
  <li>弱引用表，记录弱引用对象</li>
</ul>

<h5 id="2-mrc">2. MRC</h5>
<ul>
  <li>alloc/dealloc。dealloc，开始 - dispose - deinstruct - freeCdot - free 关联对象 - sidetable_clear - weaktable_clear - refcnts_clear - 结束</li>
  <li>retain/release</li>
  <li>refcnts，引用数</li>
  <li>autorease，栈式双向链表，当次 runloop 结束时释放哨兵位之间的内存。</li>
</ul>

<h5 id="3-arc">3. ARC</h5>
<ul>
  <li>由 LLVM 编译器和 runtime 共同实现；</li>
  <li>不能使用 MRC 中的 dealloc/retain/release/refcnts;</li>
  <li>添加了 weak 和 strong 的使用</li>
  <li>weak，声明时创建 weak 对象，包含新对象和 init_weak()方法</li>
</ul>

<h5 id="4-autorelease">4. Autorelease</h5>

<h5 id="5-循环引用">5. 循环引用</h5>
<ul>
  <li>自引用、循环引用、大环引用；</li>
  <li>block 的使用：
    <ul>
      <li>MRC 下，需要使用 copy 传值，将 block 从栈区复制到堆区；</li>
      <li>ARC 中，存在循环引用的问题，block 使用自身强引用成员变量时，需要声明 weak；</li>
    </ul>
  </li>
  <li>Timer 的使用，结束时需要置空，主动断环</li>
</ul>

<h4 id="五-六大设计原则与五大设计模式">五. 六大设计原则与五大设计模式</h4>
<ul>
  <li>单一原则：一个类只负责一件事情，如 UIView 负责事件和响应链，CALayer 负责渲染和显示；</li>
  <li>开闭原则：对修改关闭，对扩展开放。定义类时要慎重定义成员变量，可以稳定的类在扩展中定义方法；</li>
  <li>接口隔离原则：定义专用协议，而不是大而臃肿的协议。如：UITableDelegate和datasource</li>
  <li>依赖倒置原则：抽象不应该依赖实际，实际依赖抽象。如：数据库访问方法，将连接过程放入具体实现中，
实现依赖倒置；</li>
  <li>迪米特法则：一个对象应该对其他对象尽可能少的知道，做到高内聚、低耦合；</li>
  <li>
    <p>里式替换原则：子类可以无缝替换父类，实现所有功能。如：KVO 的实现。</p>
  </li>
  <li>责任链模式：对于营销界面，自定义控制器的跳转。</li>
  <li>适配器模式：对于历史类，为了不影响功能实现，可以新建适配器，执行原类的方法后，执行添加的方法。</li>
  <li>桥接模式：网络访问框架，定义时，同一个接口返回不同类型的结果，LLVM 三相设计</li>
  <li>单例模式：对于常用的对象，生成单例，减少内存分配的资源浪费。如：登录、下载器</li>
  <li>命令模式：将一些功能命令化，减少出错，提高可读性，如网络中的 start、cancel 等。</li>
</ul>

<h4 id="五-分类和扩展">五. 分类和扩展</h4>
<ul>
  <li>分类是运行时决议，扩展是编译时决议；</li>
  <li>扩展可以添加私有属性和成员变量，分类只能通过关联对象的方法添加属性；</li>
  <li>分类有声明和实现，扩展只有声明，实现在宿主类中；</li>
  <li>可以为系统类添加分类，不能添加扩展。</li>
</ul>

<h4 id="六-kvo-和-kvc">六. KVO 和 KVC</h4>
<ul>
  <li>KVO 是通过 isa 混写实现的，在给对象添加观察者时，会生成新对象；</li>
  <li>KVC 可以通过 key 对私有变量操作，破坏面向对象。</li>
</ul>

<h4 id="七-代理和通知">七. 代理和通知</h4>
<ul>
  <li>代理通过代理模式实现，一对一；</li>
  <li>通知通过观察者模式实现，一对多，可跨层传递。</li>
</ul>

<h4 id="八-runloop">八. Runloop</h4>
<p><a href="https://www.jianshu.com/p/ffebf2839d66">runloop 的 mode 作用</a></p>

<p><a href="https://www.jianshu.com/p/66229ed12216">runloop 内部实现</a></p>

<h4 id="八-补充">八. 补充</h4>
<ul>
  <li>元类是类的类，类也是对象。</li>
</ul>
:ET