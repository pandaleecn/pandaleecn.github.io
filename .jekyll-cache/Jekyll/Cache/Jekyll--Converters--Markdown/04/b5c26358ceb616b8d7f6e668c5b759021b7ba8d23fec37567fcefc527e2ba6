I"Â<h4 id="1-ç»™åˆ†ç±»æ·»åŠ æˆå‘˜å˜é‡">1. ç»™åˆ†ç±»æ·»åŠ â€æˆå‘˜å˜é‡â€</h4>
<p>ä¸èƒ½ç›´æ¥æ·»åŠ æˆå‘˜å˜é‡ï¼Œå¯ä»¥ç”¨å…³è”å¯¹è±¡çš„æ–¹æ³•ä¸ºåˆ†ç±»æ·»åŠ ã€‚</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id objc_getAssociatedObject(id object, const void *key)

// policyï¼šå…³è”æ–¹æ³•ï¼Œcopyã€retain
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)

void objc_removeAssociatedObject(id object)
</code></pre></div></div>
<h4 id="2-å…³è”å¯¹è±¡çš„æœ¬è´¨">2. å…³è”å¯¹è±¡çš„æœ¬è´¨</h4>
<p>å…³è”å¯¹è±¡AssociationsManagerç®¡ç†å¹¶åœ¨AssociationsHashMapå­˜å‚¨ã€‚
æ‰€æœ‰å¯¹è±¡çš„å…³è”å†…å®¹éƒ½åœ¨åŒä¸€ä¸ªå…¨å±€å®¹å™¨ä¸­ã€‚
<img src="http://files.pandaleo.cn/9a045680410b36c326676dde6eabf266.png" alt="" /></p>
<h4 id="3-å…³è”å¯¹è±¡åœ¨å®¹å™¨ä¸­å­˜å‚¨çš„æ ¼å¼">3. å…³è”å¯¹è±¡åœ¨å®¹å™¨ä¸­å­˜å‚¨çš„æ ¼å¼</h4>
<p><img src="http://files.pandaleo.cn/fb749d17225915940282123e7909cf57.png" alt="" />
æ³¨ï¼šsetObjectæ—¶valueä¼ æˆnilï¼Œå°±å¯ä»¥æŠŠå¯¹åº”keyçš„å€¼æ“¦é™¤æ‰</p>
<h4 id="4-æºç åˆ†æ">4. æºç åˆ†æ</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        // å…³è”å¯¹è±¡ç®¡ç†ç±»ï¼ŒC++å®ç°çš„ä¸€ä¸ªç±»
        AssociationsManager manager;
        // è·å–å…¶ç»´æŠ¤çš„ä¸€ä¸ªHashmapï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå­—å…¸ï¼Œå…¨å±€å®¹å™¨
        AssociationsHashMap &amp;associations(manager.associations());
        // æ ¹æ®å¯¹è±¡æŒ‡é’ˆæŸ¥æ‰¾å¯¹åº”çš„ä¸€ä¸ªObjectAssociationMapç»“æ„çš„map
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end()) {
                // secondary table exists
                ObjectAssociationMap *refs = i-&gt;second;
                ObjectAssociationMap::iterator j = refs-&gt;find(key);
                if (j != refs-&gt;end()) {
                    old_association = j-&gt;second;
                    j-&gt;second = ObjcAssociation(policy, new_value);
                } else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                object-&gt;setHasAssociatedObjects();
            }
        } else { //
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i-&gt;second;
                ObjectAssociationMap::iterator j = refs-&gt;find(key);
                if (j != refs-&gt;end()) {
                    old_association = j-&gt;second;
                    refs-&gt;erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre></div></div>
:ET