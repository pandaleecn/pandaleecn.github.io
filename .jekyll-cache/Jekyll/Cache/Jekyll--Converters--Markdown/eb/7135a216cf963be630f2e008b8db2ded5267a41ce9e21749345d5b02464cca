I"E<h4 id="1-读写权限">1. 读写权限</h4>
<ul>
  <li>readonly</li>
  <li>readwrite</li>
</ul>

<h4 id="2-原子性">2. 原子性</h4>
<ul>
  <li>atomic，赋值和获取线程安全。修饰数组时，赋值和获取线程安全，对数组添加和移除对象时，无法保证线程安全。</li>
  <li>nonatomic</li>
</ul>

<h4 id="3-引用计数">3. 引用计数</h4>
<ul>
  <li>retain/strong</li>
  <li>assign/unsafe_unretained</li>
</ul>

<h4 id="4-assign">4. assign</h4>
<ul>
  <li>修饰基本数据类型，如int，BOOL等。</li>
  <li>修饰对象类型时，不改变其引用计数。</li>
  <li>会产生悬垂指针。</li>
</ul>

<h4 id="5-weak">5. weak</h4>
<ul>
  <li>不改变被修饰对象的引用计数。</li>
  <li>所指对象被释放之后会自动置位nil。</li>
</ul>

<h4 id="6-weak和assign的区别和联系">6. weak和assign的区别和联系</h4>
<ul>
  <li>weak修饰对象，assign可以修饰对象和基本数据类型；</li>
  <li>assign被释放后，指针仍指向原地址，weak释放后自动置位nil。</li>
  <li>weak和assign都不会改变引用计数。</li>
</ul>

<h4 id="7-copy">7. copy</h4>
<ul>
  <li>浅拷贝，对内存地址的复制，让目标对象指针和源对象指向同一片内存空间。并没有对内存空间复制，没有增加内存分配，增加引用计数。
<img src="http://files.pandaleo.cn/515c07ae0b15bad2fa4b7eca9d488a1b.png" alt="" /></li>
  <li>深拷贝，让目标对象指针和源对象指针指向两片内容相同的内存空间。不会增加被拷贝对象的内存空间，增加了内存分配。<br />
<img src="http://files.pandaleo.cn/e519ae602cc250af9e7e37e1d3b74cac.png" alt="" /></li>
  <li>深拷贝VS浅拷贝
    <ul>
      <li>是否开辟了新的内存空间</li>
      <li>是否影响了引用计数</li>
    </ul>
  </li>
  <li>copy关键字
<img src="http://files.pandaleo.cn/b2abb9dd41398330719c7acce5f07f64.png" alt="" />
    <ul>
      <li>可变对象的copy和mutableCopy都是深拷贝。</li>
      <li>不可变对象的copy是浅拷贝，mutableCopy是深拷贝。</li>
      <li>copy方法返回的都是不可变对象。</li>
    </ul>
  </li>
  <li>@property(copy) NSMutableArray* array？
    <ul>
      <li>如果赋值过来的时NSMutableArray，copy之后是NSArray。</li>
      <li>如果赋值过来的时NSArray，copy之后是NSArray。</li>
      <li>如果数据类型不同，会导致crash。</li>
    </ul>
  </li>
</ul>

<h4 id="8-mrc下重写retain修改变量的setter方法">8. MRC下重写retain修改变量的setter方法</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property(nonatomic, retain) id obj;
- （void)setObj:(id)obj
{
  if (_obj != obj) {
    [_ob release];
    _obj = [obj retain];
  }
}
</code></pre></div></div>
<p>历史遗留问题，很多大公司的App。</p>
:ET