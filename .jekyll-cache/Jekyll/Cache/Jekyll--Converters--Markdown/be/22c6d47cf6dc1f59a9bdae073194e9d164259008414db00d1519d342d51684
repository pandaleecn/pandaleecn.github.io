I"7§<h3 id="ä¸€åºåˆ—">ä¸€ã€åºåˆ—</h3>
<h4 id="1-å®šä¹‰">1. å®šä¹‰</h4>
<ul>
  <li>Sequence åè®®æ˜¯é›†åˆç±»å‹ç»“æ„ä¸­çš„åŸºç¡€ï¼Œä»£è¡¨çš„æ˜¯ä¸€ç³»åˆ—å…·æœ‰ç›¸åŒç±»å‹çš„å€¼ï¼Œä½ å¯ä»¥å¯¹è¿™äº›å€¼è¿›è¡Œè¿­ä»£ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ç®€å•forå¾ªç¯
for element in someSequence {
  doSomething(with: element)
}

// æ»¡è¶³Sequenceåè®®çš„è¦æ±‚æ˜¯æä¾›ä¸€ä¸ªè¿”å›è¿­ä»£å™¨çš„makeIterator()æ–¹æ³•ã€‚
protocol Sequence {
  associatedtype Iterator: IteratorProtocol
  func makeIterator() -&gt; Iterator
  // ...
}
</code></pre></div></div>

<h4 id="2-è¿­ä»£å™¨">2. è¿­ä»£å™¨</h4>
<p>åºåˆ—é€šè¿‡åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨æ¥æä¾›å¯¹å…ƒç´ çš„è®¿é—®ã€‚è¿­ä»£å™¨æ¯æ¬¡äº§ç”Ÿä¸€ä¸ªåºåˆ—çš„å€¼ï¼Œå¹¶ä¸”å½“éå†åºåˆ—æ—¶å¯¹éå†çŠ¶æ€è¿›è¡Œç®¡ç†ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol IteratorProtocol {

  // è¿­ä»£å™¨äº§ç”Ÿçš„æŒ‡çš„ç±»å‹
  associatedtype Element

  // åè®®ä¸­å”¯ä¸€çš„æ–¹æ³•ï¼Œæ¯æ¬¡è¢«è°ƒç”¨æ—¶è¿”å›åºåˆ—ä¸­ä¸‹ä¸€ä¸ªå€¼ï¼Œè€—å°½æ—¶è¿”å›nil
  mutating func next() -&gt; Element?
}

// è¿­ä»£å™¨å®šä¹‰äº†å¯¹åº”åºåˆ—çš„å…ƒç´ ç±»å‹
public protocol Sequence {
  associatedtype Element
  associatedtype Iterator: IteratorProtocol
  where Iterator.Element == Element
  // ...
}

// forå¾ªç¯æ˜¯è¿­ä»£å™¨çš„ç®€å†™æ–¹å¼
// ç¼–è¯‘å™¨ä¼šä¸ºåºåˆ—åˆ›å»ºä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå¹¶ä¸”ä¸æ–­è°ƒç”¨è¿­ä»£å™¨çš„ next æ–¹æ³•ï¼Œç›´åˆ°å®ƒè¿”å› nil ä¸ºæ­¢ã€‚
var iterator = someSequence.makeIterator() while let element = iterator.next() {
    doSomething(with: element)
}

// æ— é™çš„è¿­ä»£å™¨
struct ConstantIterator: IteratorProtocol {

  // typealias æŒ‡å®š Element çš„ç±»å‹ï¼Œä¸ºæ–‡æ¡£çš„ç›®çš„å¸®åŠ©ç†è§£ä»£ç ï¼Œåè®®è¶Šå¤§è¶Šæ˜æ˜¾
  typealias Element = Int

  // next() è¢«æ ‡è®°ä¸ºäº† mutatingï¼Œè¿­ä»£å™¨çš„æœ¬è´¨æ˜¯å­˜åœ¨çŠ¶æ€çš„ã€‚å‡ ä¹æ‰€æœ‰æœ‰æ„ä¹‰çš„è¿­ä»£å™¨éƒ½ä¼šè¦æ±‚å¯å˜çŠ¶æ€ï¼Œè¿™æ ·å®ƒä»¬æ‰èƒ½å¤Ÿç®¡ç†åœ¨åºåˆ—ä¸­çš„å½“å‰ä½ç½®ã€‚
  mutating func next() -&gt; Int? {
    return 1
  }

}

// æ— ç©·æ‰“å°æ•°å­—1
var iterator = ConstantIterator()
while let x = iterator.next() {
  print(x)
}

// FibsIteratoræ— ç©·è¿­ä»£å™¨
struct FibsIterator: IteratorProtocol {
  var state = (0, 1)
  mutating func next() -&gt; Int? {
    let upcomingNumber = state.0
    state = (state.1, state.0 + state.1)
    return upcomingNumber
  }
}

</code></pre></div></div>
<ul>
  <li>éµå®ˆåºåˆ—åè®®</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é¡ºæ¬¡ç”Ÿæˆå­—ç¬¦ä¸²çš„æ‰€æœ‰å‰ç¼€ï¼ˆåŒ…å«æœ¬èº«ï¼‰
struct PrefixIterator: IteratorProtocol {
  let string: String
  var offset: String.Index
  init(string: String) {
      self.string = string
      offset = string.startIndex
  }

  mutating func next() -&gt; Substring? {
    guard offset &lt; string.endIndex else { return nil }
    offset = string.index(after: offset)
    return string[..&lt;offset]
  }
}

struct PrefixSequence: Sequence {
  let string: String

  // ç¼–è¯‘å™¨ä»è¿”å›ç±»å‹æ¨æ–­å‡ºç®¡ç†æŒ‰ç±»å‹Iteratoræˆ–Elementçš„å…·ä½“ç±»å‹
  func makeIterator() -&gt; PrefixIterator {
    return PrefixIterator(string: string)
  }
}

// forå¾ªç¯è°ƒç”¨
for prefix in PrefixSequence(string: "Hello") {
  print(prefix)
}

/*
H
He
Hel
Hell
Hello
*/

// è¿˜å¯ä»¥æ‰§è¡ŒSequenceæä¾›çš„æ‰€æœ‰æ“ä½œ
PrefixSequence(string: "Hello").map { $0.uppercased() }
// ["H", "HE", "HEL", "HELL", "HELLO"]
</code></pre></div></div>

<ul>
  <li>è¿­ä»£å™¨å’Œå€¼è¯­ä¹‰
    <ul>
      <li>StrideToIterator æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„ç»“æ„ä½“ï¼Œå…·æœ‰å€¼è¯­ä¹‰ã€‚</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä¸€ä¸ªä» 0 åˆ° 9 çš„åºåˆ—
let seq = stride(from: 0, to: 10, by: 1)
var i1 = seq.makeIterator()
i1.next() // Optional(0)
i1.next() // Optional(1)

var i2 = i1

i1.next() // Optional(2)
i1.next() // Optional(3)
i2.next() // Optional(2)
i2.next() // Optional(3)
</code></pre></div></div>
<ul>
  <li>AnyIterator æ˜¯ä¸€ä¸ªå¯¹åˆ«çš„è¿­ä»£å™¨è¿›è¡Œå°è£…çš„è¿­ä»£å™¨ï¼Œå®ƒå¯ä»¥ç”¨æ¥å°†åŸæ¥çš„è¿­ä»£å™¨çš„å…·ä½“ç±»å‹â€œæŠ¹æ¶ˆâ€æ‰ã€‚<br />
  æ¯”å¦‚ä½ åœ¨åˆ›å»ºå…¬æœ‰ API æ—¶æƒ³è¦å°†ä¸€ä¸ªå¾ˆå¤æ‚çš„è¿­ä»£å™¨çš„å…·ä½“ç±»å‹éšè—èµ·æ¥ï¼Œè€Œä¸æš´éœ²å®ƒçš„å…·ä½“å®ç°çš„æ—¶å€™ï¼Œå°±å¯ä»¥ä½¿ç”¨è¿™ç§è¿­ä»£å™¨ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å¾ˆå°‘ç”¨åˆ°ï¼Œéœ€è¦å…±äº«æ—¶ï¼Œå¯ä»¥ç›´æ¥å°è£…åˆ°åºåˆ—ä¹‹ä¸­ï¼Œè€Œä¸æ˜¯ä¼ é€’
var i3 = AnyIterator(i1)
var i4 = i3
i3.next() // Optional(4)
i4.next() // Optional(5)
i3.next() // Optional(6)
i3.next() // Optional(7)

</code></pre></div></div>
<ul>
  <li>åŸºäºå‡½æ•°çš„è¿­ä»£å™¨å’Œåºåˆ—</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä¸å…·æœ‰å€¼è¯­ä¹‰
func fibsIterator() -&gt; AnyIterator&lt;Int&gt; {
  var state = (0, 1)
  return AnyIterator {
    let upcomingNumber = state.0
    state = (state.1, state.0 + state.1)
    return upcomingNumber
  }
}

let fibsSequence = AnySequence(fibsIterator)
Array(fibsSequence.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// sequence(first:next:) å°†ä½¿ç”¨ç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼ä½œä¸ºåºåˆ—çš„é¦–ä¸ªå…ƒç´ ï¼Œå¹¶ä½¿ç”¨ next å‚æ•°ä¼ å…¥çš„é—­åŒ…ç”Ÿæˆåºåˆ—çš„åç»­å…ƒç´ ï¼Œæœ€åè¿”å›ç”Ÿæˆçš„åºåˆ—ã€‚
// sequence(state:next:)ï¼Œå¯ä»¥åœ¨ä¸¤æ¬¡ next é—­åŒ…è¢«è°ƒç”¨ä¹‹é—´ä¿å­˜ä»»æ„çš„å¯å˜çŠ¶æ€ï¼Œæ‰€ä»¥å®ƒæ›´å¼ºå¤§ä¸€äº›ã€‚
let fibsSequence2 = sequence(state: (0, 1)) {
  // åœ¨è¿™é‡Œç¼–è¯‘å™¨éœ€è¦ä¸€äº›ç±»å‹æ¨æ–­çš„ååŠ©
  (state: inout (Int, Int)) -&gt; Int? in
  let upcomingNumber = state.0
  state = (state.1, state.0 + state.1)
  return upcomingNumber
}

Array(fibsSequence2.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

let fb3 = sequence(first: (0, 1), next: {
    ($0.1, $0.0 + $0.1)
})
print(Array(fb3.prefix(10)))
// [(0, 1), (1, 1), (1, 2), (2, 3), (3, 5), (5, 8), (8, 13), (13, 21), (21, 34), (34, 55)]

</code></pre></div></div>
<h4 id="3-æ— é™åºåˆ—">3. æ— é™åºåˆ—</h4>
<ul>
  <li>sequence å¯¹äº next é—­åŒ…çš„ä½¿ç”¨æ˜¯è¢«å»¶è¿Ÿçš„ï¼Œä¸‹ä¸€ä¸ªå€¼ä¸ä¼šè¢«é¢„å…ˆè®¡ç®—ï¼Œå®ƒåªåœ¨è°ƒç”¨è€…éœ€è¦çš„æ—¶å€™ç”Ÿæˆã€‚</li>
  <li>åºåˆ—å¯ä»¥æ˜¯æ— é™çš„ï¼Œè€Œé›†åˆåˆ™ä¸è¡Œã€‚</li>
</ul>

<h4 id="4-ä¸ç¨³å®šåºåˆ—">4. ä¸ç¨³å®šåºåˆ—</h4>
<ul>
  <li>åºåˆ—å¹¶ä¸åªé™äºåƒæ˜¯æ•°ç»„æˆ–è€…åˆ—è¡¨è¿™æ ·çš„ä¼ ç»Ÿé›†åˆæ•°æ®ç±»å‹ï¼Œå¦‚ï¼šç½‘ç»œæµï¼Œç£ç›˜ä¸Šçš„æ–‡ä»¶ï¼ŒUI äº‹ä»¶çš„æµã€‚æ•°ç»„ï¼Œå¯ä»¥å¤šæ¬¡éå†å…¶ä¸­çš„å…ƒç´ ï¼Œè€Œä¸Šé¢è¿™äº›ä¾‹å­æœ‰æ—¶ä¸è¡Œã€‚</li>
  <li>åºåˆ—å¹¶ä¸ä¿è¯å¯ä»¥è¢«å¤šæ¬¡éå†ã€‚æ–æ³¢çº³å¥‘åºåˆ—å…ƒç´ å›ºå®šï¼Œå¯ä»¥ä» 0 å†æ¬¡éå†ï¼Œä½†æ˜¯åƒæ˜¯ç½‘ç»œåŒ…çš„æµè¿™æ ·çš„åºåˆ—å°†ä¼šéšç€éå†è¢«æ¶ˆè€—ï¼Œæ— æ³•å†æ¬¡éå†äº§ç”ŸåŒæ ·çš„å€¼ã€‚</li>
  <li>åºåˆ—ä¸å­˜åœ¨firstå±æ€§ï¼Œæ— æ³•ä¿è¯getteræ–¹æ³•æ˜¯éç ´åçš„ï¼Œé›†åˆç±»å‹åœ¨Collectionåè®®ä¿è¯ä¸‹æœ‰firstå±æ€§ã€‚</li>
  <li>ä¸€äº›éé›†åˆçš„åºåˆ—æ˜¯å¯ä»¥è¢«å¤šæ¬¡éå†çš„ï¼Œå¦‚ï¼š stride(from:to:by:) è¿”å›çš„ StrideTo ç±»å‹ï¼Œä»¥åŠ stride(from:through:by:) æ‰€è¿”å›çš„ StrideThrough ç±»å‹ï¼Œä½¿ç”¨æµ®ç‚¹æ•°æ­¥é•¿æ¥è·å–å€¼ï¼Œè¿™ä½¿å¾—å®ƒä»¬æ— æ³•è¢«æè¿°ä¸ºä¸€ä¸ªé›†åˆï¼Œæ‰€ä»¥å®ƒä»¬åªèƒ½ä½œä¸ºåºåˆ—å­˜åœ¨ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let standardIn = AnySequence {
  return AnyIterator {
  readLine()
  }
}

// è¾“å…¥å›è½¦æ—¶ï¼Œå»¶è¿Ÿä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–ä¸€è¡Œï¼Œæ— æ³•ä¿è¯ç¨³å®šæ€§
let numberedStdIn = standardIn.enumerated()
  for (i, line) in numberedStdIn {
  print("\(i+1): \(line)")
}

</code></pre></div></div>
<h4 id="5-åºåˆ—å’Œè¿­ä»£å™¨ä¹‹é—´çš„å…³ç³»">5. åºåˆ—å’Œè¿­ä»£å™¨ä¹‹é—´çš„å…³ç³»</h4>
<ul>
  <li>è¿­ä»£å™¨æä¾›éå†çŠ¶æ€ï¼Œåºåˆ—æä¾›éå†é€»è¾‘ï¼ŒmakeIterator æ–¹æ³•çš„ç›®çš„å°±æ˜¯åˆ›å»ºéå†çŠ¶æ€ã€‚</li>
  <li>è¿­ä»£å™¨å¯ä»¥çœ‹ä½œå³å°†è¿”å›å…ƒç´ æ‰€ç»„æˆçš„ä¸ç¨³å®šåºåˆ—ï¼Œå¯é€šè¿‡æ»¡è¶³Sequenceè½¬æ¢æˆåºåˆ—ã€‚</li>
</ul>

<h4 id="6-å­åºåˆ—">6. å­åºåˆ—</h4>
<p>Sequenceçš„å¦ä¸€ä¸ªå…³è”ç±»å‹ï¼ŒSubSequence</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Sequence {
  associatedtype Element
  associatedtype Iterator: IteratorProtocol
  where Iterator.Element == Element
  associatedtype SubSequence
  // ...
}
</code></pre></div></div>
<ul>
  <li>åœ¨è¿”å›åŸåºåˆ—çš„åˆ‡ç‰‡æ“ä½œä¸­ï¼ŒSubSequenceè¢«ç”¨ä½œè¿”å›å€¼çš„å­ç±»å‹æ“ä½œ
    <ul>
      <li>prefix å’Œ suffix â€” è·å–å¼€å¤´æˆ–ç»“å°¾ n ä¸ªå…ƒç´ </li>
      <li>prefix(while:) - ä»å¼€å¤´å¼€å§‹å½“æ»¡è¶³æ¡ä»¶æ—¶ï¼Œ</li>
      <li>dropFirst å’Œ dropLast â€” è¿”å›ç§»é™¤æ‰å‰ n ä¸ªæˆ–å n ä¸ªå…ƒç´ çš„å­åºåˆ—</li>
      <li>drop(while:) - ç§»é™¤å…ƒç´ ï¼Œç›´åˆ°æ¡ä»¶ä¸å†ä¸ºçœŸï¼Œç„¶åè¿”å›å‰©ä½™å…ƒç´ </li>
      <li>split â€” å°†ä¸€ä¸ªåºåˆ—åœ¨æŒ‡å®šçš„åˆ†éš”å…ƒç´ æ—¶æˆªæ–­ï¼Œè¿”å›å­åºåˆ—çš„çš„æ•°ç»„</li>
    </ul>
  </li>
  <li>ä¸ç¡®å®šSubsequenceæ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®AnySequence<Iterator.Element>æ¨æ–­ç±»å‹ï¼Œå¹¶æä¾›é»˜è®¤å®ç°ã€‚è‡ªå®šä¹‰å­åºåˆ—æ—¶ï¼Œéœ€è¦æä¾›ä¸Šè¿°æ–¹æ³•çš„è‡ªå®šä¹‰å®ç°ã€‚</Iterator.Element></li>
  <li>å­åºåˆ—å’ŒåŸåºåˆ—ç±»å‹ä¸€è‡´å¯ä»¥æ–¹ä¾¿å›ä¼ å‚æ•°åœ¨åŸå§‹é›†åˆç±»å‹çš„å‡½æ•°ä¸­ä½¿ç”¨ï¼Œä½†åœ¨æ ‡å‡†åº“ä¸­é›†åˆç±»å‹çš„åˆ‡ç‰‡ç±»å‹å¹¶ä¸ä¸€æ ·ï¼Œä¸ºäº†é˜²æ­¢éå¸¸å°çš„åˆ‡ç‰‡æŒæœ‰è¾ƒå¤§çš„åŸæœ‰é›†åˆç±»å‹ï¼Œå¯¼è‡´å†…å­˜â€œæ³„éœ²â€ã€‚ä½¿ç”¨åŸå§‹ç±»å‹è¡¨ç¤ºåˆ‡ç‰‡ï¼Œå¯ä»¥å°†å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ›´å¥½çš„ç»‘å®šåœ¨å±€éƒ¨ä½œç”¨åŸŸä¸­ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ¯”è¾ƒç†æƒ³çš„SubSequenceå…³è”ç±»å‹çš„å£°æ˜
// a. æœ¬èº«ä¹Ÿæ˜¯åºåˆ—ã€‚
// b. å­åºåˆ—çš„å…ƒç´ ç±»å‹å’Œå…¶å­åºåˆ—ç±»å‹ï¼Œå’ŒåŸåºåˆ—çš„å¯¹åº”ç±»å‹ä¸€è‡´ã€‚
// båœ¨Swift4.0ä¸­æ— æ³•åšåˆ°ï¼Œç¼–è¯‘å™¨æ²¡æœ‰å¾ªç¯åè®®çº¦æŸï¼ˆSequenceä¼šå¯¹è‡ªèº«è¿›è¡Œå¼•ç”¨ï¼‰ã€‚
associatedtype SubSequence: Sequence
  where Element == SubSequence.Element,
    SubSequence.SubSequence == SubSequence

// æ¯”è¾ƒåºåˆ—å‰ånä¸ªå…ƒç´ æ˜¯å¦ä¸ºé•œåƒ
extension Sequence where Element: Equatable, SubSequence: Sequence, SubSequence.Element == Element
{
  func headMirrorsTail(_ n: Int) -&gt; Bool {
    let head = prefix(n)
    let tail = suffix(n).reversed()
    return head.elementsEqual(tail)
  }
}
[1,2,3,4,2,1].headMirrorsTail(2) // true

</code></pre></div></div>

<ul>
  <li>é“¾è¡¨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// ä¸€ä¸ªç®€å•çš„é“¾è¡¨æšä¸¾
enum List&lt;Element&gt; {
  case end
  /// indirectå£°æ˜nodeä¸ºå¼•ç”¨ï¼Œæšä¸¾æ˜¯å€¼ç±»å‹ï¼Œæ— æ³•å¼•ç”¨è‡ªèº«ï¼Œå¦åˆ™æ— æ³•è®¡ç®—å°ºå¯¸
  indirect case node(Element, next: List&lt;Element&gt;)
}

let emptyList = List&lt;Int&gt;.end
let oneElementList = List.node(1, next: emptyList)
// node(1, next: List&lt;Swift.Int&gt;.end)

extension List {
  /// åœ¨é“¾è¡¨å‰æ–¹æ·»åŠ ä¸€ä¸ªå€¼ä¸º `x` çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›è¿™ä¸ªé“¾è¡¨
  func cons(_ x: Element) -&gt; List {
    return .node(x, next: self)
  }
}
// ä¸€ä¸ªæ‹¥æœ‰ 3 ä¸ªå…ƒç´ çš„é“¾è¡¨ (3 2 1)
let list = List&lt;Int&gt;.end.cons(1).cons(2).cons(3)
/*
node(3, next: List&lt;Swift.Int&gt;.node(2, next: List&lt;Swift.Int&gt;.node(1,
next: List&lt;Swift.Int&gt;.end)))
*/

extension List: ExpressibleByArrayLiteral {
  init(arrayLiteral elements: Element...) {
    self = elements.reversed().reduce(.end) { partialList, element in
      partialList.cons(element)
    }
  }
}
let list2: List = [3,2,1]
/*
node(3, next: List&lt;Swift.Int&gt;.node(2, next: List&lt;Swift.Int&gt;.node(1,
next: List&lt;Swift.Int&gt;.end)))
*/
</code></pre></div></div>
<p><img src="http://files.pandaleo.cn/2edbe499744a692d5b3e6516161c2e06.png?imageMogr2/thumbnail/!50p" alt="é“¾è¡¨å…±äº«" />
é“¾è¡¨å…±äº«</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension List {
  mutating func push(_ x: Element) {
    self = self.cons(x)
  }
  mutating func pop() -&gt; Element? {
    switch self {
      case .end: return nil
      case let .node(x, next: tail):
      self = tail
      return x
    }
  }
}

// é“¾è¡¨å…·æœ‰æŒä¹…æ€§å’Œä¸å¯å˜æ€§ï¼Œå˜é‡å€¼æ”¹å˜äº†åˆ—è¡¨æ‰€æŒæœ‰çš„èŠ‚ç‚¹
var stack: List&lt;Int&gt; = [3,2,1]
var a = stack
var b = stack
a.pop() // Optional(3)
a.pop() // Optional(2)
a.pop() // Optional(1)
stack.pop() // Optional(3)
stack.push(4)
b.pop() // Optional(3)
b.pop() // Optional(2)
b.pop() // Optional(1)
stack.pop() // Optional(4)
stack.pop() // Optional(2)
stack.pop() // Optional(1)
</code></pre></div></div>
<p><img src="http://files.pandaleo.cn/f4ab9819e5637c92736292950a458d99.png?imageMogr2/thumbnail/!50p" alt="" />
é“¾è¡¨è¿­ä»£å™¨
<img src="http://files.pandaleo.cn/4ae369d32c520e99230558da4ff0c0a2.png?imageMogr2/thumbnail/!50p" alt="" />
é“¾è¡¨çš„å†…å­˜ç®¡ç†</p>

<ul>
  <li>è®©Listéµå®ˆSequence</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension List: IteratorProtocol, Sequence {
  mutating func next() -&gt; Element? {
    return pop()
  }
}

let list: List = ["1", "2", "3"]
for x in list {
  print("\(x) ", terminator: "")
} // 1 2 3

list.joined(separator: ",") // 1,2,3
list.contains("2") // true
list.flatMap { Int($0) } // [1, 2, 3]
list.elementsEqual(["1", "2", "3"]) // true
</code></pre></div></div>
<h3 id="äºŒé›†åˆç±»å‹">äºŒã€é›†åˆç±»å‹</h3>
<ul>
  <li>é›†åˆç±»å‹ (Collection) æŒ‡çš„æ˜¯é‚£äº›ç¨³å®šçš„åºåˆ—ï¼Œå®ƒä»¬èƒ½å¤Ÿè¢«å¤šæ¬¡éå†ä¸”ä¿æŒä¸€è‡´ã€‚å…ƒç´ å¯ä»¥é€šè¿‡å…ˆè¡Œéå†å’Œä¸‹æ ‡ç´¢å¼•çš„æ–¹å¼è¢«è·å–åˆ°ã€‚å’Œåºåˆ—ä¸åŒï¼Œé›†åˆç±»å‹ä¸èƒ½æ˜¯æ— é™çš„ã€‚</li>
  <li>Collection åè®®æ˜¯å»ºç«‹åœ¨ Sequence åè®®ä¸Šçš„ã€‚é™¤äº†ä» Sequence ç»§æ‰¿äº†å…¨éƒ¨æ–¹æ³•ä»¥å¤–ï¼Œè¿˜è·å–äº†ä¸€äº›æ–°çš„èƒ½åŠ›ã€‚æ¯”å¦‚ count å±æ€§ã€‚</li>
  <li>é›†åˆç±»å‹åœ¨æ ‡å‡†åº“ä¸­è¿ç”¨å¹¿æ³›ï¼š Arrayï¼ŒDictionaryï¼ŒSetï¼ŒString ï¼ŒCountableRangeï¼Œ UnsafeBufferPointerï¼ŒData ï¼ŒIndexSetã€‚</li>
</ul>

<h4 id="1-è‡ªå®šä¹‰çš„é›†åˆç±»å‹">1. è‡ªå®šä¹‰çš„é›†åˆç±»å‹</h4>
<ul>
  <li>ä¸ºé˜Ÿåˆ—è®¾è®¡åè®®
    <ul>
      <li>æ³¨é‡Šéå¸¸é‡è¦ï¼Œå®ƒå’Œå®é™…çš„æ–¹æ³•ååŠç±»å‹åä¸€æ ·ï¼Œä¹Ÿæ˜¯åè®®çš„ä¸€éƒ¨åˆ†ï¼Œè¿™äº›æ³¨é‡Šç”¨æ¥ä¿è¯åè®®åº”æœ‰çš„è¡Œä¸ºã€‚</li>
      <li>æ²¡æœ‰ç»™å‡ºè¶…è¿‡æˆ‘ä»¬ç°åœ¨æ‰€åšçš„èŒƒå›´çš„æ‰¿è¯ºï¼Œå¦‚å¤æ‚åº¦ã€peekæ“ä½œã€çº¿ç¨‹å®‰å…¨ã€å…ˆè¿›å…ˆå‡ºã€‚</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// ä¸€ä¸ªèƒ½å¤Ÿå°†å…ƒç´ å…¥é˜Ÿå’Œå‡ºé˜Ÿçš„ç±»å‹
protocol Queue {
  /// åœ¨ `self` ä¸­æ‰€æŒæœ‰çš„å…ƒç´ çš„ç±»å‹
  associatedtype Element
  /// å°† `newElement` å…¥é˜Ÿåˆ° `self`
  mutating func enqueue(_ newElement: Element)
  /// ä» `self` å‡ºé˜Ÿä¸€ä¸ªå…ƒç´ 
  mutating func dequeue() -&gt; Element?
}
</code></pre></div></div>

<ul>
  <li>é˜Ÿåˆ—çš„å®ç°</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// ä¸€ä¸ªé«˜æ•ˆçš„ FIFO é˜Ÿåˆ—ï¼Œå…¶ä¸­å…ƒç´ ç±»å‹ä¸º `Element`
struct FIFOQueue&lt;Element&gt;: Queue {
  private var left: [Element] = []
  private var right: [Element] = []
  /// å°†å…ƒç´ æ·»åŠ åˆ°é˜Ÿåˆ—æœ€å
  /// - å¤æ‚åº¦: O(1)
  mutating func enqueue(_ newElement: Element) {
    right.append(newElement)
  }
  /// ä»é˜Ÿåˆ—å‰ç«¯ç§»é™¤ä¸€ä¸ªå…ƒç´ 
  /// å½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œè¿”å› nil
  /// - å¤æ‚åº¦: å¹³æ‘Š O(1)
  mutating func dequeue() -&gt; Element? {
    if left.isEmpty {
      left = right.reversed()
      right.removeAll()
    }
    return left.popLast()
  }
}
</code></pre></div></div>

<h3 id="ä¸‰éµå®ˆcollectionåè®®">ä¸‰ã€éµå®ˆCollectionåè®®</h3>
<h4 id="1-æ–‡æ¡£ä¸­å…³äºåè®®çš„æœ€å°éœ€æ±‚">1. æ–‡æ¡£ä¸­å…³äºåè®®çš„æœ€å°éœ€æ±‚</h4>
<p>é™¤äº†Indexå’ŒElementä»¥å¤–ï¼Œå…¶ä»–çš„å…³è”ç±»å‹éƒ½æœ‰é»˜è®¤å€¼ï¼Œå¤§éƒ¨åˆ†æ–¹æ³•ã€å±æ€§å’Œä¸‹æ ‡Collectionçš„åè®®æ‰©å±•ä¹Ÿéƒ½æä¾›äº†é»˜è®¤å®ç°ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Collection åè®®æœ‰å…­ä¸ªå…³è”ç±»å‹ï¼Œå››ä¸ªå±æ€§ï¼Œä¸ƒä¸ªå®ä¾‹æ–¹æ³•
protocol Collection: Sequence {
  associatedtype Element // inherited from Sequence
  associatedtype Index: Comparable
  associatedtype IndexDistance: SignedInteger = Int
  associatedtype Iterator: IteratorProtocol = IndexingIterator&lt;Self&gt;
  where Iterator.Element == Element
  associatedtype SubSequence: Sequence
  /* ... */
  associatedtype Indices: Sequence = DefaultIndices&lt;Self&gt;
  /* ... */
  var first: Element? { get }
  var indices: Indices { get }
  var isEmpty: Bool { get }
  var count: IndexDistance { get }
  func makeIterator() -&gt; Iterator
  func prefix(through: Index) -&gt; SubSequence
  func prefix(upTo: Index) -&gt; SubSequence
  func suffix(from: Index) -&gt; SubSequence
  func distance(from: Index, to: Index) -&gt; IndexDistance
  func index(_: Index, offsetBy: IndexDistance) -&gt; Index
  func index(_: Index, offsetBy: IndexDistance, limitedBy: Index) -&gt; Index?
  subscript(position: Index) -&gt; Element { get }
  subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }
}

/*
æ–‡æ¡£ä¸­å…³äºåè®®çš„æœ€å°éœ€æ±‚ï¼š
â€¦â€¦è¦ä½¿ä½ çš„ç±»å‹æ»¡è¶³ Collectionï¼Œä½ è‡³å°‘éœ€è¦å£°æ˜ä»¥ä¸‹è¦æ±‚çš„å†…å®¹ï¼š
startIndex å’Œ endIndex å±æ€§
è‡³å°‘èƒ½å¤Ÿè¯»å–ä½ çš„ç±»å‹ä¸­çš„å…ƒç´ çš„ä¸‹æ ‡æ–¹æ³•
è‡³å°‘èƒ½å¤Ÿè¯»å–ä½ çš„ç±»å‹ä¸­çš„å…ƒç´ çš„ä¸‹æ ‡æ–¹æ³•
ç”¨æ¥åœ¨é›†åˆç´¢å¼•ä¹‹é—´è¿›è¡Œæ­¥è¿›çš„ index(after:) æ–¹æ³•ã€‚
*/

// äºæ˜¯æœ€åï¼Œæˆ‘ä»¬éœ€è¦å®ç°çš„æœ‰ï¼š
protocol Collection: Sequence {
  /// ä¸€ä¸ªè¡¨ç¤ºé›†åˆä¸­ä½ç½®çš„ç±»å‹
  associatedtype Index: Comparable
  /// ä¸€ä¸ªéç©ºé›†åˆä¸­é¦–ä¸ªå…ƒç´ çš„ä½ç½®
  var startIndex: Index { get }
  /// é›†åˆä¸­è¶…è¿‡æœ«ä½çš„ä½ç½®---ä¹Ÿå°±æ˜¯æ¯”æœ€åä¸€ä¸ªæœ‰æ•ˆä¸‹æ ‡å€¼å¤§ 1 çš„ä½ç½®
  var endIndex: Index { get }
  /// è¿”å›åœ¨ç»™å®šç´¢å¼•ä¹‹åçš„é‚£ä¸ªç´¢å¼•å€¼
  func index(after i: Index) -&gt; Index
  /// è®¿é—®ç‰¹å®šä½ç½®çš„å…ƒç´ 
  subscript(position: Index) -&gt; Element { get }
}

extension FIFOQueue: Collection {
  public var startIndex: Int { return 0 }
  public var endIndex: Int { return left.count + right.count }
  public func index(after i: Int) -&gt; Int {
  precondition(i &lt; endIndex)
  return i + 1
}

public subscript(position: Int) -&gt; Element {
  precondition((0..&lt;endIndex).contains(position), "Index out of bounds")
  if position &lt; left.endIndex {
    return left[left.count - position - 1]
    } else {
    return right[position - left.count]
    }
  }
}

// æœ‰äº†è¿™å‡ è¡Œä»£ç ï¼Œæˆ‘ä»¬çš„é˜Ÿåˆ—å·²ç»æ‹¥æœ‰è¶…è¿‡ 40 ä¸ªæ–¹æ³•å’Œå±æ€§ä¾›æˆ‘ä»¬ä½¿ç”¨äº†
var q = FIFOQueue&lt;String&gt;()
for x in ["1", "2", "foo", "3"] {
  q.enqueue(x)
}
for s in q {
  print(s, terminator: " ")
} // 1 2 foo 3

// æˆ‘ä»¬å¯ä»¥å°†é˜Ÿåˆ—ä¼ é€’ç»™æ¥å—åºåˆ—çš„æ–¹æ³•ï¼š
var a = Array(q) // ["1", "2", "foo", "3"]
a.append(contentsOf: q[2...3])
a // ["1", "2", "foo", "3", "foo", "3"]

// æˆ‘ä»¬å¯ä»¥è°ƒç”¨é‚£äº› Sequence çš„æ‰©å±•æ–¹æ³•å’Œå±æ€§ï¼š
q.map { $0.uppercased() } // ["1", "2", "FOO", "3"]
q.flatMap { Int($0) } // [1, 2, 3]
q.filter { $0.count &gt; 1 } // ["foo"]
q.sorted() // ["1", "2", "3", "foo"]
q.joined(separator: " ") // 1 2 foo 3

// æˆ‘ä»¬ä¹Ÿå¯ä»¥è°ƒç”¨ Collection çš„æ‰©å±•æ–¹æ³•å’Œå±æ€§ï¼š
q.isEmpty // false
q.count // 4
q.first // Optional("1")
</code></pre></div></div>
<h4 id="2-éµå®ˆ-expressiblebyarrayliteral-åè®®">2. éµå®ˆ ExpressibleByArrayLiteral åè®®</h4>
<p>å®ç° ExpressibleByArrayLiteralï¼Œå¯ä»¥ç”¨ [value1, value2, etc] è¯­æ³•åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension FIFOQueue: ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Element...) {
    left = elements.reversed()
    right = []
  }
}

let queue: FIFOQueue = [1,2,3] // FIFOQueue&lt;Int&gt;(left: [3, 2, 1], right: [])
</code></pre></div></div>
<ul>
  <li>å­—é¢é‡
    <ul>
      <li>[1, 2, 3] å¹¶ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªâ€œæ•°ç»„å­—é¢é‡â€ï¼Œæ˜¯ä¸€ç§å†™æ³•ï¼Œå¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºä»»æ„çš„éµå®ˆ ExpressibleByArrayLiteral çš„ç±»å‹ã€‚åœ¨è¿™ä¸ªå­—é¢é‡é‡Œé¢è¿˜åŒ…æ‹¬äº†å…¶ä»–çš„å­—é¢é‡ç±»å‹ï¼Œæ¯”å¦‚èƒ½å¤Ÿåˆ›å»ºä»»æ„éµå®ˆ ExpressibleByIntegerLiteral çš„æ•´æ•°å‹å­—é¢é‡ã€‚</li>
      <li>è¿™äº›å­—é¢é‡æœ‰â€œé»˜è®¤â€çš„ç±»å‹ï¼Œå¦‚æœä½ ä¸æŒ‡æ˜ç±»å‹ï¼Œé‚£äº› Swift å°†å‡è®¾ä½ æƒ³è¦çš„å°±æ˜¯é»˜è®¤çš„ç±»å‹ã€‚</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let byteQueue: FIFOQueue&lt;UInt8&gt; = [1,2,3]
// FIFOQueue&lt;UInt8&gt;(left: [3, 2, 1], right: [])

// å­—é¢é‡çš„ç±»å‹å¯ä»¥ä»ä¸Šä¸‹æ–‡ä¸­æ¨æ–­å‡ºæ¥
// è¿™ä¸ªå‡½æ•°å¯ä»¥æ¥å—ä¸€ä¸ªä»å­—é¢é‡åˆ›å»ºçš„å‚æ•°ï¼Œè€Œè°ƒç”¨æ—¶æ‰€ä¼ é€’çš„å­—é¢é‡çš„ç±»å‹ï¼Œå¯ä»¥æ ¹æ®å‡½æ•°å‚æ•°çš„ç±»å‹è¢«æ¨æ–­å‡ºæ¥ã€‚
func takesSetOfFloats(floats: Set&lt;Float&gt;) {
  //...
}
takesSetOfFloats(floats: [1,2,3])
// è¿™ä¸ªå­—é¢é‡è¢«æ¨æ–­ä¸º Set&lt;Float&gt;ï¼Œè€Œä¸æ˜¯ Array&lt;Int&gt;
</code></pre></div></div>

<ul>
  <li>å…³è”ç±»å‹</li>
  <li>IndexingIterator<Self> ï¼Œé›†åˆç±»å‹ä¸­çš„é»˜è®¤è¿­ä»£å™¨ç±»å‹</Self></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public struct IndexingIterator&lt;Elements: _IndexableBase&gt;
: IteratorProtocol, Sequence
{
  internal let _elements: Elements
  internal var _position: Elements.Index
  init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
  public mutating func next() -&gt; Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &amp;_position)
    return element
  }
}
// (&lt;Elements: _IndexableBase&gt; è¿™ä¸ªæ³›å‹çº¦æŸå…¶å®åº”è¯¥æ˜¯ &lt;Elements: Collection&gt;ï¼Œä¸è¿‡ç¼–è¯‘å™¨è¿˜ä¸å…è®¸å¾ªç¯å…³è”ç±»å‹çº¦æŸã€‚)
</code></pre></div></div>
<ul>
  <li>SubSequenceï¼Œä» Sequence ç»§æ‰¿çš„ï¼Œä¸è¿‡ Collection ç”¨æ›´ä¸¥æ ¼çš„çº¦æŸé‡æ–°å®šä¹‰äº†è¿™ä¸ªç±»å‹ã€‚
    <ul>
      <li>ä¸€ä¸ªé›†åˆç±»å‹çš„ SubSequence æœ¬èº«ä¹Ÿåº”è¯¥æ˜¯ä¸€ä¸ª Collection (æˆ‘ä»¬è¿™é‡Œä½¿ç”¨äº†â€œåº”è¯¥â€è€Œä¸æ˜¯â€œå¿…é¡»â€è¿™ä¸ªè¯ï¼Œæ˜¯å› ä¸ºç°åœ¨ç±»å‹ç³»ç»Ÿä¸­æ— æ³•è¡¨è¾¾å‡ºè¿™ä¸ªè¦æ±‚)ã€‚</li>
      <li>å®ƒçš„é»˜è®¤å€¼æ˜¯ Slice<Self>ï¼Œå®ƒæ˜¯å¯¹åŸæ¥çš„é›†åˆçš„å°è£…ï¼Œå¹¶å­˜å‚¨äº†åˆ‡ç‰‡ç›¸å¯¹äºåŸæ¥é›†åˆçš„èµ·å§‹å’Œç»ˆæ­¢ç´¢å¼•ã€‚</Self></li>
      <li>é›†åˆç±»å‹ç»å¸¸éœ€è¦å¯¹å®ƒçš„ SubSequence çš„ç±»å‹è¿›è¡Œè‡ªå®šä¹‰ï¼Œç‰¹åˆ«æ˜¯å½“ SubSequence å°±æ˜¯ Self æ—¶ (ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªé›†åˆçš„åˆ‡ç‰‡æ‹¥æœ‰å’Œé›†åˆæœ¬èº«ç›¸åŒçš„ç±»å‹)ã€‚Foundation æ¡†æ¶ä¸­çš„ Data å°±æ˜¯ä¸€ä¸ªè¿™ç§é›†åˆçš„ä¾‹å­ã€‚</li>
    </ul>
  </li>
  <li>
    <p>IndexDistanceã€‚ä¸€ä¸ªæœ‰ç¬¦å·æ•´æ•°ç±»å‹ï¼Œä»£è¡¨äº†ä¸¤ä¸ªç´¢å¼•ä¹‹é—´çš„æ­¥æ•°ï¼Œä¸€èˆ¬é»˜è®¤çš„ Int ã€‚ä¾‹å¤–æƒ…å†µï¼šåœ¨ 32 ä½ç³»ç»Ÿä¸Šè®¿é—®å’Œå¤„ç†éå¸¸å¤§ ( &gt; 4GB) çš„æ–‡ä»¶ï¼Œå°† IndexDistance è®¾ä¸º (ä¾‹å¦‚) Int64ã€‚</p>
  </li>
  <li>Indicesã€‚é›†åˆçš„ indices å±æ€§çš„è¿”å›å€¼ç±»å‹ã€‚å®ƒä»£è¡¨å¯¹äºé›†åˆçš„æ‰€æœ‰æœ‰æ•ˆä¸‹æ ‡çš„ç´¢å¼•æ‰€ç»„æˆçš„é›†åˆï¼Œå¹¶ä»¥å‡åºè¿›è¡Œæ’åˆ—ã€‚
    <ul>
      <li>æ³¨æ„å¹¶ä¸åŒ…å« endIndex ï¼Œå› ä¸º endIndex ä»£è¡¨çš„æ˜¯æœ€åä¸€ä¸ªæœ‰æ•ˆç´¢å¼•ä¹‹åçš„é‚£ä¸ªç´¢å¼•ï¼Œå®ƒä¸æ˜¯æœ‰æ•ˆçš„ä¸‹æ ‡å‚æ•°ã€‚</li>
      <li>Indices çš„é»˜è®¤ç±»å‹æ˜¯ DefaultIndices<Self>ã€‚å’Œ Slice ä¸€æ ·ï¼Œå®ƒæ˜¯å¯¹äºåŸæ¥çš„é›†åˆç±»å‹çš„ç®€å•å°è£…ï¼Œå¹¶åŒ…å«èµ·å§‹å’Œç»“æŸç´¢å¼•ã€‚å®ƒéœ€è¦ä¿æŒå¯¹åŸé›†åˆçš„å¼•ç”¨ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿå¯¹ç´¢å¼•è¿›è¡Œæ­¥è¿›ã€‚å½“ç”¨æˆ·åœ¨è¿­ä»£ç´¢å¼•çš„åŒæ—¶æ”¹å˜é›†åˆçš„å†…å®¹çš„æ—¶å€™ï¼Œå¯èƒ½ä¼šé€ æˆæ„æƒ³ä¸åˆ°çš„æ€§èƒ½é—®é¢˜ï¼šå¦‚æœé›†åˆæ˜¯ä»¥å†™æ—¶å¤åˆ¶ (å°±åƒæ ‡å‡†åº“ä¸­çš„æ‰€æœ‰é›†åˆç±»å‹æ‰€åšçš„ä¸€æ ·) æ¥å®ç°çš„è¯ï¼Œè¿™ä¸ªå¯¹äºé›†åˆçš„é¢å¤–å¼•ç”¨å°†è§¦å‘ä¸å¿…è¦çš„å¤åˆ¶ã€‚</Self></li>
      <li>åœ¨ç»“æ„ä½“å’Œç±»ä¸­ä¼šæ¶‰åŠå†™æ—¶å¤åˆ¶ï¼Œå¦‚æœåœ¨ä¸ºè‡ªå®šä¹‰é›†åˆæä¾›å¦å¤–çš„ Indices ç±»å‹ä½œä¸ºæ›¿æ¢çš„è¯ï¼Œä¸éœ€è¦è®©å®ƒä¿æŒå¯¹åŸé›†åˆçš„å¼•ç”¨ï¼Œå¯ä»¥æå‡æ€§èƒ½ã€‚è¿™å¯¹äºé‚£äº›è®¡ç®—ç´¢å¼•æ—¶ä¸ä¾èµ–äºé›†åˆæœ¬èº«çš„é›†åˆç±»å‹éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œæ¯”å¦‚æ•°ç»„æˆ–è€…é˜Ÿåˆ—ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨æ•´æ•°ç±»å‹çš„ç´¢å¼•ã€‚</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CountableRange&lt;Index&gt;ï¼š
extension FIFOQueue: Collection {
  ...
  typealias Indices = CountableRange&lt;Int&gt;
  var indices: CountableRange&lt;Int&gt; {
    return startIndex..&lt;endIndex
  }
}
</code></pre></div></div>

<h3 id="å››ç´¢å¼•">å››ã€ç´¢å¼•</h3>
<p>ç´¢å¼•è¡¨ç¤ºäº†é›†åˆä¸­çš„ä½ç½®ã€‚æ¯ä¸ªé›†åˆéƒ½æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„ç´¢å¼•å€¼ï¼ŒstartIndex å’Œ endIndexã€‚</p>
<ul>
  <li>startIndex æŒ‡å®šé›†åˆä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒendIndex æ˜¯é›†åˆä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ä½ç½®ã€‚</li>
  <li>endIndex å¹¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¸‹æ ‡ç´¢å¼•ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºç´¢å¼•çš„èŒƒå›´ (someIndex..&lt;endIndex)ã€‚</li>
  <li>æˆ–è€…å°†å®ƒä¸åˆ«çš„ç´¢å¼•è¿›è¡Œæ¯”è¾ƒï¼Œæ¯”å¦‚æ¥æ§åˆ¶å¾ªç¯çš„é€€å‡ºæ¡ä»¶ (while someIndex &lt; endIndex)ã€‚</li>
  <li>åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œæˆ‘ä»¬éƒ½ä½¿ç”¨æ•´æ•°ä½œä¸ºæˆ‘ä»¬é›†åˆçš„ç´¢å¼•ï¼Œæ•´æ•°ç´¢å¼•ååˆ†ç›´è§‚ï¼Œä½†å®ƒå¹¶ä¸æ˜¯å”¯ä¸€é€‰é¡¹ã€‚é›†åˆç±»å‹çš„ Index çš„å”¯ä¸€è¦æ±‚æ˜¯ï¼Œå®ƒå¿…é¡»å®ç° Comparableï¼Œå¿…é¡»è¦æœ‰ç¡®å®šçš„é¡ºåºã€‚</li>
  <li>å­—å…¸çš„ç´¢å¼•æ˜¯ DictionaryIndex ç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘å­—å…¸å†…éƒ¨å­˜å‚¨ç¼“å†²åŒºçš„ä¸é€æ˜å€¼ï¼Œæ˜¯ä¸€ä¸ªIntåç§»å€¼çš„å°è£…ã€‚é€šè¿‡ç´¢å¼•ä¸‹æ ‡è®¿é—® Dictionary æ—¶è¿”å›çš„å€¼ï¼Œä¸åƒç”¨å­—å…¸é”®ä¸‹æ ‡è®¿é—®æ—¶é‚£æ ·æ˜¯ä¸€ä¸ªå¯é€‰å€¼ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Dictionary {
  ...
  subscript(key: Key) -&gt; Value?
}

// é€šè¿‡ç´¢å¼•è®¿é—®çš„æ–¹æ³•æ˜¯ Collection åè®®æ‰€å®šä¹‰çš„
// (åƒæ˜¯æ•°ç»„é‡Œçš„è¶Šç•Œç´¢å¼•è¿™æ ·çš„) æ— æ•ˆçš„ä¸‹æ ‡è¢«è®¤ä¸ºæ˜¯ç¨‹åºå‘˜çŠ¯çš„é”™è¯¯ï¼Œæ‰€ä»¥å®ƒæ€»æ˜¯è¿”å›éå¯é€‰å€¼.
// Element ç±»å‹æ˜¯ä¸€ä¸ªå¤šå…ƒç»„ï¼š(key: Key, value: Value)
protocol Collection {
  subscript(position: Index) -&gt; Element { get }
}
</code></pre></div></div>
<h4 id="1-ç´¢å¼•å¤±æ•ˆ">1. ç´¢å¼•å¤±æ•ˆ</h4>
<ul>
  <li>å½“é›†åˆå‘ç”Ÿæ”¹å˜æ—¶ï¼Œç´¢å¼•å¯èƒ½ä¼šå¤±æ•ˆ
    <ul>
      <li>ç´¢å¼•æœ¬èº«ä»æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯å®ƒç°åœ¨æŒ‡å‘äº†ä¸€ä¸ªå¦å¤–çš„å…ƒç´ ã€‚</li>
      <li>ç´¢å¼•æœ¬èº«å°±å·²ç»æ— æ•ˆäº†ï¼Œé€šè¿‡å®ƒå¯¹é›†åˆè®¿é—®å°†é€ æˆå´©æºƒã€‚</li>
    </ul>
  </li>
  <li>å­—å…¸çš„ç´¢å¼•ä¸ä¼šéšç€æ–°çš„é”®å€¼å¯¹çš„åŠ å…¥è€Œå¤±æ•ˆï¼Œç›´åˆ°å­—å…¸çš„å°ºå¯¸å¢å¤§åˆ°è§¦å‘é‡æ–°çš„å†…å­˜åˆ†é…ã€‚</li>
  <li>ç´¢å¼•åº”è¯¥æ˜¯ä¸€ä¸ªåªå­˜å‚¨åŒ…å«æè¿°å…ƒç´ ä½ç½®æ‰€éœ€æœ€å°ä¿¡æ¯çš„ç®€å•å€¼ã€‚åœ¨å°½å¯èƒ½çš„æƒ…å†µä¸‹ï¼Œç´¢å¼•ä¸åº”è¯¥æŒæœ‰å¯¹å®ƒä»¬é›†åˆçš„å¼•ç”¨ã€‚</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å¯ä»¥ç”¨ä»ä¸€ä¸ªæ•°ç»„ä¸­è·å–åˆ°çš„æ•´æ•°ç´¢å¼•å€¼æ¥è®¿é—®å¦ä¸€ä¸ªæ•°ç»„çš„å†…å®¹
let numbers = [1,2,3,4]
let squares = numbers.map { $0 * $0 }
let numbersIndex = numbers.index(of: 4)! // 3
squares[numbersIndex] // 16

// ä½¿ç”¨ä¸€ä¸ªå­—ç¬¦ä¸²çš„ startIndex æ¥è®¿é—®å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„é¦–å­—ç¬¦
// ç”¨è¿™ä¸ªç´¢å¼•æ¥é€šè¿‡ä¸‹æ ‡è®¿é—®ä¸€ä¸ªç©ºå­—ç¬¦ä¸²çš„è¯ï¼Œç¨‹åºå°†å› ä¸ºç´¢å¼•è¶Šç•Œè€Œå‘ç”Ÿå´©æºƒ
let hello = "Hello"
let world = "World"
let helloIdx = hello.startIndex
world[helloIdx] // W
</code></pre></div></div>
<ul>
  <li>åœ¨é›†åˆä¹‹é—´å…±äº«ç´¢å¼•æ˜¯æœ‰å…¶åˆç†ç”¨æ³•çš„ï¼Œåœ¨åˆ‡ç‰‡ä¸Šæˆ‘ä»¬ä¼šå¤§é‡ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚Collection åè®®è¦æ±‚åŸé›†åˆçš„ç´¢å¼•å¿…é¡»åœ¨åˆ‡ç‰‡ä¸Šä¹Ÿå‘½ä¸­åŒæ ·çš„å…ƒç´ ï¼Œåœ¨åˆ‡ç‰‡ä¹‹é—´å…±äº«ç´¢å¼•å°†ä¼šæ˜¯å®‰å…¨çš„æ“ä½œã€‚</li>
</ul>

<h4 id="2-ç´¢å¼•æ­¥è¿›">2. ç´¢å¼•æ­¥è¿›</h4>
<p>å‘å‰æˆ–è€…å‘åç§»åŠ¨ç´¢å¼•çš„ä»»åŠ¡æ˜¯ç”±é›†åˆæ¥è´Ÿè´£çš„ï¼Œcollection.index(after: someIndex)ã€‚</p>

<h4 id="3-è‡ªå®šä¹‰é›†åˆç´¢å¼•">3. è‡ªå®šä¹‰é›†åˆç´¢å¼•</h4>
<p>åˆ†å‰²å­—ç¬¦ä¸²ä¸­çš„å•è¯ï¼Œé‡‡ç”¨å»¶è¿ŸåŠ è½½çš„æ–¹å¼è¿›è¡Œè¿­ä»£ï¼Œä¸ä¸€æ¬¡æ€§åœ°è®¡ç®—å‡ºæ‰€æœ‰å•è¯ã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å°†ä½¿ç”¨æä¾›çš„åˆ†å‰²å…ƒç´ è¿›è¡Œåˆ†å‰²ï¼ŒæŠŠä¸€ä¸ªé›†åˆè½¬å˜ä¸ºå…¶ SubSequence çš„æ•°ç»„
// æ¯ä¸ªå•è¯çš„ç±»å‹éƒ½æ˜¯ SubStringï¼Œè¿™æ­£æ˜¯ String æ‰€å…³è”çš„ SubSequence ç±»å‹
var str = "Still I see monsters"
str.split(separator: " ") // ["Still", "I", "see", "monsters"]

// start æ˜¯æ‰€æœ‰å‰ç½®ç©ºæ ¼éƒ½è¢«ç§»é™¤äº†çš„å­å­—ç¬¦ä¸²ã€‚å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºæ ¼ï¼Œä»¥å®ƒä½œä¸ºå•è¯çš„ç»“æŸè¾¹ç•Œï¼Œæ‰¾ä¸åˆ°åˆ™ä½¿ç”¨ endIndexã€‚
extension Substring {
  var nextWordRange: Range&lt;Index&gt; {
    let start = drop(while: { $0 == " "})
    let end = start.index(where: { $0 == " "}) ?? endIndex
    return start.startIndex..&lt;end
  }
}

// é›†åˆç±»å‹çš„ç´¢å¼•éœ€è¦æ»¡è¶³ Comparable (å› ä¸º Comparable ç»§æ‰¿è‡ª Equatableï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦å®ç° ==)
struct WordsIndex: Comparable {
  fileprivate let range: Range&lt;Substring.Index&gt;
  fileprivate init(_ value: Range&lt;Substring.Index&gt;) {
    self.range = value
  }
  static func &lt;(lhs: Words.Index, rhs: Words.Index) -&gt; Bool {
    return lhs.range.lowerBound &lt; rhs.range.lowerBound
  }
  static func ==(lhs: Words.Index, rhs: Words.Index) -&gt; Bool {
    return lhs.range == rhs.range
  }
}

// æ»¡è¶³Collection åè®®è¦æ±‚ startIndex çš„å¤æ‚åº¦ä¸º O(1)
struct Words: Collection {
  let string: Substring
  let startIndex: WordsIndex
  init(_ s: String) {
    self.init(s[...])
  }
  private init(_ s: Substring) {
    self.string = s
    self.startIndex = WordsIndex(string.nextWordRange)
  }
  var endIndex: WordsIndex {
    let e = string.endIndex
    return WordsIndex(e..&lt;e)
  }
}

// ä¸‹æ ‡çš„å®ç°æ»¡è¶³ O(1) å¤æ‚åº¦
extension Words {
  subscript(index: WordsIndex) -&gt; Substring {
    return string[index.range]
  }
}

// åœ¨ç»™å®šæŸä¸ªæŸä¸ªç´¢å¼•æ—¶ï¼Œèƒ½å¤Ÿè®¡ç®—å‡ºä¸‹ä¸€ä¸ªç´¢å¼•
extension Words {
  func index(after i: WordsIndex) -&gt; WordsIndex {
    guard i.range.upperBound &lt; string.endIndex
    else { return endIndex }
    let remainder = string[i.range.upperBound...]
    return WordsIndex(remainder.nextWordRange)
  }
}
Array(Words(" hello world test ").prefix(2)) // ["hello", "world"]
</code></pre></div></div>
<ul>
  <li>æˆ‘ä»¬å¯ä»¥å¯¹å•è¯çš„è¾¹ç•Œè¿›è¡Œè®¾ç½®ï¼šç›¸å¯¹äºç°åœ¨ç›´æ¥ä½¿ç”¨ç©ºæ ¼ï¼Œæˆ‘ä»¬å¯ä»¥ä¼ å…¥ä¸€ä¸ª isWordBoundary: (Character) -&gt; Bool çš„å‡½æ•°æ¥ç¡®å®šå•è¯è¾¹ç•Œã€‚</li>
  <li>è¿™äº›ä»£ç å¹¶ä¸æ˜¯æŒ‡é’ˆå¯¹å­—ç¬¦ä¸²çš„ï¼šæˆ‘ä»¬å®Œå…¨å¯ä»¥å°† String æ›¿æ¢æˆä»»æ„çš„é›†åˆç±»å‹ã€‚æ¯”å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨åŒæ ·çš„ç®—æ³•æ¥å°† Data å»¶è¿Ÿåˆ†å‰²ä¸ºå¯å¤„ç†çš„å°æ•°æ®å—ã€‚</li>
</ul>

<h3 id="äº”åˆ‡ç‰‡">äº”ã€åˆ‡ç‰‡</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//  list.dropFirst():
let words: Words = Words("one two three")
let onePastStart = words.index(after: words.startIndex)

let firstDropped = words[onePastStart..&lt;words.endIndex]
Array(firstDropped) // ["two", "three"]

let firstDropped2 = words.suffix(from: onePastStart)
let firstDropped3 = words[onePastStart...]

// é»˜è®¤æƒ…å†µä¸‹ï¼ŒfirstDropped ä¸æ˜¯ Wordsï¼Œå®ƒçš„ç±»å‹æ˜¯ Slice&lt;Words&gt;
// Slice æ˜¯åŸºäºä»»æ„é›†åˆç±»å‹çš„ä¸€ä¸ªè½»é‡çº§å°è£…ã€å®ƒçš„å®ç°çœ‹ä¸Šå»ä¼šæ˜¯è¿™æ ·çš„
struct Slice&lt;Base: Collection&gt;: Collection {
  typealias Index = Base.Index
  typealias IndexDistance = Base.IndexDistance
  typealias SubSequence = Slice&lt;Base&gt;
  let collection: Base
  var startIndex: Index
  var endIndex: Index
  init(base: Base, bounds: Range&lt;Index&gt;) {
    collection = base
    startIndex = bounds.lowerBound
    endIndex = bounds.upperBound
  }
  func index(after i: Index) -&gt; Index {
    return collection.index(after: i)
  }
  subscript(position: Index) -&gt; Base.Element {
    return collection[position]
  }
  subscript(bounds: Range&lt;Base.Index&gt;) -&gt; Slice&lt;Base&gt; {
    return Slice(base: collection, bounds: bounds)
  }
}

// Sliceéå¸¸é€‚åˆä½œä¸ºé»˜è®¤çš„å­åºåˆ—ç±»å‹ï¼Œéœ€è¦è€ƒè™‘é›†åˆç±»å‹æœ¬èº«èƒ½å¤Ÿå½“ä½œè‡ªå·±çš„SubSequenceä½¿ç”¨
// Wordsæ¯”è¾ƒå®¹æ˜“ã€‚ç¼–è¯‘å™¨æ ¹æ®èŒƒå›´ä¸‹æ ‡è®¿é—®çš„è¿”å›ç±»å‹ï¼Œæ¨æ–­å‡ºSubSequenceç±»å‹ã€‚
extension Words {
  subscript(range: Range&lt;WordsIndex&gt;) -&gt; Words {
    let start = range.lowerBound.range.lowerBound
    let end = range.upperBound.range.upperBound
    return Words(string[start..&lt;end])
  }
}
</code></pre></div></div>
<ul>
  <li>å°†é›†åˆç±»å‹çš„ SubSequence å®šä¹‰ä¸ºå’Œé›†åˆç±»å‹ç›¸åŒçš„ç±»å‹ï¼Œå¯ä»¥å‡è½»é›†åˆç±»å‹ä½¿ç”¨è€…çš„è´Ÿæ‹…ï¼Œå› ä¸ºä»–ä»¬åªéœ€è¦ç†è§£å•ä¸ªç±»å‹å°±å¯ä»¥äº†ï¼Œè€Œä¸éœ€è¦å­¦ä¹ ä¸¤ä¸ªç±»å‹ã€‚</li>
  <li>è®©â€œæ ¹â€é›†åˆç±»å‹å’Œåˆ‡ç‰‡ä½¿ç”¨ä¸åŒçš„ç±»å‹ï¼Œæœ‰åŠ©äºé¿å…æ„å¤–çš„å†…å­˜â€œæ³„æ¼â€ï¼Œè¿™ä¹Ÿæ˜¯æ ‡å‡†åº“ä¸­ä½¿ç”¨ ArraySlice å’Œ Substring æ¥ä½œä¸º Array å’Œ String çš„å­åºåˆ—çš„åŸå› ã€‚</li>
</ul>

<h4 id="1-åˆ‡ç‰‡ä¸åŸé›†åˆå…±äº«ç´¢å¼•">1. åˆ‡ç‰‡ä¸åŸé›†åˆå…±äº«ç´¢å¼•</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cities = ["New York", "Rio", "London", "Berlin",
"Rome", "Beijing", "Tokyo", "Sydney"]
let slice = cities[2...4]
cities.startIndex // 0
cities.endIndex // 8
slice.startIndex // 2
slice.endIndex // 5
</code></pre></div></div>
<ul>
  <li>å¦‚æœä¸å°å¿ƒè®¿é—®äº† slice[0]ï¼Œä½ çš„ç¨‹åºå°†ä¼šå´©æºƒï¼Œä¸€å®šè¦ä» collection.startIndex å¼€å§‹è¿›è¡Œå¾ªç¯ï¼Œè€Œä¸è¦æŠŠ 0 ä½œä¸ºå¼€å§‹ã€‚å°½å¯èƒ½å§‹ç»ˆé€‰æ‹© for x in collection çš„å½¢å¼ï¼Œè€Œä¸å»æ‰‹åŠ¨åœ°ç”¨ for index in collection.indices è¿›è¡Œç´¢å¼•è®¡ç®—ã€‚å¦‚æœä½ åœ¨é€šè¿‡é›†åˆç±»å‹çš„ indices è¿›è¡Œè¿­ä»£æ—¶ï¼Œä¿®æ”¹äº†é›†åˆçš„å†…å®¹ï¼Œé‚£ä¹ˆ indices æ‰€æŒæœ‰çš„ä»»ä½•å¯¹åŸæ¥é›†åˆç±»å‹çš„å¼ºå¼•ç”¨éƒ½ä¼šç ´åå†™æ—¶å¤åˆ¶çš„æ€§èƒ½ä¼˜åŒ–ï¼Œå› ä¸ºè¿™ä¼šé€ æˆä¸å¿…è¦çš„å¤åˆ¶æ“ä½œã€‚å¦‚æœé›†åˆçš„å°ºå¯¸å¾ˆå¤§çš„è¯ï¼Œè¿™ä¼šå¯¹æ€§èƒ½é€ æˆå¾ˆå¤§çš„å½±å“ã€‚(ä¸æ˜¯æ‰€æœ‰é›†åˆçš„ Indices ç±»å‹éƒ½æŒæœ‰å¯¹åŸé›†åˆçš„å¼ºå¼•ç”¨ï¼Œä¸è¿‡å› ä¸ºæ ‡å‡†åº“ä¸­çš„ DefaultIndices æ˜¯è¿™ä¹ˆåšçš„ï¼Œæ‰€ä»¥å¾ˆå¤šé›†åˆéƒ½æœ‰åŒæ ·çš„è¡Œä¸ºã€‚)</li>
  <li>å¯ä»¥å°† for å¾ªç¯æ›¿æ¢ä¸º while å¾ªç¯ï¼Œç„¶åæ‰‹åŠ¨åœ¨æ¯æ¬¡è¿­ä»£çš„æ—¶å€™å¢åŠ ç´¢å¼•å€¼ï¼Œè¿™æ ·ä½ å°±ä¸ä¼šç”¨åˆ° indices å±æ€§ã€‚</li>
</ul>

<h4 id="2-æ³›å‹-prefixiterator">2. æ³›å‹ PrefixIterator</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct PrefixIterator&lt;Base: Collection&gt;: IteratorProtocol, Sequence {
  let base: Base
  var offset: Base.Index
  init(_ base: Base) {
    self.base = base
    self.offset = base.startIndex
  }
  mutating func next() -&gt; Base.SubSequence? {
    guard offset != base.endIndex else { return nil }
    base.formIndex(after: &amp;offset)
    return base.prefix(upTo: offset)
  }
}

// é€šè¿‡ä½¿è¿­ä»£å™¨ç›´æ¥æ»¡è¶³ Sequenceï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å¯¹å®ƒä½¿ç”¨åºåˆ—çš„é‚£äº›å‡½æ•°ï¼Œè€Œä¸ç”¨å¦å¤–å®šä¹‰ç±»å‹
let numbers = [1,2,3]
Array(PrefixIterator(numbers))
// [ArraySlice([1]), ArraySlice([1, 2]), ArraySlice([1, 2, 3])]
</code></pre></div></div>
<h3 id="å…­ä¸“é—¨çš„é›†åˆç±»å‹">å…­ã€ä¸“é—¨çš„é›†åˆç±»å‹</h3>
<p>Collection åŠªåŠ›å°†å®ƒçš„éœ€æ±‚æ§åˆ¶åœ¨æœ€å°ï¼Œåè®®æœ¬èº«åº”è¯¥åªè¦æ±‚å’ŒåŠŸèƒ½ç›¸å…³æ‰€ç»å¯¹å¿…é¡»çš„å†…å®¹ï¼Œæ»¡è¶³è¯¥åè®®çš„ç±»å‹å¯ä»¥ä¸éœ€è¦æä¾›é‚£äº›éç›¸å…³åŠŸèƒ½ã€‚</p>
<ul>
  <li>BidirectionalCollection â€” â€œä¸€ä¸ªæ—¢æ”¯æŒå‰å‘åˆæ”¯æŒåå‘éå†çš„é›†åˆã€‚</li>
  <li>RandomAccessCollection â€” â€œä¸€ä¸ªæ”¯æŒé«˜æ•ˆéšæœºå­˜å–ç´¢å¼•éå†çš„é›†åˆã€‚</li>
  <li>MutableCollection â€” â€œä¸€ä¸ªæ”¯æŒä¸‹æ ‡èµ‹å€¼çš„é›†åˆã€‚</li>
  <li>RangeReplaceableCollection â€” â€œä¸€ä¸ªæ”¯æŒå°†ä»»æ„å­èŒƒå›´çš„å…ƒç´ ç”¨åˆ«çš„é›†åˆä¸­çš„å…ƒç´ è¿›è¡Œæ›¿æ¢çš„é›†åˆã€‚</li>
</ul>

<h4 id="1-åŒå‘ç´¢å¼•">1. åŒå‘ç´¢å¼•</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension BidirectionalCollection {
  /// é›†åˆä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
  /// Collection æœ¬èº«ä¹Ÿèƒ½æä¾› last å±æ€§ï¼Œä»å¤´è¿­ä»£åˆ°å°¾ï¼ŒO(n) æ“ä½œ
  public var last: Element? {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
}

extension BidirectionalCollection {
  /// è¿”å›é›†åˆä¸­å…ƒç´ çš„é€†åºè¡¨ç¤ºæ–¹å¼ä¼¼ä¹æ•°ç»„
  /// - å¤æ‚åº¦: O(1)
  public func reversed() -&gt; ReversedCollection&lt;Self&gt; {
    return ReversedCollection(_base: self)
  }
}
</code></pre></div></div>
<ul>
  <li>BidirectionalCollection åœ¨å‰å‘ç´¢å¼•çš„åŸºç¡€ä¸Šåªå¢åŠ äº†ä¸€ä¸ªæ–¹æ³•ï¼Œä½†æ˜¯å®ƒéå¸¸å…³é”®ï¼Œé‚£å°±æ˜¯è·å–ä¸Šä¸€ä¸ªç´¢å¼•å€¼çš„ index(before:)ã€‚</li>
  <li>å’Œä¸Šé¢ Sequence çš„ enumerated å°è£…ä¸€æ ·ï¼Œå®ƒä¸ä¼šçœŸçš„å»å°†å…ƒç´ åšé€†åºæ“ä½œã€‚ReverseCollection ä¼šæŒæœ‰åŸæ¥çš„é›†åˆï¼Œå¹¶ä¸”ä½¿ç”¨é€†å‘çš„ç´¢å¼•ã€‚ä¾èµ–äº†å€¼è¯­ä¹‰çš„ç‰¹æ€§ï¼Œå°è£…å°†åŸé›†åˆâ€œå¤åˆ¶â€åˆ°å®ƒè‡ªå·±çš„å­˜å‚¨ä¸­ã€‚</li>
  <li>Dictionary å’Œ Set æ˜¯æ— åºçš„é›†åˆç±»å‹ï¼Œè®¨è®ºå‰å‘è¿­ä»£è¿˜æ˜¯åå‘è¿­ä»£æ²¡æœ‰æ„ä¹‰ã€‚</li>
</ul>

<h4 id="2-éšæœºå­˜å–çš„é›†åˆç±»å‹">2. éšæœºå­˜å–çš„é›†åˆç±»å‹</h4>
<p>RandomAccessCollection æä¾›äº†æœ€é«˜æ•ˆçš„å…ƒç´ å­˜å–æ–¹å¼ï¼Œå®ƒèƒ½å¤Ÿåœ¨å¸¸æ•°æ—¶é—´å†…è·³è½¬åˆ°ä»»æ„ç´¢å¼•ã€‚</p>
<ul>
  <li>æ»¡è¶³è¯¥åè®®çš„ç±»å‹å¿…é¡»èƒ½å¤Ÿ (a) ä»¥ä»»æ„è·ç¦»ç§»åŠ¨ä¸€ä¸ªç´¢å¼•ï¼Œä»¥åŠ (b) æµ‹é‡ä»»æ„ä¸¤ä¸ªç´¢å¼•ä¹‹é—´çš„è·ç¦»ï¼Œä¸¤è€…éƒ½éœ€è¦æ˜¯ O(1) æ—¶é—´å¸¸æ•°çš„æ“ä½œã€‚</li>
  <li>RandomAccessCollection ä»¥æ›´ä¸¥æ ¼çš„çº¦æŸé‡æ–°å£°æ˜äº†å…³è”çš„ Indices å’Œ SubSequence ç±»å‹ï¼Œè¿™ä¸¤ä¸ªç±»å‹è‡ªèº«ä¹Ÿå¿…é¡»æ˜¯å¯ä»¥è¿›è¡Œéšæœºå­˜å–çš„ã€‚</li>
  <li>æ»¡è¶³åè®®çš„ç±»å‹å¿…é¡»ç¡®ä¿æ»¡è¶³æ–‡æ¡£æ‰€è¦æ±‚çš„ O(1) å¤æ‚åº¦ï¼Œå¯ä»¥é€šè¿‡æä¾› index(_:offsetBy:) å’Œ distance(from:to:) æ–¹æ³•ï¼Œæˆ–è€…æ˜¯ä½¿ç”¨ä¸€ä¸ªæ»¡è¶³ Strideable çš„ Index ç±»å‹ (åƒæ˜¯ Int)ã€‚</li>
  <li>å¯¹äº Collection å’Œ BidirectionalCollectionï¼Œindex(_:offsetBy:) æ“ä½œé€šè¿‡æ¸è¿›çš„æ–¹å¼è®¿é—®ä¸‹ä¸€ä¸ªç´¢å¼•ï¼Œç›´åˆ°åˆ°è¾¾ç›®æ ‡ç´¢å¼•ä¸ºæ­¢ã€‚è¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªçº¿æ€§å¤æ‚åº¦çš„æ“ä½œï¼Œéšç€è·ç¦»çš„å¢åŠ ï¼Œå®Œæˆæ“ä½œéœ€è¦æ¶ˆè€—çš„æ—¶é—´ä¹Ÿçº¿æ€§å¢é•¿ã€‚è€Œéšæœºå­˜å–ç´¢å¼•åˆ™å®Œå…¨ä¸åŒï¼Œå®ƒå¯ä»¥ç›´æ¥åœ¨ä¸¤ä¸ªç´¢å¼•é—´è¿›è¡Œç§»åŠ¨ã€‚</li>
</ul>

<h4 id="3-mutablecollection">3. MutableCollection</h4>
<p>å¯å˜é›†åˆæ”¯æŒåŸåœ°çš„å…ƒç´ æ›´æ”¹ã€‚ç›¸æ¯”äº Collectionï¼ŒMutableCollection åªå¢åŠ äº†ï¼Œå•ä¸ªå…ƒç´ çš„ä¸‹æ ‡è®¿é—®æ–¹æ³• subscript å¿…é¡»æä¾›ä¸€ä¸ª setterã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension FIFOQueue: MutableCollection {
  public var startIndex: Int { return 0 }
  public var endIndex: Int { return left.count + right.count }
  public func index(after i: Int) -&gt; Int {
    return i + 1
  }
  public subscript(position: Int) -&gt; Element {
    get {
      precondition((0..&lt;endIndex).contains(position), "Index out of bounds")
      if position &lt; left.endIndex {
        return left[left.count - position - 1]
      } else {
        return right[position - left.count]
      }
    }
    set {
      precondition((0..&lt;endIndex).contains(position), "Index out of bounds")
      if position &lt; left.endIndex {
        left[left.count - position - 1] = newValue
      } else {
        return right[position - left.count] = newValue
      }
    }
  }
}

var playlist: FIFOQueue = ["Shake It Off", "Blank Space", "Style"]
playlist.first // Optional("Shake It Off")
playlist[0] = "You Belong With Me"
playlist.first // Optional("You Belong With Me")
</code></pre></div></div>
<ul>
  <li>ç¼–è¯‘å™¨ä¸è®©ä¸ºå­˜åœ¨çš„Collectionæ·»åŠ setterï¼Œå¿…é¡»æ‹“å±•æ–°æ–¹æ³•æ»¡è¶³MutableCollectionã€‚(a)ä¸å…è®¸åªæä¾›setterä¸æä¾›geterï¼Œ(b)æ— æ³•é‡æ–°å®šä¹‰å·²å­˜åœ¨çš„getterã€‚</li>
  <li>MutableCollection å…è®¸æ”¹å˜é›†åˆä¸­çš„å…ƒç´ å€¼ï¼Œä½†æ˜¯å®ƒä¸å…è®¸æ”¹å˜é›†åˆçš„é•¿åº¦æˆ–è€…å…ƒç´ çš„é¡ºåºã€‚</li>
  <li>å­—å…¸å’Œé›†åˆæ˜¯æ— åºçš„ç»“åˆç±»å‹ï¼Œindiceså…ƒç´ å˜åŒ–æ—¶ï¼Œå­˜å‚¨ä½ç½®ä¹Ÿä¼šæ”¹å˜ï¼Œä¸æ»¡è¶³ç´¢å¼•ä¿æŒä¸å˜çš„æ¡ä»¶ã€‚</li>
</ul>

<h4 id="4-rangereplaceablecollection">4. RangeReplaceableCollection</h4>
<ul>
  <li>åè®®æä¾›å¯¹äºéœ€è¦æ·»åŠ æˆ–è€…ç§»é™¤å…ƒç´ çš„æ“ä½œï¼Œä¸¤ä¸ªè¦æ±‚ï¼š
    <ul>
      <li>ä¸€ä¸ªç©ºçš„åˆå§‹åŒ–æ–¹æ³• â€” åœ¨æ³›å‹å‡½æ•°ä¸­è¿™å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒå…è®¸ä¸€ä¸ªå‡½æ•°åˆ›å»ºç›¸åŒç±»å‹çš„æ–°çš„ç©ºé›†åˆã€‚</li>
      <li>replaceSubrange(_:with:) æ–¹æ³• â€” å®ƒæ¥å—ä¸€ä¸ªè¦æ›¿æ¢çš„èŒƒå›´ä»¥åŠä¸€ä¸ªç”¨æ¥è¿›è¡Œæ›¿æ¢çš„é›†åˆã€‚</li>
    </ul>
  </li>
  <li>åªéœ€è¦å®ç°ä¸€ä¸ªè¶…çº§çµæ´»çš„ replaceSubrange æ–¹æ³•ï¼Œåè®®æ‰©å±•å°±å¯ä»¥ä¸ºä½ å¼•ç”³å‡ºä¸€ç³»åˆ—æœ‰ç”¨çš„æ–¹æ³•ã€‚
    <ul>
      <li>append(_:) å’Œ append(contentsOf:) â€” å°† endIndex..&lt;endIndex (ä¹Ÿå°±æ˜¯è¯´æœ«å°¾çš„ç©ºèŒƒå›´) æ›¿æ¢ä¸ºå•ä¸ªæˆ–å¤šä¸ªæ–°çš„å…ƒç´ ã€‚</li>
      <li>remove(at:) å’Œ removeSubrange(_:) â€” å°† iâ€¦i æˆ–è€… subrange æ›¿æ¢ä¸ºç©ºé›†åˆã€‚</li>
      <li>insert(at:) å’Œ insert(contentsOf:at:) â€” å°† i..&lt;i (æˆ–è€…è¯´åœ¨æ•°ç»„ä¸­æŸä¸ªä½ç½®çš„ç©ºèŒƒå›´) æ›¿æ¢ä¸ºå•ä¸ªæˆ–å¤šä¸ªæ–°çš„å…ƒç´ ã€‚</li>
      <li>removeAll â€” å°† startIndex..&lt;endIndex æ›¿æ¢ä¸ºç©ºé›†åˆã€‚</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// å°†è¿™äº›å…ƒç´ å†åšä¸€æ¬¡é€†åºï¼Œç„¶ååˆå¹¶åˆ°å³ä¾§çš„æ•°ç»„ä¸­ï¼Œä¸€æ¬¡æ€§åœ°å¯¹æ•´ä¸ªèŒƒå›´è¿›è¡Œæ›¿æ¢
extension FIFOQueue: RangeReplaceableCollection {
  mutating func replaceSubrange&lt;C: Collection&gt;(_ subrange: Range&lt;Int&gt;,
  with newElements: C) where C.Element == Element
  {
    right = left.reversed() + right
    left.removeAll()
    right.replaceSubrange(subrange, with: newElements)
  }
}
</code></pre></div></div>
<h4 id="5-ç»„åˆèƒ½åŠ›">5. ç»„åˆèƒ½åŠ›</h4>
<p>è¿™äº›ä¸“é—¨çš„é›†åˆåè®®å¯ä»¥è¢«å¾ˆå¥½åœ°ç»„åˆèµ·æ¥ï¼Œä½œä¸ºä¸€ç»„çº¦æŸï¼Œæ¥åŒ¹é…æ¯ä¸ªç‰¹å®šç®—æ³•çš„è¦æ±‚ã€‚</p>

<p>ä¸¾ä¾‹æ¥è¯´ï¼Œæ ‡å‡†åº“ä¸­æœ‰ä¸ª sort æ–¹æ³•ï¼Œå¯ä»¥åŸåœ°å¯¹ä¸€ä¸ªé›†åˆè¿›è¡Œæ’åº (è€Œä¸åƒå®ƒçš„ä¸å¯å˜ç‰ˆæœ¬ sorted é‚£æ ·ï¼Œè¿”å›ä¸€ä¸ªæ’åºåçš„æ•°ç»„)ã€‚</p>
<ul>
  <li>åŸåœ°æ’åºéœ€è¦é›†åˆæ˜¯å¯å˜çš„ï¼Œå¦‚æœä½ æƒ³è¦æ’åºä¿æŒè¿…é€Ÿï¼Œä½ è¿˜éœ€è¦éšæœºå­˜å–ã€‚æœ€åï¼Œå½“ç„¶ä½ è¿˜éœ€è¦èƒ½å¤Ÿæ¯”è¾ƒé›†åˆä¸­å…ƒç´ çš„å¤§å°ã€‚</li>
  <li>å°†è¿™äº›è¦æ±‚ç»„åˆèµ·æ¥ï¼Œsort æ–¹æ³•è¢«å®šä¹‰åœ¨äº† MutableCollection ä¸Šï¼Œå¹¶åŒ…æ‹¬ RandomAccessCollection å’Œ Element: Comparable ä½œä¸ºé™„åŠ çš„çº¦æŸï¼š</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension MutableCollection
  where Self: RandomAccessCollection, Element: Comparable {
  /// åŸåœ°å¯¹é›†åˆè¿›è¡Œæ’åº
  public mutating func sort() { ... }
}
</code></pre></div></div>
:ET