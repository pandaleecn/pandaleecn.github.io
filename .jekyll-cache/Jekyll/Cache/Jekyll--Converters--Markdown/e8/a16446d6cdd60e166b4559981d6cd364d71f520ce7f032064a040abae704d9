I"(<h4 id="1-block介绍和调用">1. Block介绍和调用</h4>
<p>定义：Block是将函数及其执行上下文封装起来的对象 
<img src="http://files.pandaleo.cn/67c852101669450f90bd710124949ff3.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    int multiplier = 6;
    int(^Block)(int) = ^int(int num){
        return num * multiplier;
    };
    Block(2);
}
// 使用【clang -rewrite-objc file.m】查看编译之后的文件内容
// TBlock.cpp

#ifndef BLOCK_IMPL
#define BLOCK_IMPL
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

// @implementation TBlock


struct __TBlock__method_block_impl_0 {
  struct __block_impl impl;
  struct __TBlock__method_block_desc_0* Desc;
  int multiplier;
  __TBlock__method_block_impl_0(void *fp, struct __TBlock__method_block_desc_0 *desc, int _multiplier, int flags=0) : multiplier(_multiplier) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static int __TBlock__method_block_func_0(struct __TBlock__method_block_impl_0 *__cself, int num) {
  int multiplier = __cself-&gt;multiplier; // bound by copy

        return num * multiplier;
    }

static struct __TBlock__method_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __TBlock__method_block_desc_0_DATA = { 0, sizeof(struct __TBlock__method_block_impl_0)};

static void _I_TBlock_method(TBlock * self, SEL _cmd) {

    int multiplier = 6;
    /* Block介绍
     int(^Block)(int) = ^int(int num){
         return num * multiplier;
     };
     */
    int(*Block)(int) = ((int (*)(int))&amp;__TBlock__method_block_impl_0((void *)__TBlock__method_block_func_0, &amp;__TBlock__method_block_desc_0_DATA, multiplier));
    /* Block调用
     Block(2);
     */
    ((int (*)(__block_impl *, int))((__block_impl *)Block)-&gt;FuncPtr)((__block_impl *)Block, 2);
}

// @end
</code></pre></div></div>

<h4 id="2-截获变量">2. 截获变量</h4>
<p>在block中使用定义的变量叫截获变量。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    int multiplier = 6; // 基本数据类型
    int(^Block)(int) = ^int(int num){
        return num * multiplier;
    };
    multiplier = 4;
    NSLog(@"result is %d", Block(2)); // result is 12
}
// 使用【clang -rewrite-objc -objc-arc file.m】命令
</code></pre></div></div>
<ul>
  <li>局部变量
    <ul>
      <li>基本数据类型，截获其值</li>
      <li>对象类型，连同所有权修饰符一起截获。</li>
    </ul>
  </li>
  <li>静态局部变量，以指针形式截获。</li>
  <li>全局变量、静态全局变量，不截获。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// TBlock.m文件
@implementation TBlock

// 全局变量
int global_var = 4;
// 静态全局变量
static int static_global_var = 5;

- (void)method
{
    static int multiplier = 6; // 静态局部变量
    int(^Block)(int) = ^int(int num)
    {
        return num * multiplier;
    };
    multiplier = 4;
    NSLog(@"result is %d", Block(2)); // result is 8
}

@end

// TBlock.cpp文件

int global_var = 4;
static int static_global_var = 5;

struct __TBlock__method_block_impl_0 {
  struct __block_impl impl;
  struct __TBlock__method_block_desc_0* Desc;
    // 截获局部变量的值
  int var;
    // 连同所有权修饰符一起截获
  __unsafe_unretained id unsafe_obj;
  __strong id strong_obj;
    // 以指针形式截获局部变量
  int *static_var;
    // 对全局变量、静态全局变量不截获

  __TBlock__method_block_impl_0(void *fp, struct __TBlock__method_block_desc_0 *desc, int _var, __unsafe_unretained id _unsafe_obj, __strong id _strong_obj, int *_static_var, int flags=0) : var(_var), unsafe_obj(_unsafe_obj), strong_obj(_strong_obj), static_var(_static_var) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// 调用
static void _I_MCBlock_method(MCBlock * self, SEL _cmd) {

    int var = 1;

    __attribute__((objc_ownership(none))) id unsafe_obj = __null;
    __attribute__((objc_ownership(strong))) id strong_obj = __null;


    static int static_var = 3;

    void(*Block)(void) = ((void (*)())&amp;__MCBlock__method_block_impl_0((void *)__MCBlock__method_block_func_0, &amp;__MCBlock__method_block_desc_0_DATA, var, unsafe_obj, strong_obj, &amp;static_var, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)Block)-&gt;FuncPtr)((__block_impl *)Block);
}
</code></pre></div></div>

<h4 id="3-__block修饰符">3. __block修饰符</h4>
<ul>
  <li>一般情况下，对被截获变量进行赋值操作需添加__block修饰符  <br />
<img src="http://files.pandaleo.cn/089f8e9bcbe245a5ea07e5cdb4d24230.png" alt="" /></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    NSMutableArray *array = [NSMutableArray array];
    void(^Block)(void) = ^{
        [array addObject:@123]; // 只是使用，未赋值
    }
    Block();
}

{
    NSMutableArray *array = nil; // 需要添加__block修饰符
    void(^Block)(void) = ^{
        array = [NSMutableArray array];
    }
    Block();
}
</code></pre></div></div>
<ul>
  <li>对变量进行赋值时<br />
<img src="http://files.pandaleo.cn/a8a419108c4fb22d43283ba7b21c31bc.png?imageMogr2/thumbnail/!68p" alt="" />
<img src="http://files.pandaleo.cn/aa859656792c80c60e81ab73528f6d08.png?imageMogr2/thumbnail/!68p" alt="" /></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    __block int multiplier = 6;
    int(^Block)(int) = ^int(int num)
    {
        return num * multiplier;
    };
    multiplier = 4;
    NSLog(@"result is %d", Block(2)); // result is 8
}
</code></pre></div></div>
<ul>
  <li>__block修饰的变量变成了对象
<img src="http://files.pandaleo.cn/235eb01e5dcf3f3d9c595cb09d77cfac.png" alt="" />
<img src="http://files.pandaleo.cn/64a4f870ea141a9b5ce83e8681a89696.png?imageMogr2/thumbnail/!68p" alt="" />
    <ul>
      <li>栈上的__forwarding指向自己，堆上__forwarding指向别处。</li>
    </ul>
  </li>
</ul>

<h4 id="4-block的内存管理">4. Block的内存管理</h4>
<p>impl.isa = &amp;_NSConcreteStackBlock
<img src="http://files.pandaleo.cn/f3fc6c338cf46c4d5d71cc5b0247736a.png?imageMogr2/thumbnail/!68p" alt="" /></p>
<ul>
  <li>Block的Copy操作
<img src="http://files.pandaleo.cn/9352e27789c0805a3063722a830a88c3.png?imageMogr2/thumbnail/!68p" alt="" /></li>
  <li>栈上Block的销毁
<img src="http://files.pandaleo.cn/eb56b951ba243874970618cb880e27b6.png?imageMogr2/thumbnail/!68p" alt="" /></li>
  <li>栈上Block的Copy，存在内存泄漏
<img src="http://files.pandaleo.cn/b47fb2e771f9e79231325b68a1022041.png?imageMogr2/thumbnail/!68p" alt="" /></li>
  <li>栈上__block变量的copy
<img src="http://files.pandaleo.cn/622f45099e7ba741aa41db7d66a528ea.png?imageMogr2/thumbnail/!68p" alt="" />
（multiplier.__forwading-&gt;multiplier） = 4;
    <ul>
      <li>copy操作时栈上和堆上的修改操作都是修改堆上的变量，copy操作从栈上复制到堆上，重新进行了内存分配</li>
      <li>非copy时，修改自身栈上的变量</li>
    </ul>
  </li>
  <li>__forwading总结
<img src="http://files.pandaleo.cn/c8625fea5d56fa68adb9a2efe440c062.png" alt="" />
    <ul>
      <li>_blk赋值操作为copy，修改堆上的数据，函数执行时也是使用堆值</li>
      <li>不论在任何内存位置，都可以顺利访问同一个__block变量</li>
    </ul>
  </li>
</ul>

<h4 id="5-block的循环引用">5. Block的循环引用</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    _array = [NSMutableArray arrayWithObject:@"block"];
    _strBlk = ^NSString*(NSString *num){
        return [NSString stringwithFormat:@"helloc_%@", array[0]];
    }
    _strBlk(@"hello");
}
</code></pre></div></div>
<ul>
  <li>存在自引用循环引用，对象类型截获变量时会连同属性关键字strong。
<img src="http://files.pandaleo.cn/b844fc426e4c0bc64fb4add1ea1f1341.png?imageMogr2/thumbnail/!68p" alt="" /></li>
  <li>解决方案：__weak NSArray *weakArray = _array;<br />
<img src="http://files.pandaleo.cn/d6b1b340d22f383d5bdf20a3326dd16c.png?imageMogr2/thumbnail/!68p" alt="" />
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  __block TBlock* blockSelf = self;
  _blk = ^int(int num){
      // var = 2
      // blockSelf = nil; ARC解决方案
      // 如果一直未使用，会导致环一直存在。
      return num * blockSelf.var;
  }

  _blk(3);
}
</code></pre></div>    </div>
  </li>
  <li>在MRC下，不会产生循环引用。当在MRC环境时，直接复制，并不会retain捕获的对象。所以在MRC环境下，__block可以消除循环引用。</li>
  <li>在ARC下，会产生大环循环引用，引起内存泄漏。
<img src="http://files.pandaleo.cn/528d69907fefa0a7920978ca00a32acd.png?imageMogr2/thumbnail/!68p" alt="" />
    <h4 id="6-总结">6. 总结</h4>
  </li>
  <li>为什么Block会产生循环引用？
    <ul>
      <li>当前block对成员变量截获时，会对其强引用，当前对象对block也存在强引用时，会产生循环引用。可以通过声明__weak时，消除循环引用。</li>
      <li>__block时，在ARC存在循环引用，MAC不存在。可以通过断环的方式解决循环引用，但是如果一直未调用仍会存在。</li>
    </ul>
  </li>
  <li>怎样理解Block截获变量的特性？
    <ul>
      <li>基本类型截获其值</li>
      <li>对象类型截获强引用和所有权修饰符</li>
      <li>静态局部变量，截获引用类型</li>
      <li>不截获全局和全局静态变量</li>
    </ul>
  </li>
  <li>block属性为什么要使用copy?
    <ul>
      <li>MRC下，copy将block从栈拷贝到区，因为栈中变量出了作用域会被销毁，无法全局使用。所以将其拷贝到堆区全局共享，不会被销毁。MRC手动管理堆区，不需要系统管理。</li>
      <li>ARC可以不使用copy，因为属性就在堆区。</li>
    </ul>
  </li>
</ul>
:ET