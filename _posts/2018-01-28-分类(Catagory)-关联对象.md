---
layout: post
title: '分类(Catagory)-关联对象'
date: 2018-01-28
author: 李大鹏
cover: ''
tags: Objective-C
---

#### 1. 给分类添加"成员变量"

不能直接添加成员变量，可以用关联对象的方法为分类添加。

```
// 根据指定key到object对象中，获取和key对象对应的关联值返回给调用方
id objc_getAssociatedObject(id object, const void *key)

// policy：关联方法，copy、retain
// 设定对应关系的key和value，通过policy策略，关联到对应的对象上
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)

// 移除对象所有的关联对象
void objc_removeAssociatedObject(id object)
```

#### 2. 关联对象的本质

- 关联对象 AssociationsManager 管理并在 AssociationsHashMap 存储。
- 所有对象的关联内容都在同一个全局容器中。
  ![2020-08-14-21-13-16](http://files.pandaleo.cn/2020-08-14-21-13-16.png)
  - 封装 ObjcAssociation 数据结构，policy: OBJC_ASSOCIATION_COPY_NONATOMIC，copy 策略关联 value 字符串对象“HELLO”
  - 封装 ObjectAssociationMap，key：@selector(text)，用在分类中声明的方法或选择器作为 key 传到 objc_setAssociatedObject 方法中
  - 封装 AssociationsHashMap，放入全局容器，通过建立当前被关联对象的指针值（DISGUISE(obj)）和 ObjectAssopciationMap 的映射进行关联
  - 可以为一个对象添加多个关联值，通过 Dictionary 对象进行关联

#### 3. 关联对象在容器中存储的格式

![](http://files.pandaleo.cn/fb749d17225915940282123e7909cf57.png)
注：setObject 时 value 传成 nil，就可以把对应 key 的值擦除掉

#### 4. 源码分析

```
void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        // 关联对象管理类，C++实现的一个类
        AssociationsManager manager;
        // 获取其维护的一个Hashmap，可以理解为一个字典
        // 全局容器
        AssociationsHashMap &associations(manager.associations());
        // 根据对象指针查找对应的一个ObjectAssociationMap结构的map，指针对象按位取反
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            // 根据对象指针查找对应的ObjectAssociationMap结构的map
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end()) {
                // secondary table exists
                // 不是第一次添加关联对象
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                  // 找到则替换，未找到直接关联
                    old_association = j->second;
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                // 对象没有添加过关联对象，第一次添加
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                object->setHasAssociatedObjects();
            }
        } else { //
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                // 撤销关联对象时，可以将其值设为nil
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
```
