---
layout: post
title: 'Swiftå­—ç¬¦ä¸²'
date: 2018-03-28
author: æå¤§é¹
cover: ''
tags: Swift
---
### ä¸€ã€Unicodeï¼Œè€Œéå›ºå®šå®½åº¦
* Unicode æ˜¯å¯å˜é•¿æ ¼å¼ï¼Œç”±ç¼–ç å•å…ƒç»„æˆ Unicode æ ‡é‡ï¼Œä¹‹åç”±æ ‡é‡ç»„æˆå­—ç¬¦ã€‚
* Unicode æ•°æ®å¯ä»¥è¢«ç¼–ç æˆä¸åŒå®½åº¦çš„ç¼–ç å•å…ƒï¼Œæœ€æ™®éçš„æœ‰ 8 æ¯”ç‰¹ (UTF-8) æˆ–è€… 16 æ¯”ç‰¹ (UTF-16)ã€‚
UTF-8 å‘åå…¼å®¹ 8 æ¯”ç‰¹çš„ ASCIIï¼Œç›®å‰ç½‘ä¸Šæœ€æµè¡Œçš„ç¼–ç æ–¹å¼ã€‚Swift åˆ†åˆ«ç”¨ UInt16 å’Œ UInt8 æ¥è¡¨ç¤º
(å®ƒä»¬è¢«èµ‹äºˆäº† Unicode.UTF16.CodeUnit å’Œ Unicode.UTF8.CodeUnit çš„ç±»å‹åˆ«å)ã€‚
* Unicode ä¸­çš„ç¼–ç ç‚¹ (code point) åœ¨ Unicode ç¼–ç ç©ºé—´ä¸­æ˜¯ä»‹äº 0 åˆ° 0x10FFFF (ä¹Ÿå°±æ˜¯åè¿›
  åˆ¶çš„ 1,114,111) ä¹‹é—´çš„ä¸€ä¸ªå•ä¸€å€¼ã€‚åœ¨è¿™ 110 ä¸‡ä¸ªæ•°å€¼é‡Œï¼Œç°åœ¨åªæœ‰å¤§çº¦ 137,000 ä¸ªåœ¨è¢«ä½¿ç”¨ä¸­ï¼Œ
  è¿˜æœ‰å¾ˆå¤šç©ºé—´å¯ä»¥ç”¨æ¥å­˜æ”¾é¢œæ–‡å­—è¿™æ ·çš„ä¸œè¥¿ã€‚å¯¹äº UTF-32ï¼Œä¸€ä¸ªç¼–ç ç‚¹ä¼šå ç”¨ä¸€ä¸ªç¼–ç å•å…ƒã€‚å¯¹äºUTF-8
  ä¸€ä¸ªç¼–ç ç‚¹ä¼šå ç”¨ä¸€è‡³å››ä¸ªç¼–ç å•å…ƒã€‚èµ·å§‹çš„ 256 ä¸ª Unicode ç¼–ç ç‚¹å’Œ Latin-1 ä¸­çš„å­—ç¬¦æ˜¯ä¸€è‡´çš„ã€‚
* Unicode æ ‡é‡å’Œç¼–ç å¤§ä½“ç›¸åŒï¼Œé™¤äº†åœ¨ 0xD800â€“0xDFFF ä¹‹é—´èŒƒå›´é‡Œçš„ 2,048 ä¸ªâ€œä»£ç†â€ (surrogate) ç¼–ç ç‚¹ï¼Œ
ç”¨æ¥æ ‡å¿— UTF-16 ç¼–ç çš„å¼€å¤´å’Œç»“å°¾ã€‚æ ‡é‡åœ¨ Swift å­—ç¬¦ä¸²å­—é¢é‡ä¸­ä»¥ â€œ\u{xxxx}â€ æ¥è¡¨ç¤ºï¼Œxxxx ä¸ºåå…­è¿›åˆ¶æ•°ç»„ã€‚
å¦‚ï¼šæ¬§å…ƒç¬¦å· â‚¬ï¼Œ"\u{20AC}ï¼Œå¯¹åº”ç±»å‹æ˜¯ Unicode.Scalarï¼Œå¯¹ UInt32 å°è£…çš„ç±»å‹ã€‚
* æ‰©å±•å­—ä½ç°‡ï¼šç”¨æˆ·æœ€ç»ˆçœ‹åˆ°çš„å­—ç¬¦çš„æœ¯è¯­ã€‚å•ä¸ªç¼–ç å•å…ƒå¯¹åº” Unicode æ ‡é‡æ—¶ï¼Œéœ€è¦ 21 ä½ç¼–ç ç³»ç»Ÿï¼Œ
é€šå¸¸å‘ä¸Šå–æ•´åˆ°32ä½ï¼ˆUTF-32ã€‚ä½†æ˜¯å®½åº¦ä»ä¸å›ºå®šï¼šåœ¨æ ‡é‡ç»„æˆå­—ç¬¦æ—¶ï¼ŒUnicode ä¾æ—§æ˜¯å¯å˜å®½åº¦æ ¼å¼ï¼Œ
æ‰©å±•å­—ä½ç°‡å¯èƒ½ç”±å¤šä¸ªç¼–ç ç‚¹ç»„åˆè€Œæˆã€‚
* æ ‡é‡å½¢æˆå­—ä½ç°‡çš„è§„åˆ™ï¼Œå†³å®šå­—ç¬¦æ–‡æœ¬çš„åˆ†æ®µï¼Œå¦‚ä½¿ç”¨é€€æ ¼åˆ é™¤æ“ä½œæ—¶ï¼Œåˆ é™¤å¯¹åº”çš„å­—ç¬¦ç°‡ã€‚è¯¥å­—ç¬¦ç°‡å¯èƒ½
å¯¹åº”å¤šä¸ªæ ‡é‡ï¼Œæ¯ä¸ªæ ‡é‡åœ¨æ–‡æœ¬å­˜å‚¨çš„å†…å­˜ä¸­ï¼Œä¹Ÿå¯èƒ½ä½¿ç”¨äº†å¯å˜æ•°é‡çš„ç¼–ç å•å…ƒã€‚Swift å­—ç¬¦ç°‡ç”± Character
ç±»å‹è¡¨ç¤ºï¼Œå¯ä»¥å¯¹ä»»æ„æ•°é‡çš„æ ‡é‡ç¼–ç ï¼Œå½¢æˆç”¨æˆ·çœ‹åˆ°çš„å­—ç¬¦ã€‚  

### äºŒã€å­—ä½ç°‡å’Œæ ‡å‡†ç­‰ä»·
#### 1. åˆå¹¶æ ‡è®°
* Unicode å¯¹ â€œÃ©â€ ç”±ä¸¤ç§è¡¨è¾¾æ–¹å¼ï¼šU+00E9 å’Œ å­—æ¯ â€œeâ€ åé¢è·Ÿä¸€ä¸ª U+0301ã€‚
* æ ‡å‡†ç­‰ä»·ï¼šä½¿ç”¨ä¸¤ç§æ–¹å¼æ˜¾ç¤ºçš„ â€œrÃ©sumÃ©â€ å­—ç¬¦ä¸²å½¼æ­¤ç›¸ç­‰ã€‚
* åŒä¸€ä¸ªå­—ç¬¦å¤šç§è¡¨ç¤ºï¼Œé¢„ç»„åˆå­—ç¬¦çš„å­˜åœ¨ä½¿å¾—å¼€æ”¾åŒºé—´çš„ Unicode ç¼–ç ç‚¹å¯ä»¥å’Œæ‹¥æœ‰ â€œÃ©â€ å’Œ â€œÃ±â€
è¿™ç±»å­—ç¬¦çš„ Latin-1 å…¼å®¹ã€‚äºŒè€…ä¹‹é—´è½¬æ¢å¯ä»¥å¿«é€Ÿã€ç®€å•ï¼Œä½†æ˜¯å¤„ç†æœ‰ç‚¹éº»çƒ¦ã€‚
* æœ‰äº›å­—ç¬¦éœ€è¦é€šè¿‡å„ç§ç¼–ç ç‚¹çš„ç»„åˆæ‰èƒ½æ­£ç¡®å¤„ç†ã€‚  

```
let single = "Pok\u{00E9}mon" // PokÃ©mon
let double = "Poke\u{0301}mon" // PokeÌmon

(single, double) // ("PokÃ©mon", "PokeÌmon")

single.count // 7
double.count // 7

single == double // true

single.utf16.count // 7
double.utf16.count // 8

let nssingle = single as NSString
nssingle.length // 7
let nsdouble = double as NSString
nsdouble.length // 8
nssingle == nsdouble // false

//  == è¢«å®šä¹‰æˆæ¯”è¾ƒä¸¤ä¸ª NSObject çš„ç‰ˆæœ¬
extension NSObject: Equatable {
  static func ==(lhs: NSObject, rhs: NSObject) -> Bool {
  return lhs.isEqual(rhs)
  }
}
// NSString åœ¨ UTF-16 ç¼–ç å•å…ƒçš„å­—é¢å€¼å±‚é¢ä¸Šæ¯”è¾ƒï¼Œæ²¡æœ‰è€ƒè™‘ç»„åˆçš„ç­‰ä»·æ€§ã€‚å…¶ä»–è¯­è¨€çš„å¤§éƒ¨åˆ†
å­—ç¬¦ä¸² APIä¹Ÿæ˜¯ã€‚æ ‡å‡†çš„æ¯”è¾ƒéœ€è¦ä½¿ç”¨ï¼ŒNSString.compare(_:)ï¼Œåœ¨å›½é™…åŒ–ä¸Šå¾ˆéš¾è¿½æŸ¥ bugã€‚

// åªæ¯”è¾ƒç¼–ç å•å…ƒæ•ˆç‡å¾ˆå¿«ï¼ŒSwift ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„æ¯”è¾ƒæ–¹å¼
single.utf16.elementsEqual(double.utf16) // false

// çº¦é²å·´è¯­ï¼Œä¸€ä¸ªå­—ç¬¦ä¸‰ç§ä¸åŒå½¢å¼ä¹¦å†™
let chars: [Character] = [
"\u{1ECD}\u{300}", // á»Ì
"\u{F2}\u{323}", // á»Ì
"\u{6F}\u{323}\u{300}", // á»Ì
"\u{6F}\u{300}\u{323}" // á»Ì
]
let allEqual = chars.dropFirst().all { $0 == chars.first } // true
// (all(matching:) æ–¹æ³•å¯¹åºåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œæ¡ä»¶æ£€æŸ¥ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºçœŸã€‚

// å˜éŸ³ç¬¦å·å¯ä»¥è¢«æ— é™æ·»åŠ 
let zalgo = "sÌÍ—ÍœÌ¼oÍ¯Í¥Ì’Í«ÍÍ…Ì Ì¦Ì¤oÌ½Í©ÌƒÍŸÍ…ÌºÌªÍ–Ì—nÍªÍ‘Ì¢Í”Í–Í‡Í‡Í‰Ì«Ì°"
zalgo.count // 4
zalgo.utf16.count // 36
// Unicode æƒ³è¦æ”¯æŒè¿™äº›ç½‘çº¢å­—ç¬¦ï¼Œå°±éœ€è¦æ”¯æŒå¤šç§ç¼–ç ç‚¹çš„ç»„åˆæ–¹å¼

// çº¯ ASCII å­—ç¬¦ä¸²ï¼ŒUnicode çš„å­—ä½åˆ†éš”è§„åˆ™ä¹Ÿä¼šäº§ç”Ÿå½±å“
// å¦‚ï¼šCR+LF æ˜¯å•ä¸ªå­—ç¬¦ï¼Œå›è½¦å’Œæ¢è¡Œçš„ç»„åˆï¼ŒWindows ç³»ç»Ÿå½“åšæ¢è¡Œä½¿ç”¨ï¼Œå•ä¸ªå­—ä½ç°‡ã€‚
let crlf = "\r\n"
crlf.count // 1
```
#### 2. é¢œæ–‡å­—
* Swift å¯¹é¢œæ–‡å­—è¯†åˆ«ä¸º1ä¸ªå­—ç¬¦ï¼Œå…¶ä»–çš„è¯­è¨€å¯èƒ½ä¸ºå¤šä¸ªã€‚
* é›¶å®½åº¦è¿æ¥ç¬¦ (zero-width joinerï¼ŒZWJ) (U+200D) å¯ä»¥å¯¹é¢œæ–‡å­—è¿›è¡Œè¿æ¥ç»„åˆæˆä¸€ä¸ªæ–°çš„é¢œæ–‡å­—ã€‚
* å¯¹åºåˆ—æ¸²æŸ“ä¸ºå•ä¸ªå­—å½¢çš„ä»»åŠ¡ç”±æ“ä½œç³»ç»Ÿå®Œæˆï¼Œ2017 å¹´ Apple å¹³å°åŒ…æ‹¬çš„å­—å½¢æ˜¯ Unicode æ ‡å‡†åˆ—å‡º
çš„ä¸€èˆ¬äº¤æ¢æ‰€æ¨èæ”¯æŒçš„åºåˆ—ï¼ˆRGIï¼‰çš„å­é›†ã€‚åˆ—è¡¨ä¸­çš„é¢œæ–‡å­—å¯ä»¥è¢«å¤šä¸ªå¹³å°å¹¿æ³›æ”¯æŒã€‚å½“é‡åˆ°è¯­æ³•æœ‰æ•ˆã€
ç³»ç»Ÿä¸­å´æ²¡æœ‰å¯ç”¨å­—å½¢æ—¶ï¼Œç³»ç»Ÿå­—ç¬¦æ¸²æŸ“ç³»ç»Ÿå°†ä¼šå›é€€ï¼Œå°†å…¶æ¯ä¸ªå­—ç¬¦æ¸²æŸ“ä¸ºå•ç‹¬å­—å½¢ã€‚ç”¨æˆ·è§†è§’ä¸ Swift
å•ä¸ªå­—ä½ç°‡äº§ç”Ÿå·®å¼‚ï¼Œè¿™ä¸å¸¸è§„ç¼–ç¨‹è¯­è¨€åˆ¤å®šå­—ç¬¦æ•°æ›´å¤šçš„æƒ…å†µç›¸åã€‚
* ç”±äºé¢œæ–‡å­—å’Œ Unicode çš„å¤æ‚æ€§ï¼Œéœ€è¦æˆ‘ä»¬å¯¹æ–‡æœ¬å¤„ç†ååˆ†ä¸¥è°¨ã€‚  

```
// Java å’Œ C# ä¸¤ä¸ªå­—ç¬¦é•¿ï¼ŒSwift ä¸º 1
let oneEmoji = "ğŸ˜‚" // U+1F602
oneEmoji.count // 1

let flags = "ğŸ‡§ğŸ‡·ğŸ‡³ğŸ‡¿"
flags.count // 2

// é€šè¿‡å­—ç¬¦ä¸²çš„ unicodeScalars è§†å›¾ï¼Œè§‚å¯Ÿ Unicode æ ‡é‡
flags.unicodeScalars.map {
"U+\(String($0.value, radix: 16, uppercase: true))"
}
// ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]

// å¤´åƒå’Œè‚¤è‰²ç»„åˆè§’è‰²
let skinTone = "ğŸ‘§ğŸ½" // ğŸ‘§ + ğŸ½
skinTone.count // 1

// ç”¨ Foundation çš„ API è¿›è¡Œ ICU å­—ç¬¦ä¸²å˜å½¢ï¼Œå°† Unicode æ ‡é‡è½¬æ¢ä¸ºå¯¹åº”çš„å®˜æ–¹ Unicode åå­—
extension StringTransform {
  static let toUnicodeName = StringTransform(rawValue: "Any-Name")
}
extension Unicode.Scalar {
  /// æ ‡é‡çš„ Unicode åå­—ï¼Œæ¯”å¦‚ "LATIN CAPITAL LETTER A".
  var unicodeName: String {
  // å¼ºåˆ¶è§£åŒ…æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºè¿™ä¸ªå˜å½¢ä¸å¯èƒ½å¤±è´¥
  let name = String(self).applyingTransform(.toUnicodeName, reverse: false)!
  // å˜å½¢åçš„å­—ç¬¦ä¸²ä»¥ "\\N{...}" ä½œä¸ºåå­—å¼€å¤´ï¼Œå°†å®ƒä»¬å»æ‰ã€‚
  let prefixPattern = "\\N{"
  let suffixPattern = "}"
  let prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.count : 0
  let suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.count : 0
  return String(name.dropFirst(prefixLength).dropLast(suffixLength))
  }
}
skinTone.unicodeScalars.map { $0.unicodeName }
// ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]

// å®¶åº­é¢œæ–‡å­— ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ = ç”·äºº ğŸ‘¨ + ZWJ + å¥³äºº ğŸ‘© + ZWJ + å¥³å­© ğŸ‘§ + ZWJ + ç”·å­© ğŸ‘¦
let family1 = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"
let family2 = "ğŸ‘¨\u{200D}ğŸ‘©\u{200D}ğŸ‘§\u{200D}ğŸ‘¦"
family1 == family2 // true

family1.count // 1
family2.count // 1
// å¥³æ€§æ¶ˆé˜²å‘˜ ğŸ‘©â€ğŸš’ = å¥³äºº ğŸ‘© + ZWJ + æ¶ˆé˜²è½¦ ğŸš’
// ç”·æ€§åŒ»æŠ¤å·¥ä½œè€… ğŸ‘¨â€âš•ï¸ = ç”·äºº ğŸ‘¨ + ZWJ + åŒ»ç–—ä¹‹ç¥é˜¿æ–¯å…‹å‹’åº‡ä¿„æ–¯çš„æƒæ– âš•

// åœ¨ 2017 å¹´ï¼Œå¸¦æœ‰è‚¤è‰²çš„å®¶åº­é¢œæ–‡å­—åœ¨å¤§å¤šæ•°å¹³å°ä¸Šä¼šè¢«æ¸²æŸ“ä¸ºå¤šä¸ªå­—å½¢
let family3 = "ğŸ‘±ğŸ¾\u{200D}ğŸ‘©ğŸ½\u{200D}ğŸ‘§ğŸ¿\u{200D}ğŸ‘¦ğŸ»"
// ä½†æ˜¯ Swift ä¾ç„¶è®¤ä¸ºå®ƒæ˜¯å•ä¸ªå­—ç¬¦
family3.count // 1

// å­—ç¬¦ç°‡å¯¹ä¸åŒçš„ç¼–ç å•å…ƒçš„ä½¿ç”¨ä¸ªæ•°ä¸åŒ
family1.count // 1
family1.utf16.count // 11
family1.utf8.count // 25
```
### ä¸‰ã€å­—ç¬¦ä¸²å’Œé›†åˆ
* Swift 2 å’Œ Swift 3 ä¸­ String æœ¬èº«é Collectionã€‚ç”±å­—ç¬¦ç»„æˆçš„é›†åˆç§»åŠ¨åˆ° Characterå±æ€§ä¸­ã€‚
å’Œ unicodeScalarsã€utf8ã€utf16 ç­‰è§†å›¾ç±»ä¼¼ï¼Œæ˜¯å­—ç¬¦ä¸²çš„ä¸€ç§è¡¨ç°å½¢å¼ã€‚
* Swift 4 ä¸ºäº†æé«˜æ˜“ç”¨æ€§å’Œé™ä½å­¦ä¹ éš¾åº¦ï¼Œå°† String è°ƒæ•´ä¸º Collectionã€‚Character ä¸ºäº†å‘å‰å…¼å®¹ï¼Œ
ä»ç„¶å­˜åœ¨ã€‚  

```
// ç¬¬ä¸€ä¸ªé›†åˆçš„æœ«å°¾å’Œç¬¬äºŒä¸ªé›†åˆçš„å¼€å¤´èƒ½å¤Ÿå½¢æˆä¸€ä¸ªå­—ä½ç°‡çš„è¯ï¼Œå®ƒä»¬å°±ä¸å†ç›¸ç­‰
// ä¸é›†åˆçš„ç‰¹æ€§ä¸ç¬¦
let flagLetterC = "ğŸ‡¨"
let flagLetterN = "ğŸ‡³"
let flag = flagLetterC + flagLetterN // ğŸ‡¨ğŸ‡³
flag.count // 1
flag.count == flagLetterC.count + flagLetterN.count // false
```
#### 1. åŒå‘ç´¢å¼•ï¼Œè€Œééšæœºè®¿é—®
String ä¸æ˜¯å¯ä»¥éšæœºè®¿é—®çš„é›†åˆï¼Œæ— æ³•é€šè¿‡å­—ç¬¦å¯¹åº”çš„ä½ç½®ï¼Œè®¡ç®— Unicode æ ‡é‡çš„ä¸ªæ•°ã€‚String åª
å®ç°äº† BidirectionalCollectionï¼Œå¯ä»¥ä»å­—ç¬¦ä¸²çš„å¤´å°¾ç§»åŠ¨ï¼Œæ¯æ¬¡è¿­ä»£ä¸€ä¸ªå­—ç¬¦ã€‚  
```
extension String {
  var allPrefixes1: [Substring] {
    return (0...self.count).map(self.prefix)
  }
}
let hello = "Hello"
hello.allPrefixes1 // ["", "H", "He", "Hel", "Hell", "Hello"]
// æ¯æ¬¡éƒ½è¦éå†è®¡ç®—é•¿åº¦ï¼Œå¤æ‚åº¦ O(nÂ²)ï¼Œæµªè´¹æ—¶é—´

extension String {
  var allPrefixes2: [Substring] {
    return [""] + self.indices.map { index in self[...index] }
  }
}
hello.allPrefixes2 // ["", "H", "He", "Hel", "Hell", "Hello"]
// å¤æ‚åº¦é™ä½åˆ° O(n)
```
#### 2. èŒƒå›´å¯æ›¿æ¢ï¼Œè€Œéå¯å˜
String æ»¡è¶³ RangeReplaceableCollection åè®®ï¼Œæ”¯æŒæ‰¾åˆ°å­—ç¬¦ä¸²ç´¢å¼•æ°å½“çš„èŒƒå›´åï¼Œè°ƒç”¨ replaceSubrange
æ–¹æ³•æ›¿æ¢å­—ç¬¦ä¸²ã€‚  
```
var greeting = "Hello, world!"
if let comma = greeting.index(of: ",") {
  greeting[..<comma] // Hello
  greeting.replaceSubrange(comma..., with: " again.")
}
greeting // Hello again.
```
### å››ã€å­—ç¬¦ä¸²ç´¢å¼•
* å­—ç¬¦ä¸²ç´¢å¼•ä¸èƒ½é€šè¿‡ä¸‹æ ‡æ“ä½œï¼Œå› ä¸ºä¸‹æ ‡è®¿é—®ä¸èƒ½å†å¸¸æ•°æ—¶é—´å†…å®Œæˆï¼ˆ Collection åè®®çš„ç›´è§‚è¦æ±‚ï¼‰,
å¿…é¡»å¯¹å‰é¢çš„å­—èŠ‚è¿›è¡Œæ£€æŸ¥ï¼ˆç¡®å®šå­—ç¬¦ç°‡ä¸­ç¼–ç å•å…ƒæ•°ç›®ï¼‰ã€‚
* å¯ä»¥æ ¹æ®å·²æœ‰ç´¢å¼•å‘å‰åå­—ç¬¦è¿­ä»£ï¼Œä¸ç”¨å¯¹å­—èŠ‚æ£€æŸ¥ï¼Œåè€Œæ›´é«˜æ•ˆã€‚  

```
// è¿”å›ä¸‹ä¸€ä¸ªå­—ç¬¦çš„ç´¢å¼•
let s = "abcdef"
let second = s.index(after: s.startIndex)
s[second] // b

// æ­¥è¿› 4 ä¸ªå­—ç¬¦
let sixth = s.index(second, offsetBy: 4)
s[sixth] // f

// ä½¿ç”¨ limitedBy: å‚æ•°ï¼Œé˜²æ­¢è¶…è¿‡æœ«å°¾å­—ç¬¦ä¸²é£é™©ï¼Œè¶…è¿‡æ—¶ï¼Œè¿”å› nil
let safeIdx = s.index(s.startIndex, offsetBy: 400, limitedBy: s.endIndex)
safeIdx // nil

// æå–å‰ 4 ä¸ªå­—ç¬¦çš„ä¼˜åŒ–å†™æ³•
s[..<s.index(s.startIndex, offsetBy: 4)] // abcd
s.prefix(4) // abcd

// éå†æ¯ä¸ªå­—ç¬¦çš„åºå·
for (i, c) in "hello".enumerated() {
  print("\(i): \(c)")
}

// æŸ¥æ‰¾å¦ä¸ªç‰¹å®šå­—ç¬¦
var hello = "Hello!"
if let idx = hello.index(of: "!") {
  hello.insert(contentsOf: ", world", at: idx)
}
hello // Hello, world!
// insert(contentsOf:) æ”¯æŒ String å’Œ å­—ç¬¦ç»„æˆçš„æ•°ç»„
```
### äº”ã€å­å­—ç¬¦ä¸²
* SubString åœ¨ Swift 4 ä¸­æ–°åŠ å…¥çš„ã€‚
* Substring å’Œ ArraySlice å¾ˆç›¸ä¼¼ï¼Œä»¥ä¸åŒèµ·å§‹å’Œç»“æŸç´¢å¼•çš„å¯¹åŸå­—ç¬¦ä¸²çš„åˆ‡ç‰‡ã€‚
* å­å­—ç¬¦ä¸²å’ŒåŸå­—ç¬¦ä¸²å…±äº«æ–‡æœ¬å­˜å‚¨ï¼Œä½¿å­—ç¬¦ä¸²åˆ‡ç‰‡éå¸¸é«˜æ•ˆï¼Œå¯¹æå–é•¿å­—ç¬¦ä¸²å„ä¸ªéƒ¨åˆ†çš„å¾ªç¯éå¸¸é‡è¦ã€‚
å¦‚ï¼šæŸ¥æ‰¾æŸå•è¯å‡ºç°çš„ä½ç½®ï¼Œè§£æ CSV æ–‡ä»¶ç­‰ã€‚

```
// åˆ›å»º firstWord å¹¶ä¸ä¼šå¯¼è‡´æ˜‚è´µçš„å¤åˆ¶æ“ä½œæˆ–è€…å†…å­˜ç”³è¯·
let sentence = "The quick brown fox jumped over the lazy dog."
let firstSpace = sentence.index(of: " ") ?? sentence.endIndex
let firstWord = sentence[..<firstSpace] // The
type(of: firstWord) // Substring

extension Collection where Element: Equatable {
  public func split(separator: Element, maxSplits: Int = Int.max,
  omittingEmptySubsequences: Bool = true) -> [SubSequence]
}

let poem = """
Over the wintry
forest, winds howl in rage
with no leaves to blow.
"""
let lines = poem.split(separator: "\n")
// ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]
type(of: lines) // Array<Substring>

// æŒ‰è¯æŠ˜è¡Œç®—æ³•
extension String {
  func wrapped(after: Int = 70) -> String {
    var i = 0
    let lines = self.split(omittingEmptySubsequences: false) {
      character in
      // æ•è·å½“å‰è¡Œä¸­çš„å­—ç¬¦æ•°
      switch character {
        case "\n", " " where i >= after:
          i = 0
          return true
        default:
          i += 1
          return false
      }
    }
    return lines.joined(separator: "\n")
  }
}
sentence.wrapped(after: 15)
/*
The quick brown
fox jumped over
the lazy dog.
*/

extension Collection where Element: Equatable {
  func split<S: Sequence>(separators: S) -> [SubSequence]
  where Element == S.Element
  {
    return split { separators.contains($0) }
  }
}

"Hello, world!".split(separators: ",! ") // ["Hello", "world"]
```
#### 1. StringProtocol
* SubString å’Œ String éƒ½éµå®ˆ StringProtocol é€šç”¨åè®®ï¼Œæ¥å£å‡ ä¹å®Œå…¨ä¸€æ ·ï¼Œå¯ä»¥åŒæ ·ä½¿ç”¨ã€‚
* å­å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡ä¸€æ ·ï¼Œç”¨äºçŸ­æœŸå­˜å‚¨ï¼Œä¸ºäº†é¿å…å¤åˆ¶çš„æ˜‚è´µã€‚æ“ä½œç»“æŸåï¼Œå¦‚æœæƒ³è¦ç»§ç»­ä½¿ç”¨ï¼Œéœ€è¦åˆ›å»º
æ–°çš„Stringï¼Œé˜²æ­¢æŒç»­æŒæœ‰åŸå­—ç¬¦ä¸²ï¼Œå¯¼è‡´å†…å­˜æ— æ³•é‡Šæ”¾ï¼Œç”šè‡³é•¿æœŸæŒæœ‰å¯¼è‡´æ³„éœ²ã€‚
* æœ€å¥½ä¸è¦è®²æ‰€æœ‰ API ä»æ¥å— String å®ä¾‹è½¬ä¸º StringProtocolï¼Œå› ä¸ºææœ‰å¯èƒ½ä½¿ç”¨åˆ°å­å­—ç¬¦ä¸²ï¼Œè€Œ
æ²¡æœ‰è¿›ä¸€æ­¥æ³›å‹åŒ–åˆ° Sequence æˆ– Collection å±‚çº§çš„APIï¼Œå¦‚ï¼š æ ‡å‡†åº“ä¸­çš„ joined æ–¹æ³•ã€‚
* å¯¹ String è¿›è¡Œæ‰©å±•æ–°åŠŸèƒ½æ—¶ï¼Œå¯ä»¥æ”¾åœ¨ StringProtocol ä¸­ï¼Œä¿æŒä¸ SubString çš„ç»Ÿä¸€æ€§ã€‚
* ä¸è¦å£°æ˜ä»»æ„æ–°çš„éµå®ˆ StringProtocol åè®®çš„ç±»å‹ã€‚åªæœ‰æ ‡å‡†åº“ä¸­çš„ String å’Œ Substring
ç±»å‹æ˜¯æœ‰æ•ˆçš„é€‚é…ç±»å‹ã€‚  

```
func lastWord(in input: String) -> String? {
  // å¤„ç†è¾“å…¥ï¼Œæ“ä½œå­å­—ç¬¦ä¸²
  let words = input.split(separators: [",", " "])
  guard let lastWord = words.last else { return nil }
  // è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶è¿”å›
  return String(lastWord)
}
lastWord(in: "one, two, three, four, five") // Optional("five")

// ä½¿ç”¨åŸå­—ç¬¦ä¸²å¼€å¤´ç´¢å¼•å’Œç»“å°¾ç´¢å¼•ä½œä¸ºèŒƒå›´çš„å­å­—ç¬¦ä¸²
let substring = sentence[...]

// Swift 4 ä¸ºå…ƒç´ æ»¡è¶³ StringProtocol çš„åºåˆ—æ·»åŠ äº†ä¸€ä¸ª joined çš„é‡è½½æ–¹æ³•
extension Sequence where Element: StringProtocol {
  /// å°†ä¸€ä¸ªåºåˆ—ä¸­çš„å…ƒç´ ä½¿ç”¨ç»™å®šçš„åˆ†éš”ç¬¦æ‹¼æ¥èµ·ä¸ºæ–°çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›
  public func joined(separator: String = "") -> String
}

// å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ç±»å‹
let commaSeparatedNumbers = "1,2,3,4,5"
let numbers = commaSeparatedNumbers
.split(separator: ",").flatMap { Int($0) }
// [1, 2, 3, 4, 5]
```
### å…­ã€ç¼–ç å•å…ƒè§†å›¾
* String æä¾›ä¸‰ç§è§†å›¾ï¼šunicodeScalarsï¼Œutf16ï¼Œutf8ï¼Œå’Œ String ä¸€æ ·åŒå‘ç´¢å¼•é›†åˆã€‚æ”¯æŒå·²ç†Ÿæ‚‰
çš„æ“ä½œï¼Œå…±äº«å­—ç¬¦ä¸²æœ¬èº«å­˜å‚¨ï¼Œç±»ä¼¼å­å­—ç¬¦ä¸²ï¼Œæ˜¯ä¸€ç§ç®€å•çš„å‘ˆç°åº•å±‚å­—èŠ‚çš„æ–¹å¼ã€‚
* ä½¿ç”¨åœºæ™¯ï¼šéœ€è¦ç¼–ç å•å…ƒä¸º UTF-8 ç¼–ç çš„ç½‘é¡µæ¸²æŸ“ã€å’Œåªæ¥å—æŸç§ç‰¹å®šç¼–ç çš„é Swift API è¿›è¡Œäº¤äº’ã€
éœ€è¦å­—ç¬¦ä¸²æŸç§ç‰¹å®šæ ¼å¼ä¸‹çš„ä¿¡æ¯ç­‰ã€‚
* é€šè¿‡ç¼–ç å•å…ƒè§†å›¾æ“ä½œç¼–ç å•å…ƒæ¯”æ“ä½œå®Œæ•´å­—ç¬¦æ›´å¿«ï¼Œé¿å…äº† Unicode å­—ä½åˆ†å‰²ç®—æ³•å’Œå­—ä½ç°‡å¼€å¤´ç¡®å®šæ—¶ï¼Œ
é¢å¤–å‘å‰è¿›è¡ŒæŸ¥çœ‹ã€‚Swift 4.0 å¯¹ Character æ–¹å¼éå† String æ¯” Swift 3.0 å¿«å¾—å¤šã€‚åœ¨æé€Ÿå‰ï¼Œ
è¦è¿›è¡Œæ€§èƒ½æµ‹é‡ï¼Œé¿å…å¾—ä¸å¿å¤±ã€‚å¦‚ï¼šå¯ä»¥ç”¨ UTF-16 è§†å›¾è§£æ JSONï¼Œå› ä¸ºè§£æå™¨åªå…³æ³¨é€—å·ã€å¼•å·ã€æ‹¬å·
ä¹‹ç±»çš„å­—ç¬¦ï¼Œå¯ä»¥ç”¨å•ä¸ªç¼–ç å•å…ƒè¡¨ç¤ºï¼Œå¤æ‚çš„é¢œæ–‡å­—ä¹‹ç±»ä¸ä¼šäº§ç”Ÿå½±å“ã€‚å¦‚æœè¦æŸ¥æ‰¾å•è¯çš„ä½ç½®ï¼Œå°±æ— æ³•
ä½¿ç”¨ç¼–ç è§†å›¾å•å…ƒäº†ã€‚  

```
// Twitter å®¢æˆ·ç«¯: API æ¥å— UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œä½† Twitter çš„å­—ç¬¦è®¡ç®—ç®—æ³•åŸºäº NFC å½’ä¸€åŒ–çš„ç¼–ç ç‚¹ã€‚
// æƒ³è¦ä¸ºä½ çš„ç”¨æˆ·æ˜¾ç¤ºè¿˜å¯ä»¥è¾“å…¥å¤šå°‘å­—ç¬¦
let tweet = "Having â˜•ï¸ in a cafe\u{301} in ğŸ‡«ğŸ‡· and enjoying the â˜€ï¸."
let characterCount = tweet
.precomposedStringWithCanonicalMapping
.unicodeScalars.count
// 46
// (NFC å½’ä¸€å¯ä»¥å¯¹åŸºç¡€å­—æ¯åŠåˆå¹¶æ ‡è®°è¿›è¡Œè½¬æ¢ï¼Œæ¯”å¦‚ "cafe\u{301}" ä¸­çš„ e å’Œå˜éŸ³ç¬¦å¯ä»¥è¢«æ­£ç¡®é¢„ç»„èµ·ã€‚
// precomposedStringWithCanonicalMapping å±æ€§åœ¨ Foundation ä¸­å®šä¹‰ã€‚

// å­—ç¬¦ä¸²çš„ UTF-8 å­—èŠ‚ä¼ é€’ç»™ä»»ä¸€æ¥å—ä¸€ä¸²å­—èŠ‚çš„å…¶ä»– API
let utf8Bytes = Data(tweet.utf8)
utf8Bytes.count // 62

// utf8 é›†åˆä¸åŒ…å«å°¾éƒ¨çš„ null å­—èŠ‚ï¼Œæƒ³è¦ä»¥ null ç»“å°¾ï¼Œéœ€è¦ä½¿ç”¨ String çš„ withCString
æ–¹æ³•æˆ–è€… utf8CString å±æ€§ã€‚
let nullTerminatedUTF8 = tweet.utf8CString
nullTerminatedUTF8.count // 63
```
#### 1. ééšæœºè®¿é—®
*  Swift 3 ä¸­ String.UTF16View è§†å›¾éµå®ˆ RandomAccessCollection (éœ€å¼•å…¥ Foundation)ï¼Œ
å¯ä»¥éšæœºè®¿é—®ã€‚å› ä¸º String å†…éƒ¨å†…å­˜æ˜¯ä½¿ç”¨ UTF-16 æˆ– ASCII ç è¡¨ç¤ºçš„ï¼Œç¬¬ n ä¸ª ç¼–ç å•å…ƒå­˜å‚¨åœ¨
å†…å­˜ç¼“å†²åŒºçš„ç¬¬ n ä¸ªä½ç½®ä¸Šã€‚Swift 4.0 å†…å­˜å­˜å‚¨è™½ç„¶æ˜¯ UTF-16ï¼Œä½†æˆä¸ºäº†ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼ŒSwift å›¢é˜Ÿ
æƒ³è¦ä¿ç•™åœ¨æœªæ¥æ·»åŠ å…¶ä»–å­˜å‚¨å±æ€§çš„å¯èƒ½æ€§ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨éšæœºè®¿é—®ç®—æ³•ã€‚
* Swift 4.0 å¯ä»¥å°† UTF-8 æˆ– UTF-16 è§†å›¾è½¬åŒ–ä¸ºæ•°ç»„ï¼Œå¦‚ï¼šArray(str.utf16)ï¼Œä½†ç‰ºç‰²äº† Unicode
çš„æ­£ç¡®æ€§  

#### 2. å…±äº«ç´¢å¼•
å­—ç¬¦ä¸²å’Œä»–ä»¬çš„è§†å›¾å…±äº«åŒæ ·çš„ç´¢å¼•ç±»å‹ï¼ŒString.Indexï¼Œå¯ä»¥ç”¨åœ¨è§†å›¾çš„ä¸‹æ ‡è®¿é—®ä¸­ã€‚  

```
// ä½¿ç”¨ Index é€šè¿‡è§†å›¾è®¿é—®ï¼ŒæŒ‡å‘è§†å›¾ä¸­ç¬¬ä¸€ä¸ªæ ‡é‡ï¼ŒÃ© = e + ç»„åˆå˜éŸ³ç¬¦å·
let pokemon = "Poke\u{301}mon" // PokeÌmon
if let index = pokemon.index(of: "Ã©") {
  let scalar = pokemon.unicodeScalars[index] // e
  String(scalar) // e
}

let family = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"
// This initializer creates an index at a UTF-16 offset
let someUTF16Index = String.Index(encodedOffset: 2)
//family[someUTF16Index] // å´©æºƒï¼Œæ— æ•ˆçš„ç´¢å¼•

// å˜éŸ³ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­æ²¡æœ‰è‡ªå·±çš„ä½ç½®
if let accentIndex = pokemon.unicodeScalars.index(of: "\u{301}") {
  accentIndex.samePosition(in: pokemon) // nil
}

let noCharacterBoundary = family.utf16.index(family.utf16.startIndex,
offsetBy: 3)
// åœ¨å­—ç¬¦è§†å›¾ä¸­ï¼Œå¹¶éæœ‰æ•ˆä½ç½®
noCharacterBoundary.encodedOffset // 3

// Swift 4.0 bugï¼šé”™è¯¯ï¼if let åº”è¯¥å¤±è´¥ï¼Œå› ä¸ºæºç´¢å¼•ä¸æ˜¯å­—ç¬¦è¾¹ç•Œ
if let idx = String.Index(noCharacterBoundary, within: family) {
  // ä¸‹æ ‡è®¿é—®è¿”å›äº†ä¸å®Œæ•´çš„å­—ç¬¦ï¼Œè¿™ä¸åº”è¯¥å‘ç”Ÿ
  family[idx] // ğŸ‘©â€ğŸ‘§â€ğŸ‘¦
}

extension String.Index {
  func samePositionOnCharacterBoundary(in str: String) -> String.Index {
    let range = str.rangeOfComposedCharacterSequence(at: self)
    return range.lowerBound
  }
}
let validIndex = noCharacterBoundary.samePositionOnCharacterBoundary(in: family)
// æ­£ç¡®
family[validIndex] // ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦
```
### ä¸ƒã€å­—ç¬¦ä¸²å’Œ Foundation
* Swift çš„ String ç±»å‹å’Œ Foundation çš„ NSString æœ‰ç€éå¸¸å¯†åˆ‡çš„å…³ç³»ã€‚å½“ä½ å¼•å…¥ Foundation å
ï¼ŒNSString çš„æˆå‘˜å°±éƒ½å¯ä»¥åœ¨ String å®ä¾‹ä¸Šè¿›è¡Œè®¿é—®ã€‚ä½†æ˜¯åœ¨å‘½åä¸Šçš„é‡å å’Œå¯¹æ–°äººæ¥è¯´æœ‰äº›è¿·æƒ‘ã€‚
* æ‰€æœ‰å¯¼å…¥åˆ° String çš„ NSString æˆå‘˜å¯ä»¥åœ¨ Swift æºç ä»“åº“çš„ NSStringAPI.swift æ–‡ä»¶ä¸­æ‰¾åˆ°ã€‚  

```
// å°†æŒ‰ç…§å•è¯æ¥è¿­ä»£å­—ç¬¦ä¸²ï¼Œå¯¹æ¯ä¸ªæ‰¾åˆ°çš„å•è¯ï¼Œå›è°ƒé—­åŒ…éƒ½ä¼šè¢«è°ƒç”¨ä¸€æ¬¡
let sentence = """
The quick brown fox jumped \
over the lazy dog.
"""
var words: [String] = []
sentence.enumerateSubstrings(in: sentence.startIndex..., options: .byWords)
{ (word, range, _, _) in
  guard let word = word else { return }
  words.append(word)
}
words
// ["The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]
```
#### 1. å…¶ä»–åŸºäºå­—ç¬¦ä¸²çš„ Foundation API
ç¼–è¯‘å™¨ä¸º NSString API å’Œ Swift String å®Œæˆäº†å¤§éƒ¨åˆ†æ¡¥æ¥å·¥ä½œï¼Œä½†æ˜¯æœ‰ä¸€éƒ¨åˆ†å°šæœªå°è£…ï¼Œå¦‚ï¼š
Foundation ä¸­çš„ NSAttributedStringã€NSRegularExpression ã€ NSLinguisticTaggerã€‚
* NSAttributedString å¯¹åº”ä¸å¯å˜å­—ç¬¦ä¸²ï¼ŒNSMutableAttributedString å¯¹åº”å¯å˜å­—ç¬¦ä¸²ã€‚
å’Œ Swift æ ‡å‡†åº“ä¸­éµå®ˆå€¼è¯­ä¹‰çš„é›†åˆä¸åŒï¼Œå®ƒä»¬éƒ½éµå®ˆå¼•ç”¨è¯­ä¹‰ã€‚
* è™½ç„¶ NSAttributedString çš„ API åŸæ¥æ¥å—çš„æ˜¯ NSStringï¼Œä½†æ˜¯å®ƒç°åœ¨æ¥å—ä¸€ä¸ª Swift.Stringã€‚
ä¸è¿‡æ•´ä¸ª API çš„åŸºç¡€è¿˜æ˜¯ NSString çš„ UTF-16 ç¼–ç å•å…ƒé›†åˆçš„æ¦‚å¿µã€‚  

```
public struct NSRange {
  public var location: Int
  public var length: Int
}

let text = "ğŸ‘‰ Click here for more info."
let linkTarget =
URL(string: "https://www.youtube.com/watch?v=DLzxrzFCyOs")!
// å°½ç®¡ä½¿ç”¨äº† `let`ï¼Œå¯¹è±¡ä¾ç„¶æ˜¯å¯å˜çš„ (å¼•ç”¨è¯­ä¹‰)
let formatted = NSMutableAttributedString(string: text)
// ä¿®æ”¹æ–‡æœ¬çš„éƒ¨åˆ†å±æ€§
if let linkRange = formatted.string.range(of: "Click here") {
  // å°† Swift èŒƒå›´è½¬æ¢ä¸º NSRange
  // æ³¨æ„èŒƒå›´çš„èµ·å§‹å€¼ä¸º 3ï¼Œå› ä¸ºæ–‡æœ¬å‰é¢çš„é¢œæ–‡å­—æ— æ³•åœ¨å•ä¸ª UTF-16 ç¼–ç å•å…ƒä¸­è¢«è¡¨ç¤º
  let nsRange = NSRange(linkRange, in: formatted.string) // {3, 10}
  // æ·»åŠ å±æ€§
  formatted.addAttribute(.link, value: linkTarget, range: nsRange)
}

// æŸ¥è¯¢å•è¯ "here" å¼€å§‹çš„å±æ€§
if let queryRange = formatted.string.range(of: "here"),
// è·å–åœ¨ UTF-16 è§†å›¾ä¸­çš„ç´¢å¼•
let utf16Index = String.Index(queryRange.lowerBound,
within: formatted.string.utf16)
{
  // å°†ç´¢å¼•è½¬ä¸º UTF-16 æ•´æ•°åç§»é‡
  let utf16Offset = utf16Index.encodedOffset
  // å‡†å¤‡ç”¨æ¥æ¥æ”¶å—å±æ€§å½±å“çš„èŒƒå›´ (effectiveRange) çš„ NSRangePointer
  var attributesRange = UnsafeMutablePointer<NSRange>.allocate(capacity: 1)
  defer {
    attributesRange.deinitialize(count: 1)
    attributesRange.deallocate(capacity: 1)
  }
  // æ‰§è¡ŒæŸ¥è¯¢
  let attributes = formatted.attributes(at: utf16Offset,
  effectiveRange: attributesRange)
  attributesRange.pointee // {3, 10}
  // å°† NSRange è½¬æ¢å› Range<String.Index>
  if let effectiveRange = Range(attributesRange.pointee, in: formatted.string) {
    // å±æ€§æ‰€è·¨è¶Šçš„å­å­—ç¬¦ä¸²
    formatted.string[effectiveRange] // Click here
  }
}
```
#### 2. å­—ç¬¦èŒƒå›´  
```
// as Character è½¬ä¸ºå­—ç¬¦ï¼Œå› ä¸ºå­—ç¬¦ä¸²å­—é¢é‡é»˜è®¤ä¸º String
let lowercaseLetters = (â€œaâ€ as Character)â€¦â€œz
// Character å¹¶æ²¡æœ‰å®ç° Strideable åè®®ï¼Œä¸å¯æ•°
for c in lowercaseLetters { // é”™è¯¯ â€¦ }

lowercaseLetters.contains("A") // false
// Swift é»˜è®¤çš„å­—ç¬¦é¡ºåºä¸­ï¼Œå­—æ¯ Ã© çš„é¡ºåºæ˜¯åœ¨ e å’Œ f ä¹‹é—´
lowercaseLetters.contains("Ã©") // true

// è¿½åŠ Unicode.Scalar éµå®ˆ Strideable
// å¿½ç•¥äº† 0xD800 å’Œ 0xDFFF ä¹‹é—´çš„ä»£ç†ç¼–ç ç‚¹ä¸æ˜¯æœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼
// æ„å»ºä¸€ä¸ªä¸è¿™ä¸ªåŒºåŸŸæœ‰é‡åˆçš„èŒƒå›´ï¼Œè¢«è®¤ä¸ºæ˜¯ç¨‹åºå‘˜çš„é”™è¯¯
extension Unicode.Scalar: Strideable {
  public typealias Stride = Int
  public func distance(to other: Unicode.Scalar) -> Int {
    return Int(other.value) - Int(self.value)
  }
  public func advanced(by n: Int) -> Unicode.Scalar {
    return Unicode.Scalar(UInt32(Int(value) + n))!
  }
}

let lowercase = ("a" as Unicode.Scalar)..."z"
Array(lowercase.map(Character.init))
/*
["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
"o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
*/
```
#### 3. CharacterSet
* CharacterSet æœ¬è´¨ä¸Šæ˜¯ UnicodeScalarSetï¼Œè¡¨ç¤ºä¸€ç³»åˆ— Unicode æ ‡é‡çš„æ•°æ®ç»“æ„ä½“ï¼Œå®Œå…¨å’Œ Character ç±»å‹ä¸å…¼å®¹ã€‚
* CharacterSet æä¾›äº†ä¸€äº›å·¥å‚åˆå§‹åŒ–æ–¹æ³•ï¼Œæ¯”å¦‚ .alphanumerics æˆ–è€… .whitespacesAndNewlinesã€‚
å®ƒä»¬å¤§éƒ¨åˆ†å¯¹åº”ç€Unicode å­—ç¬¦åˆ†ç±» (æ¯ä¸ªç¼–ç ç‚¹éƒ½è¢«èµ‹äºˆäº†ä¸€ä¸ªåˆ†ç±»ï¼Œæ¯”å¦‚â€œå­—æ¯â€æˆ–è€…â€œéç©ºæ ¼æ ‡è®°â€)ã€‚
è¿™äº›åˆ†ç±»è¦†ç›–äº†æ‰€æœ‰çš„æ–‡å­—ï¼Œä¸å•å•æ˜¯ ASCII æˆ–è€… Latin-1ï¼Œæ‰€ä»¥é€šå¸¸æ¥è¯´è¿™äº›é¢„å…ˆå®šä¹‰çš„é›†åˆä¸­çš„æˆå‘˜
ä¸ªæ•°éƒ½éå¸¸åºå¤§ã€‚è¿™ä¸ªç±»å‹éµå®ˆ SetAlgebra åè®®ï¼Œè¯¥åè®®ä¸­åŒ…å«ä¸€äº›é›†åˆæ“ä½œï¼Œæ¯”å¦‚æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨é›†åˆå†…ï¼Œ
æˆ–è€…æ„å»ºå¹¶é›†æˆ–äº¤é›†ç­‰ã€‚CharacterSet æ²¡æœ‰å®ç° Sequence æˆ–è€… Collectionï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•è½»æ˜“åœ°æ£€æŸ¥
é›†åˆä¸­å…ƒç´ çš„æ•°é‡ï¼Œä¹Ÿä¸èƒ½å¯¹é›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œè¿­ä»£ã€‚

```
// å¥³æ¶ˆé˜²å‘˜çš„é¢œæ–‡å­—å®é™…ä¸Šæ˜¯å¥³äºº + ZWJ + æ¶ˆé˜²è½¦
let favoriteEmoji = CharacterSet("ğŸ‘©â€ğŸš’ğŸ‘¨â€ğŸ¤".unicodeScalars)
// é”™è¯¯ï¼è¿˜æ˜¯æ­£ç¡®ï¼Ÿ
favoriteEmoji.contains("ğŸš’") // true

// é€šè¿‡åœ¨ UnicodeScalarView ä¸Šåˆ©ç”¨ CharacterSet å®ç°äº†å°†å­—ç¬¦ä¸²åˆ†å‰²ä¸ºå•è¯
extension String {
  func words(with charset: CharacterSet = .alphanumerics) -> [Substring] {
    return self.unicodeScalars.split {
      !charset.contains($0)
    }.map(Substring.init)
  }
}
let code = "struct Array<Element>: Collection { }"
code.words() // ["struct", "Array", "Element", "Collection"]
// words ä¸­çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ä¾ç„¶åªæ˜¯åŸå­—ç¬¦ä¸²çš„è§†å›¾ï¼Œæ‰€ä»¥å®ƒè¿˜æ˜¯ä¼šæ¯” components(separatedBy:) é«˜æ•ˆå¾—å¤š
// è¿™ä¸ªæ–¹æ³•å°†è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œå¤åˆ¶ã€‚
```
### å…«ã€String å’Œ Character çš„å†…éƒ¨ç»“æ„
* å’Œæ ‡å‡†åº“ä¸­çš„å…¶ä»–é›†åˆç±»å‹ä¸€æ ·ï¼Œå­—ç¬¦ä¸²ä¹Ÿæ˜¯ä¸€ä¸ªå®ç°äº†å†™æ—¶å¤åˆ¶çš„å€¼è¯­ä¹‰ç±»å‹ã€‚
* åœ¨ Swift 4.0 ä¸­ï¼ŒString åœ¨å†…å­˜ä¸­çš„è¡¨ç¤ºï¼Œä½¿ç”¨çš„æ˜¯ 8 ä½ ASCII (å¦‚æœå­—ç¬¦ä¸²åªåŒ…æ‹¬ ASCII å­—ç¬¦)
æˆ–è€… UTF-16 (å¦‚æœå­˜åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªé ASCII å­—ç¬¦)ã€‚å¦‚æœä½ éœ€è¦æœ€å¤§åŒ–æ€§èƒ½ï¼Œä½ ä¹Ÿè®¸ä¼šç”¨åˆ°è¿™ä¸ªçŸ¥è¯† -
æ¯”å¦‚å¯¹é ASCII çš„æ•°æ®ï¼Œå¯¹ UTF-16 è§†å›¾è¿›è¡Œéå†ä¼šæ¯”ä½¿ç”¨ UTF-8 æˆ–è€… Unicode æ ‡é‡è§†å›¾è¦ç¨å¿«ä¸€äº›ã€‚
* ä» Objective-C æ¥æ”¶åˆ°çš„å­—ç¬¦ä¸²èƒŒåæ˜¯ä¸€ä¸ª NSString æ—¶ï¼Œä¸ºäº†è®©æ¡¥æ¥å°½å¯èƒ½é«˜æ•ˆï¼ŒNSString
 ç›´æ¥æ‰®æ¼”äº† Swift å­—ç¬¦ä¸²çš„ç¼“å†²åŒºï¼Œåœ¨è¢«æ”¹å˜æ—¶ï¼Œå°†ä¼šè¢«è½¬æ¢ä¸ºåŸç”Ÿçš„ Swift å­—ç¬¦ä¸²ã€‚  

#### 1. Character ç±»å‹
* Character ä»£è¡¨ä¸€ä¸ªå¯èƒ½ä¼šæ˜¯ä»»æ„é•¿åº¦çš„æ ‡é‡åºåˆ—ã€‚ä»»æ„é•¿åº¦çš„å­—ä½ç°‡æœ¬èº«å°±æ˜¯ä¸€ç§ç‰¹æ®Šæƒ…å†µ - ç»å¤§å¤š
æ•°çš„å­—ç¬¦åªä¼šæœ‰å‡ ä¸ªå­—èŠ‚é•¿ã€‚å¯¹äºä¸€èˆ¬æƒ…å†µï¼Œå°†ä¸è¶…è¿‡ä¸€å®šé•¿åº¦çš„æ„æˆå­—ç¬¦çš„å­—èŠ‚è¿›è¡Œå†…è”å­˜å‚¨ï¼Œè€Œåªå¯¹é‚£äº›
ä¸å¸¸è§çš„å¤§çš„å­—ä½ç°‡å¼€è¾Ÿå•ç‹¬çš„ç¼“å†²åŒºï¼Œä¼šæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¼˜åŒ–ã€‚  
* .smallUTF16 ç”¨æ¥è¡¨ç¤ºé‚£äº› UTF-16 è¡¨ç¤ºä¸‹é•¿åº¦å°‘äºç­‰äº 63 bit çš„å­—ä½ç°‡(Builtin.Int63 æ˜¯ä¸€
  ä¸ª LLVM å†…éƒ¨ç±»å‹ï¼Œå®ƒåªåœ¨æ ‡å‡†åº“ä¸­å¯ç”¨)ã€‚63 bit è¿™ä¸ªä¸å¯»å¸¸çš„å°ºå¯¸æ˜¯ç»è¿‡ç²¾å¿ƒæŒ‘é€‰çš„ï¼Œå®ƒè®© Character
  å®ä¾‹èƒ½å¤Ÿè¢«æ”¾åˆ°å•ä¸ªçš„æœºå™¨å­— (machine word) ä¸­ã€‚å‰©ä¸‹çš„ 1 bit æ­£å¥½å¯ä»¥ç”¨æ¥å¯¹ä¸¤ç§æšä¸¾æˆå‘˜è¿›è¡ŒåŒºåˆ«ã€‚
* Swift ç¼–è¯‘å™¨é¢å¤–é©»åœ¨ (extra inhabitants) çš„æŠ€æœ¯ï¼Œæ¥å°†æšä¸¾ case çš„æ ‡å¿—å­˜æ”¾åˆ°å…³è”å€¼ä¸­ã€‚é¢
å¤–é©»åœ¨æŠ€æœ¯å°†å¯ä»¥è®©è¿™ä¸ªæšä¸¾ä½¿ç”¨é‚£äº›å¯¹äºæŸä¸ªç‰¹å®šç±»å‹æ¥è¯´æ— æ•ˆçš„ bit ä½æ¥æ¥å­˜æ”¾å†…å®¹ã€‚è¿™é¡¹æŠ€æœ¯èƒ½å¤Ÿå¥
æ•ˆçš„å¦ä¸€ä¸ªåŸå› æ˜¯å¯¹äº .large çš„æƒ…å†µ (å®ƒå®é™…å­˜æ”¾çš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆ) æ¥è¯´ï¼ŒæŒ‡é’ˆå¯¹é½è§„åˆ™æ„å‘³ç€ä¸€ä¸ªæœ‰æ•ˆçš„
å¯¹è±¡æŒ‡é’ˆçš„æŸäº› bit å°†è‚¯å®šä¸º 0ï¼Œæ‰€ä»¥åœ¨å…¶ä¸­ä¹Ÿä¼šæœ‰ä¸€äº›ç©ºç™½çš„ bit å¯ä»¥åŠ ä»¥åˆ©ç”¨ã€‚
* Apple åœ¨å‡ å¹´å‰ä¸º NSString å¼•å…¥è¿‡ä¸€ä¸ªè¿™æ ·çš„ä¼˜åŒ–ï¼Œé‚£æ—¶å°‘äº 7 ä¸ª ASCII å­—ç¬¦çš„çŸ­å­—ç¬¦ä¸²è¢«ç›´æ¥
å­˜å‚¨åˆ°äº†ä¸€ä¸ªæ ‡ç­¾æŒ‡é’ˆ (tagged pointer) ä¸­ï¼Œè¿™é¿å…äº†é¢å¤–çš„å †ä¸Šçš„å†…å­˜ç”³è¯·ã€‚  

```
// Character çš„å®é™…å®šä¹‰
public struct Character {
  internal enum Representation {
    case smallUTF16(Builtin.Int63)
    case large(Buffer)
  }
  internal var _representation: Representation
}

MemoryLayout<Character>.size // 8
```
### ä¹ã€ç®€å•çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å™¨
```
/// ç®€å•çš„æ­£åˆ™è¡¨è¾¾å¼ç±»å‹ï¼Œæ”¯æŒ ^ å’Œ $ é”šç‚¹,
/// å¹¶ä¸”åŒ¹é… . å’Œ *
public struct Regex {
  private let regexp: String
  /// ä»ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²æ„å»ºè¿›è¡Œ
  public init(_ regexp: String) {
    self.regexp = regexp
  }
}

extension Regex {
  /// å½“å­—ç¬¦ä¸²å‚æ•°åŒ¹é…è¡¨è¾¾å¼æ˜¯è¿”å› true
  public func match(_ text: String) -> Bool {
    // å¦‚æœè¡¨è¾¾å¼ä»¥ ^ å¼€å¤´ï¼Œé‚£ä¹ˆå®ƒåªä»å¤´å¼€å§‹åŒ¹é…è¾“å…¥
    if regexp.first == "^" {
      return Regex.matchHere(regexp: regexp.dropFirst(),
      text: text[...])
    }
    // å¦åˆ™ï¼Œåœ¨è¾“å…¥çš„æ¯ä¸ªéƒ¨åˆ†è¿›è¡Œæœç´¢ï¼Œç›´åˆ°å‘ç°åŒ¹é…
    var idx = text.startIndex
    while true {
      if Regex.matchHere(regexp: regexp[...],
        text: text.suffix(from: idx))
      {
        return true
      }
      guard idx != text.endIndex else { break }
      text.formIndex(after: &idx)
    }
    return false
  }

  /// ä»æ–‡æœ¬å¼€å¤´å¼€å§‹åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼
  private static func matchHere(
  regexp: Substring, text: Substring) -> Bool
  {
    // ç©ºçš„æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥åŒ¹é…æ‰€æœ‰
    if regexp.isEmpty {
      return true
    }
    // æ‰€æœ‰è·Ÿåœ¨ * åé¢çš„å­—ç¬¦éƒ½éœ€è¦è°ƒç”¨ matchStar
    if let c = regexp.first, regexp.dropFirst().first == "*" {
      return matchStar(character: c, regexp: regexp.dropFirst(2), text: text)
    }
    // å¦‚æœå·²ç»æ˜¯æ­£åˆ™è¡¨è¾¾å¼çš„æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œè€Œä¸”è¿™ä¸ªå­—ç¬¦æ˜¯ $ï¼Œ
    // é‚£ä¹ˆå½“ä¸”ä»…å½“å‰©ä½™å­—ç¬¦ä¸²çš„ç©ºæ—¶æ‰åŒ¹é…
    if regexp.first == "$" && regexp.dropFirst().isEmpty {
      return text.isEmpty
    }
    // å¦‚æœå½“å‰å­—ç¬¦åŒ¹é…äº†ï¼Œé‚£ä¹ˆä»è¾“å…¥å­—ç¬¦ä¸²å’Œæ­£åˆ™è¡¨è¾¾å¼ä¸­å°†å…¶ä¸¢å¼ƒï¼Œ
    // ç„¶åç»§ç»­è¿›è¡Œæ¥ä¸‹æ¥çš„åŒ¹é…
    if let tc = text.first, let rc = regexp.first, rc == "." || tc == rc {
      return matchHere(regexp: regexp.dropFirst(), text: text.dropFirst())
    }
    // å¦‚æœä¸Šé¢éƒ½ä¸æˆç«‹ï¼Œå°±æ„å‘³ç€æ²¡æœ‰åŒ¹é…
    return false
  }

  /// åœ¨æ–‡æœ¬å¼€å¤´æŸ¥æ‰¾é›¶ä¸ªæˆ–å¤šä¸ª `c` å­—ç¬¦ï¼Œ
  /// æ¥ä¸‹æ¥æ˜¯æ­£åˆ™è¡¨è¾¾å¼çš„å‰©ä½™éƒ¨åˆ†
  private static func matchStar
  (character c: Character, regexp: Substring, text: Substring) -> Bool
  {
    var idx = text.startIndex
    while true { // a * matches zero or more instances
      if matchHere(regexp: regexp, text: text.suffix(from: idx)) {
        return true
      }
      if idx == text.endIndex || (text[idx] != c && c != ".") {
        return false
      }
      text.formIndex(after: &idx)
    }
  }
}

// ä½¿ç”¨
Regex("^h..lo*!$").match("hellooooo!") // true

// å¦‚æœå­—ç¬¦ä¸²å¯ä»¥åƒæ•°ç»„ä¸€æ ·ï¼Œå°±å¯ä»¥æŒ‰ä¸‹é¢è¿™æ ·å†™ï¼Œä½†æ˜¯å­—ç¬¦ä¸²ç´¢å¼•èŒƒå›´ä¸æ˜¯åºåˆ—ã€‚
// ... è¡¨ç¤ºç›´åˆ°å¹¶ä¸”åŒ…æ‹¬ endIndex
for idx in text.startIndex...text.endIndex {
  // idx å’Œç»“å°¾ä¹‹é—´çš„å­—ç¬¦ä¸²åˆ‡ç‰‡
  if Regex.matchHere(regexp: _regexp, text: text[idx...]) {
    return true
  }
}
```
### åã€ExpressibleByStringLiteral
* String("blah") å’Œ "blah" ä¸¤è€…æ˜¯ä¸åŒçš„ï¼Œ"" æ˜¯å­—ç¬¦ä¸²å­—é¢é‡ã€‚å¯ä»¥é€šè¿‡å®ç° ExpressibleByStringLiteral
æ¥è®©è‡ªå·±çš„ç±»å‹å¯ä»¥é€šè¿‡å­—ç¬¦ä¸²å­—é¢é‡è¿›è¡Œåˆå§‹åŒ–ã€‚
* å­—ç¬¦ä¸²å­—é¢é‡éš¶å±äº ExpressibleByStringLiteralã€ExpressibleByExtendedGraphemeClusterLiteral å’Œ ExpressibleByUnicodeScalarLiteral è¿™ä¸‰ä¸ªå±‚æ¬¡ç»“æ„çš„åè®®ï¼Œæ‰€ä»¥å®ç°èµ·æ¥æ¯”æ•°ç»„å­—é¢é‡ç¨è´¹åŠ²ä¸€äº›ã€‚
è¿™ä¸‰ä¸ªåè®®éƒ½å®šä¹‰äº†æ”¯æŒå„è‡ªå­—é¢é‡ç±»å‹çš„ init æ–¹æ³•ï¼Œä½ å¿…é¡»å¯¹è¿™ä¸‰ä¸ªéƒ½è¿›è¡Œå®ç°ã€‚å¦‚æœä¸éœ€è¦åŒºåˆ†æ˜¯ä»
ä¸€ä¸ª Unicode æ ‡é‡è¿˜æ˜¯ä»ä¸€ä¸ªå­—ä½ç°‡æ¥åˆ›å»ºå®ä¾‹è¿™æ ·ç»†ç²’åº¦çš„é€»è¾‘ï¼Œåªéœ€è¦å®ç°å­—ç¬¦ä¸²ç‰ˆæœ¬å°±è¡Œäº†ã€‚  

```
extension Regex: ExpressibleByStringLiteral {
  public init(stringLiteral value: String) {
    regexp = value
  }
}
// å®šä¹‰å¥½ä¹‹åï¼Œåªéœ€è¦æ˜¾å¼åœ°æ ‡æ˜ç±»å‹ï¼Œå°±å¯ä»¥å¼€å§‹ç”¨å­—ç¬¦ä¸²å­—é¢é‡æ¥åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å™¨äº†ï¼š
let r: Regex = "^h..lo*!$"

// å½“ç±»å‹å·²ç»æ ‡æ˜æ—¶å°±æ›´å¥½ç”¨äº†ï¼Œå› ä¸ºç¼–è¯‘å™¨å¯ä»¥å¸®åŠ©ä½ è¿›è¡Œæ¨æ–­
func findMatches(in strings: [String], regex: Regex) -> [String] {
  return strings.filter { regex.match($0) }
}
findMatches(in: ["foo","bar","baz"], regex: "^b..") // ["bar", "baz"]
```
### åä¸€ã€CustomStringConvertible å’Œ CustomDebugStringConvertible
* print å’Œ String.init è¿™æ ·çš„å‡½æ•°ï¼Œä»¥åŠå­—ç¬¦ä¸²æ’å€¼è¢«è®¾è®¡æˆæ¥æ”¶ä»»ä½•ç±»å‹çš„å‚æ•°ï¼Œé»˜è®¤å±æ€§ã€‚
* å¦‚æœæ²¡æœ‰å®ç° CustomDebugStringConvertibleï¼ŒString(reflecting:) ä¼šé€€å›ä½¿ç”¨ CustomStringConvertibleã€‚
æ‰€ä»¥å¦‚æœä½ çš„ç±»å‹å¾ˆç®€å•ï¼Œé€šå¸¸æ²¡å¿…è¦å®ç° CustomDebugStringConvertibleã€‚ä¸è¿‡å¦‚æœä½ çš„è‡ªå®šä¹‰ç±»å‹
æ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œé‚£ä¹ˆéµå¾ª CustomDebugStringConvertible ä»¥æ‰“å°å…¶æ‰€å«å…ƒç´ çš„è°ƒè¯•æè¿°ä¿¡æ¯ä¼šæ›´è€ƒç©¶ä¸€äº›ã€‚  

```
print(Regex("colou?r"))
// æ‰“å° Regex("colou?r")

// å½“ç±»å‹æœ‰ä¸€äº›ä¸å¸Œæœ›è¢«å±•ç¤ºçš„ç§æœ‰å˜é‡ï¼Œè‡ªå®šä¹‰ç±»è¢«ä¼ ç»™ print æ—¶è¾“å‡ºæ ¼å¼åŒ–è¾“å‡º
extension Regex: CustomStringConvertible {
  public var description: String {
    return "/\(regexp)/"
  }
}

// å°†ä½ çš„è‡ªå®šä¹‰ç±»å‹é€šè¿‡å„ç§æ‰‹æ®µè½¬æˆå­—ç¬¦ä¸² (æ¯”å¦‚ç”¨åœ¨ç±»ä¼¼ print çš„æµå¼å‡½æ•°ï¼Œæˆ–è€…å½“åš
  String(describing:) çš„å‚æ•°ï¼Œåˆæˆ–è€…ç”¨åœ¨æŸä¸ªå­—ç¬¦ä¸²æ’å€¼ä¸­ä½¿ç”¨)ï¼Œéƒ½ä¼šå¾—åˆ° /expression/ï¼š
let regex = Regex("colou?r")
print(regex) // /colou?r/

// CustomDebugStringConvertible åè®®ï¼Œå®ç°è¯¥åè®®å¯ä»¥åœ¨è°ƒç”¨ String(reflecting:) æ—¶è¾“å‡ºæ›´å¤šè°ƒè¯•ä¿¡æ¯ã€‚
extension Regex: CustomDebugStringConvertible {
  public var debugDescription: String {
    return "{expression: \(regexp)}"
  }
}

// FIFOQueue ä¾‹å­æ‰©å±•
extension FIFOQueue: CustomStringConvertible,
CustomDebugStringConvertible
{
  public var description: String {
    // ä½¿ç”¨ String(describing:) å¯¹å…ƒç´ è¿›è¡Œæ‰“å°ï¼Œ
    // å®ƒå°†ä¼˜å…ˆä½¿ç”¨ CustomStringConvertible
    let elements = map { String(describing: $0) }.joined(separator: ", ")
    return "[\(elements)]"
  }
  public var debugDescription: String {
    // ä½¿ç”¨ String(reflecting:) å¯¹å…ƒç´ è¿›è¡Œæ‰“å°ï¼Œ
    // å®ƒå°†ä¼˜å…ˆä½¿ç”¨ CustomDebugStringConvertible
    let elements = map { String(reflecting: $0) }.joined(separator: ", ")
    return "FIFOQueue: [\(elements)]"
  }
}
// å°±ç®—ä½¿ç”¨çš„æ˜¯ String(describing:)ï¼ŒArray è¿˜æ˜¯ä¼šä¸ºå®ƒçš„å…ƒç´ æ‰“å°è°ƒè¯•ç‰ˆæœ¬çš„æè¿°ã€‚
// æ•°ç»„çš„æè¿°åº”è¯¥æ°¸è¿œä¸ä¼šæœ‰å‘ˆç°ç»™ç”¨æˆ·çš„éœ€æ±‚ï¼Œå®ƒä»¬åªåº”è¯¥è¢«ç”¨åœ¨è°ƒè¯•ä¸­ã€‚

func doSomethingAttractive<T: CustomStringConvertible>(with value: T) {
  // å› ä¸º CustomStringConvertible çš„è¾“å‡ºåº”è¯¥å¾ˆæ¼‚äº®ï¼Œæ‰€ä»¥èƒ½å¾ˆå¥½åœ°æ‰“å°æŸä¸ªå€¼
}
// ä¸åº”è¯¥è¿™ä¹ˆæ¥ä½¿ç”¨ CustomStringConvertibleã€‚
// åº”è¯¥ä½¿ç”¨ String(describing:)ï¼Œè€Œä¸æ˜¯æ£€æŸ¥æŸä¸ªç±»å‹æ˜¯å¦æœ‰ description å±æ€§ã€‚å¦‚æœæŸä¸ªç±»å‹ä¸
// éµå¾ª CustomStringConvertibleï¼Œé‚£ä¹Ÿåªèƒ½å¿å—å…¶ä¸‘é™‹çš„è¾“å‡ºäº†ã€‚æ‰€ä»¥å†™çš„ä»»ä½•ç¨å¾®å¤æ‚ä¸€äº›çš„ç±»å‹éƒ½
// åº”è¯¥å®ç° CustomStringConvertibleï¼Œè¦ä¸äº†å‡ è¡Œä»£ç ã€‚
```
### åäºŒã€æ–‡æœ¬è¾“å‡ºæµ
* æ ‡å‡†åº“ä¸­çš„ print å’Œ dump å‡½æ•°ä¼šæŠŠæ–‡æœ¬è®°å½•åˆ°æ ‡å‡†è¾“å‡ºä¸­ï¼Œè°ƒç”¨äº† print(\_:to:) å’Œ dump(\_:to:)
å®ç°ã€‚to å‚æ•°å°±æ˜¯è¾“å‡ºçš„ç›®æ ‡ï¼Œå®ƒå¯ä»¥æ˜¯ä»»ä½•å®ç°äº† TextOutputStream åè®®çš„ç±»å‹ã€‚
* æ ‡å‡†åº“ç»´æŠ¤äº†ä¸€ä¸ªå†…éƒ¨çš„æ–‡æœ¬è¾“å‡ºæµï¼Œå°†æ‰€æœ‰è¾“å…¥çš„å†…å®¹å†™åˆ°æ ‡å‡†è¾“å‡ºä¸­ï¼ŒString æ˜¯æ ‡å‡†åº“ä¸­å”¯ä¸€çš„è¾“å‡ºæµç±»å‹ã€‚
* å¯ä»¥å°† print å’Œ dump çš„è¾“å‡ºé‡æ–°å®šå‘åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ ‡å‡†åº“ä¹Ÿåˆ©ç”¨äº†è¾“å‡ºæµï¼Œæ¥è®© Xcode è·å–æ‰€æœ‰çš„æ ‡å‡†è¾“å‡ºã€‚
* å¯ä»¥åˆ›å»ºè‡ªå·±çš„è¾“å‡ºæµï¼ŒTextOutputStream åè®®åªè¦æ±‚æ¥å—å­—ç¬¦ä¸²ï¼Œå¹¶å°†å®ƒå†™åˆ°æµä¸­çš„ write æ–¹æ³•ã€‚
* è¾“å‡ºæµçš„æºå¯ä»¥æ˜¯å®ç°äº† TextOutputStreamable åè®®çš„ä»»æ„ç±»å‹ã€‚è¿™ä¸ªåè®®éœ€è¦ write(to:) è¿™ä¸ª
æ³›å‹æ–¹æ³•ï¼Œå®ƒå¯ä»¥æ¥å—æ»¡è¶³ TextOutputStream çš„ä»»æ„ç±»å‹ä½œä¸ºè¾“å…¥ï¼Œå¹¶å°† self å†™åˆ°è¿™ä¸ªè¾“å‡ºæµä¸­ã€‚
* åœ¨æ ‡å‡†åº“ä¸­ï¼ŒStringï¼ŒSubstringï¼Œ Character å’Œ Unicode.Scalar éƒ½æ»¡è¶³ TextOutputStreamableï¼Œ
ä¹Ÿå¯ä»¥è‡ªè¡Œä¸ºç±»å‹æ·»åŠ  TextOutputStreamable æ”¯æŒã€‚ä½¿ç”¨ print(\_:to:) å’Œ ç›´æ¥è°ƒç”¨ç›®æ ‡æµä¸Šçš„ write æ–¹æ³•ã€‚
* è¾“å‡ºæºå¯ä»¥å¤šæ¬¡è°ƒç”¨ writeï¼Œæµä¹Ÿå°†ç«‹å³å¤„ç†æ¯ä¸€æ¬¡çš„ write æ“ä½œã€‚
* æµè¿˜èƒ½å¤ŸæŒæœ‰çŠ¶æ€ï¼Œæˆ–è€…å¯¹è¾“å‡ºè¿›è¡Œå˜å½¢ï¼Œä¹Ÿèƒ½å¤Ÿå°†å¤šä¸ªæµé“¾æ¥èµ·æ¥ã€‚  

```
// print(_:to:) ä¸­çš„ Target å®ç°äº† TextOutputStream åè®®
public func print<Target: TextOutputStream>
(_ items: Any..., separator: String = " ",
terminator: String = "\n", to output: inout Target)

// æ ‡å‡†åº“ä¸­å…¨å±€å˜é‡å£°æ˜
public var _playgroundPrintHook: ((String) -> Void)?

// æ¥å°†æ‰€æœ‰æ‰“å°çš„å†…å®¹åŒæ—¶ä¼ é€’ç»™æ ‡å‡†è¾“å‡ºå’Œè¿™ä¸ªå‡½æ•°
var printCapture = ""
_playgroundPrintHook = { text in
  printCapture += text
}
print("This is supposed to only go to stdout")
printCapture // This is supposed to only go to stdout

// è¾“å‡ºæµå°†è¾“å…¥å†™åˆ°ä¸€ä¸ªç¼“å†²æ•°ç»„é‡Œï¼š
struct ArrayStream: TextOutputStream {
  var buffer: [String] = []
  mutating func write(_ string: String) {
    buffer.append(string)
  }
}
var stream = ArrayStream()
print("Hello", to: &stream)
print("World", to: &stream)
stream.buffer // ["", "Hello", "\n", "", "World", "\n"]

// æ‰©å±• Data ç±»å‹ï¼Œè®©å®ƒæ¥å—æµè¾“å…¥ï¼Œå¹¶è¾“å‡º UTF-8 ç¼–ç çš„ç»“æœï¼š
extension Data: TextOutputStream {
  mutating public func write(_ string: String) {
    self.append(contentsOf: string.utf8)
  }
}
var utf8Data = Data()
var string = "cafÃ©"
utf8Data.write(string) // ()

// ç›´æ¥è°ƒç”¨ç›®æ ‡æµä¸Šçš„ write æ–¹æ³•ï¼Œåœ¨é›†åˆåè®®ä¸­æ„å»ºçš„é˜Ÿåˆ—æ»¡è¶³ TextOutputStreamableï¼š
extension FIFOQueue: TextOutputStreamable {
  func write<Target: TextOutputStream>(to target: inout Target) {
    target.write("[")
    target.write(map { String(describing: $0) }.joined(separator: ","))
    target.write("]")
  }
}
var textRepresentation = ""
let queue: FIFOQueue = [1,2,3]
queue.write(to: &textRepresentation)
textRepresentation // [1,2,3]

// è¾“å‡ºæºå¯ä»¥å¤šæ¬¡è°ƒç”¨ writeï¼Œæµä¹Ÿå°†ç«‹å³å¤„ç†æ¯ä¸€æ¬¡çš„ write
struct SlowStreamer: TextOutputStreamable, ExpressibleByArrayLiteral {
  let contents: [String]
  init(arrayLiteral elements: String...) {
    contents = elements
  }
  func write<Target: TextOutputStream>(to target: inout Target) {
    for x in contents {
      target.write(x)
      target.write("\n")
      sleep(1)
    }
  }
}
let slow: SlowStreamer = [
"You'll see that this gets",
"written slowly line by line",
"to the standard output",
]
print(slow)

// print å‡½æ•°åœ¨å†…éƒ¨ä½¿ç”¨äº†ä¸€äº›æ»¡è¶³ TextOutputStream çš„ä¸œè¥¿æ¥å°è£…æ ‡å‡†è¾“å‡º
// æ ‡å‡†é”™è¯¯çš„å°è£…
struct StdErr: TextOutputStream {
  mutating func write(_ string: String) {
    guard !string.isEmpty else { return }
    // èƒ½å¤Ÿç›´æ¥ä¼ é€’ç»™ C å‡½æ•°çš„å­—ç¬¦ä¸²æ˜¯
    // const char* çš„ï¼Œå‚é˜…äº’ç”¨æ€§ä¸€ç« è·å–æ›´å¤šä¿¡æ¯ï¼
    fputs(string, stderr)
  }
}
var standarderror = StdErr()
print("oops!", to: &standarderror)

// è¾“å‡ºæµå°†æ‰€æœ‰æŒ‡å®šçš„çŸ­è¯­æ›¿æ¢ä¸ºç»™å®šçš„å­—ç¬¦ä¸²
struct ReplacingStream: TextOutputStream, TextOutputStreamable {
  let toReplace: DictionaryLiteral<String, String>
  private var output = ""
  init(replacing toReplace: DictionaryLiteral<String, String>) {
    self.toReplace = toReplace
  }
  mutating func write(_ string: String) {
    let toWrite = toReplace.reduce(string) { partialResult, pair in
      partialResult.replacingOccurrences(of: pair.key, with: pair.value)
    }
    print(toWrite, terminator: "", to: &output)
  }
  func write<Target: TextOutputStream>(to target: inout Target) {
    output.write(to: &target)
  }
}
var replacer = ReplacingStream(replacing: [
"in the cloud": "on someone else's computer"
])
let source = "People find it convenient to store their data in the cloud."
print(source, terminator: "", to: &replacer)
var output = ""
print(replacer, terminator: "", to: &output)
output
// People find it convenient to store their data on someone else's computer.

// ä½¿ç”¨ DictionaryLiteral æ˜¯å¯¹äºé”®å€¼å¯¹æ•°ç»„ (æ¯”å¦‚ [(key, value)]) çš„å¾ˆå¥½çš„æ›¿ä»£ï¼Œå®ƒä¸ä¼šå¼•å…¥
å­—å…¸çš„å‰¯ä½œç”¨(å»æ‰é‡å¤çš„é”®ï¼Œå¹¶ä¸”ä¼šå°†æ‰€æœ‰é”®é‡æ–°æ’åº)ï¼ŒåŒæ—¶è®©è°ƒç”¨è€…èƒ½å¤Ÿä½¿ç”¨æ›´åŠ ä¾¿æ·çš„ [:] è¯­æ³•ã€‚
```
### åä¸‰ã€å­—ç¬¦ä¸²æ€§èƒ½
UTF-16 çš„è§†å›¾å†è¿™ä¸ªæµ‹è¯•ä¸­æ˜¯æœ€å¿«çš„ï¼Œèƒ½ç¡®ä¿è‡ªå·±æ‰€åšçš„æ“ä½œå¯ä»¥æ­£ç¡®å¤„ç† UTF-16 çš„æ•°æ®ï¼Œä½¿ç”¨ UTF-16
ä¼šåœ¨åšéå¸¸ç¹é‡çš„å­—ç¬¦ä¸²æ“ä½œæ—¶å¸¦æ¥ç›¸å½“ä¸é”™çš„æ€§èƒ½æå‡ã€‚  
```
protocol StringViewSelector {
  associatedtype View: Collection
  static var caret: View.Element { get }
  static var asterisk: View.Element { get }
  static var period: View.Element { get }
  static var dollar: View.Element { get }
  static func view(from s: String) -> View
}

/_
å¹»å½± (phantom) ç±»å‹â€çš„ä¸œè¥¿ã€‚è¿™ç§ç±»å‹åªåœ¨ç¼–è¯‘æ—¶å­˜åœ¨ï¼Œå¹¶ä¸”ä¸å­˜å‚¨ä»»ä½•æ•°æ®ã€‚å°è¯•è°ƒç”¨ MemoryLayout
<CharacterViewSelector>.size ä¼šè¿”å›é›¶ï¼Œå› ä¸ºé‡Œé¢æ²¡æœ‰ä»»ä½•æ•°æ®ã€‚æˆ‘ä»¬ä½¿ç”¨è¿™äº›å¹»å½±ç±»å‹å°±æ˜¯ä¸ºäº†å°†
æ­£åˆ™åŒ¹é…å™¨çš„è¡Œä¸ºè¿›è¡Œå‚æ•°åŒ–ã€‚
_/
struct UTF8ViewSelector: StringViewSelector {
  static var caret: UInt8 { return UInt8(ascii: "^") }
  static var asterisk: UInt8 { return UInt8(ascii: "_") }
  static var period: UInt8 { return UInt8(ascii: ".") }
  static var dollar: UInt8 { return UInt8(ascii: "$") }
  static func view(from s: String) -> String.UTF8View { return s.utf8 }
}
struct CharacterViewSelector: StringViewSelector {
  static var caret: Character { return "^" }
  static var asterisk: Character { return "_" }
  static var period: Character { return "." }
  static var dollar: Character { return "$" }
  static func view(from s: String) -> String { return s }
}

struct Regex&lt;V: StringViewSelector>
where V.View.Element: Equatable,
V.View.SubSequence: Collection
{
  let regexp: String
  /// ä»æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²ä¸­æ„å»º
  init(_ regexp: String) {
    self.regexp = regexp
  }
}
extension Regex {
  /// å½“è¡¨è¾¾å¼åŒ¹é…å­—ç¬¦ä¸²æ—¶è¿”å› true
  func match(_ text: String) -> Bool {
    let text = V.view(from: text)
    let regexp = V.view(from: self.regexp)
    // å¦‚æœæ­£åˆ™ä»¥ ^ å¼€å¤´ï¼Œå®ƒåªä»å¼€å¤´è¿›è¡ŒåŒ¹é…
    if regexp.first == V.caret {
      return Regex.matchHere(regexp: regexp.dropFirst(), text: text[...])
    }
    // å¦åˆ™ï¼Œåœ¨è¾“å…¥å†…é€ä½æœç´¢åŒ¹é…ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…å†…å®¹
    var idx = text.startIndex
    while true {
      if Regex.matchHere(regexp: regexp[...], text: text.suffix(from: idx)) {
        return true
    }

    guard idx != text.endIndex else { break }
      text.formIndex(after: &idx)
    }
    return false
  }
  /// ä»æ–‡æœ¬å¼€å¤´åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²
  private static func matchHere(
  regexp: V.View.SubSequence, text: V.View.SubSequence) -> Bool
  {
    // ...
  }
  // ...
}

func benchmark&lt;V: StringViewSelector>(\_: V.Type, pattern: String, text: String)
\-> TimeInterval
where V.View.Element: Equatable, V.View.SubSequence: Collection
{
  let r = Regex<V>(pattern)
  let lines = text.split(separator: "\\n").map(String.init)
  var count = 0
  let startTime = CFAbsoluteTimeGetCurrent()
  for line in lines {
    if r.match(line) { count = count &+ 1 }
  }
  let totalTime = CFAbsoluteTimeGetCurrent() - startTime
  return totalTime
}
let timeCharacter = benchmark(CharacterViewSelector.self,
  pattern: pattern, text: input)
let timeUnicodeScalar = benchmark(UnicodeScalarViewSelector.self,
  pattern: pattern, text: input)
let timeUTF16 = benchmark(UTF8ViewSelector.self,
  pattern: pattern, text: input)
let timeUTF8 = benchmark(UTF16ViewSelector.self,
  let pattern: pattern, text: input)

```
ç»“æœæ˜¾ç¤ºä¸åŒçš„è¡¨ç¤ºæ–¹å¼åœ¨å¤„ç†åŒä¸€ä»½å¤§å‹è‹±è¯­æ–‡æœ¬è¯­æ–™åº“ (128,000è¡Œï¼Œ650 ä¸‡ä¸ªå­—ç¬¦) æ—¶çš„é€Ÿåº¦ï¼š  

è¡¨ç¤ºæ–¹å¼ | ASCII æ–‡æœ¬ | ä¸­æ–‡æ–‡æœ¬
--- | --- | ---
Characters |	1.4 seconds |	3.5 seconds
Unicode.Scalars |	1.6 seconds |	1.1 seconds
UTF-16 |	0.7 seconds |	0.5 seconds
UTF-8	| 1.1 seconds |	n/a  

(é€šè¿‡ UTF-8 è§†å›¾æµ‹é‡ä¸­æ–‡çš„ç»“æœæ²¡æœ‰æ„ä¹‰ï¼Œå› æ— æ³•å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚)
