---
layout: post
title: '悦读笔记-待整理'
date: 2020-08-25
author: 李大鹏
cover: ''
tags: iOS
---

### 一、《iOS 高手课》

- 浅谈架构

  - MVC，Model 数据管理者，View 数据展示者，Controller 数据加工者。

- 设计模式

  - 策略（strategy）模式，实现 IM 系统的内容发送时，由于发送类型包含文本、图片、语音、视频多种格式的消息，导致 Manager 略显臃肿。通过引入策略模式，增加 MassegetSend 类，发送方通过调用对应的策略进行内容的发送，如：文本发送策略、语音发送策略，从而拆分了臃肿的 Manager。
  - 中间人（Mediator）模式，在订单系统开发时，会由于订单业务较长，多人协同开发时会存在业务间的依赖。通过建立中间人模块 OrderManager，采用 AOP 将定制过程分片，如：钻石选择、款式选择，解决横向依赖的问题。
  - Target/action 模式，一个对象包含一些生成一个消息表达式的元素，当一个确定事件出现时，把这些元素放到一起组成消息并发送这个消息。
  - Promise 模式

- StoryBoard

  - 新版本能够局部更新，解决了指数型消耗性能的问题。

- 埋点

  - UIViewController
  - +load 时 hook 住 Willappear 和 Disappear

- RunLoop 检查卡顿

  - 监听 RunLoop，创建一个 CFRunLoopObserverContext 观察者
  - 卡顿规则：睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阀值内一直没有变化，即可判定为卡顿。
  - 标准：启动 10 秒、其他 3 秒
  - WatchDog

    - 启动(Launch):20s;
    - 恢复(Resume):10s;
    - 挂起(Suspend):10s;
    - 退出(Quit):6s;
    - 后台(Background):3min(在 iOS 7 之前，每次申请 10min; 之后改为每次申请 3min，可 连续申请，最多申请到 10min)。

- 线上性能监控
  - CPU 使用率
    - 每个线程都会有这个 thread_basic_info 结构体，所以接下来的事情就好办了，你只需要定时 (比如，将定时间隔设置为 2s)去遍历每个线程，累加每个线程 cpu_usage 字段的值。
  - FPS
    - 通过注册 CADisplayLink 得到屏幕的同步刷新率，记录每次刷新时间，然后就可以得到 FPS。
  - 内存使用量
    - 存信息存在 task_info.h (完整路径 usr/include/mach/task.info.h)文件的 task_vm_info 结构 体中，其中 phys_footprint 就是物理内存的使用，而不是驻留内存 resident_size。
- 耗电量
  - IOKit framework 来 获取硬件信息，进而获取到电量消耗信息
    - 把 IOPowerSources.h、IOPSKeys.h 和 IOKit 这三个文件导入到工程中;
    - batteryMonitoringEnabled 置为 true;
    - percentage = curCapacity / maxCapacity \* 100.0f); （1%精确度的电量信息。）
  - 线程的 CPU 使用率长时间都比较高的话，比如超过了 90%，推断出有问题，记录方法堆栈。
- libffi:动态调用和定义 C 函数
  - ffi 的全称是 Foreign Function Interface(外部函数接口)
  - Aspect 进行方法替换，如果使用不当，会有较大的风险
  - hook 已经被 hook 过的方 法，那么之前的 hook 会失效，新的 hook 也会出错，而使用 libffi 进行 hook 不会出现这样的问题。

### 二、其他

- `@synchronized` 和 `@dispatch_once`

  - synchronized，objc_sync_enter 对方法添加递归互斥锁，执行线程安全代码，objc_sync_exit 时解锁。
  - dispatch_once 首次调用执行 block 时设置 predicate 为 DISPATCH_ONCE_DONE(~0l)，其他线程调用会等待，加入到信号量链表中，执行完之后唤醒。
  - dispatch_once 单例效率更高。内部原子操作来替代锁、通过信号量实现线程同步、针对处理器优化、if 判断语句上也做了优化。

### 三、算法常用函数

```
// ------- 数组 --------
// 初始值
var f = [Int](repeating: Int.min, count: n + 1)
// 删除所有元素
f.removeAll()
// 变形
let numbers = [1,2,3,4]
let result = numbers.map { $0 + 2 }
// 排序
intervals.sort { $0[0] < $1[0] }
// 遍历
for idx in arr.indices { }
for idx in 0...max { }
// 步进
for i in stride(from: 0, to: 10 ,by: 2) {}
// 最大值，最小值
Int.max Int.min

// 集合
var colors:Set = ["red", "green", "blue" , "white"]
let isContainBlue = colors.contains("blue")

// 枚举
enum Direction {
  case right
  case down
}
switch direction {
  case .right:
      print(1)
  case .down:
      print(1)
}

// 次方
// 结果为a的b次方
pow(a , b)
Int(truncating: pow(10, bitNum-1) as NSDecimalNumber)

extension String {
    subscript (i: Int) -> Character {
        return self[index(startIndex, offsetBy: i)]
    }
}
```
