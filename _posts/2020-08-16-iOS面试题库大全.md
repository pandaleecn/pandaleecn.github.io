---
layout: post
title: 'iOS面试题库大全'
date: 2020-08-16
author: 李大鹏
cover: ''
tags: iOS
---

## 一、问题目录

### 1. Runloop

#### [Runloop 和线程的关系](#Runloop 和线程的关系)

### 2. 内存管理

#### [自动释放池什么时候释放？](#自动释放池什么时候释放？)

#### [](#)

#### [](#)

### 3. 多线程

#### [NSThread 的声明周期](#NSThread的声明周期)

#### [线程安全-加互斥锁](#线程安全加互斥锁)

#### [线程间通信](#线程通信)

#### [GCD 任务、队列](#GCD任务、队列)

#### [Runloop 的应用](#Runloop的应用)

### 4. Objective-C

#### [用@property 声明的 NSString (或 NSArray，NSDictionary)经常使 用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？](#用@property 声明的 NSString)

#### [什么情况下使用 weak 关键字，和 assign 的区别？](#什么情况下使用 weak 关键字，和 assign 的区别)

#### [怎么用 copy 关键子？](#怎么用copy关键子？)

#### [@property (copy) NSMutableArray \*array;这写法会出什么问题？](#NSMutableArray)

#### [如何让自己的类用 copy 修饰符？即让自己写的对象具备拷贝功能](#如何让自己的类用copy修饰符？即让自己写的对象具备拷贝功能)

#### [@property 的本质是什么？ ivar、getter、setter 如何生成并添加到这个类中的](#@property 的本质是什么)

#### [@protocol 和 category 中如何使用 @property?](#@protocol 和 category 中如何使用 @property?)

#### [@property 中有哪些属性关键字？](#@property中有哪些属性关键字？)

#### [weak 属性需要在 dealloc 中置 nil 么？](#weak属性需要在dealloc中置nil么？)

#### [@synthesize 和@dynamic 分别有什么作用？](#@synthesize和@dynamic分别有什么作用？)

#### [ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些？](#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？)

#### [@synthesize 合成实例变量的规则是什么？假如 property 名为 foo， 存在一个名为\_foo 的实例变量，那么还会自动合成新变量么？](#合成实例)

#### [在有了自动合成属性实例变量之后，@synthesize 还有哪些使用场 景？](#在有了自动合成属性实例变量之后)

#### [objc 中向一个 nil 对象发送消息将会发生什么？](#objc中向一个nil对象发送消息将会发生什么？)

#### [objc 中向一个对象发送消息[obj foo]和 objc_msgSend ()函数之间 有什么关系？](#objc 中向一个对象发送消息[)

#### [什么时候会报 unrecognized selector 的异常？](#unrecognized selector)

#### [一个 objc 对象如何进行内存布局？（考虑有父类的情况）](#一个objc对象如何进行内存布局？（考虑有父类的情况）)

#### [objc 对象的 isa 指针指向什么？有什么作用？](#objc对象的isa指针指向什么？有什么作用？)

#### [runtime 如何通过 selector 找到对应的 IMP 地址？（分别考虑类方法 和实例方法）](#分别考虑类方法 和实例方法）)

#### [NSStringFromClass([super class])](#NSStringFromClass([super class]))

#### [使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的 时候释放么？](#使用runtimeAssociate方法)

#### [objc 中的类方法和实例方法有什么本质区别和联系？](#objc中的类方法和实例方法有什么本质区别和联系？)

#### [\_objc_msgForward 函数是做什么的，直接调用它将会发生什么？](#_objc_msgForward函数是做什么的，直接调用它将会发生什么？)

#### [runtime 如何实现 weak 变量的自动置 nil?](#runtime如何实现weak变量的自动置nil?)

#### [能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添 加实例变量？为什么？](#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添 加实例变量？为什么？)

#### [runloop 和线程有什么关系？](#runloop和线程有什么关系？)

#### [ runloop 的 mode 作用是什么？](#runloop的mode作用是什么？)

#### [+ scheduledTimerWithTimelnterval. • •的方式触发的 timer， 在滑动页面上的列表时，timer 会暂定回调，为什么？如何解决？](#+ scheduledTimerWithTimelnterval)

#### [猜想 r unloop 内部是如何实现的？](#runloop内部是如)

#### [objc 使用什么机制管理对象内存？](#objc使用什么机制管理对象内存？)

#### [ARC 通过什么方式帮助开发者管理内存？](#ARC通过什么方式帮助开发者管理内存？)

#### [BAD_ACCESS 在什么情况下出现？](#BAD_ACCESS在什么情况下出现？)

#### [使用 block 时什么情况会发生引用循环，如何解决？](#使用block时什么情况会发生引用循环，如何解决？)

#### [在 block 内如何修改 block 外部变量？](#在block内如何修改block外部变量？)

#### [苹果是如何实现 autoreleasepool 的？](#苹果是如何实现autoreleasepool的？)

#### [不手动指定 autoreleasepool 的前提下，一个 autorealese 对象在什 么吋刻释放？（比如在一个 vc 的 viewDidLoad 中创建）](#不手动指定autoreleasepool的前提下)

#### [使用系统的某些 block api- 如 UlView 的 block 版本写动画时，是 否也考虑引用循环问题？](#使用系统的某些)

#### [GCD 的队列（dispatch_queue_t)分哪两种类型？](#两种类型？)

#### [如何用 GCD 同步若干个异步调用？（如根据若干个 url 异步加载多张图 片，然后在都下载完成后合成一张整图）](#加载多张图 片，然后在都下载完成后合成一张整图）)

#### [dispatch_barrier_async 的作用是什么？](#dispatch_barrier_async 的作用是什么？)

#### [苹果为什么要废弃 dispatch_get_current_queue?](#苹果为什么要废弃 dispatch_get_current_queue?)

#### [dispatch_sync(dispatch_get_main_queue(),^{});](<#dispatch_sync(dispatch_get_main_queue(),^{});>)

#### [addObserver:forKeyPath:options:context:各个参数的作用分别是什 么，observer 中需要实现哪个方法才能获得 KVO 回调？](#addObserver:forKeyPath:options:context:各个参数的作用分别是什 么，observer 中需要实现哪个方法才能获得 KVO 回调？)

#### [如何手动触发一个 value 的 KVO?](#如何手动触发一个value的KVO?)

#### [若一个类有实例变量 NSString *_foo，调用 setValue:forKey:时，可以以 foo 还是_foo 作为 key?](#用 setValue:)

#### [KVC 的 keyPath 中的集合运算符如何使用？](#KVC的keyPath中的集合运算符如何使用？)

#### [KVC 和 KVO 的 keyPath—定是属性么？](#KVC和KVO的keyPath—定是属性么？)

#### [如何关闭默认的 KVO 的默认实现，并进入自定义的 KVO 实现?](#如何关闭默认的KVO的默认实现，并进入自定义的KVO实现?)

#### [apple 用什么方式实现对一个对象的 KVO?](#apple用什么方式实现对一个对象的KVO?)

#### [IB0utlet 连出来的视图属性为什么可以被设置成 weak?](#IB0utlet连出来的视图属性为什么可以被设置成weak?)

#### [IB 中 User Defined Runtime Attributes 如何使用？（应该知道在哪吧）](#UserefinedRuntimeAttributes)

#### [如何调试 BAD_ACCESS 错误](#如何调试BAD_ACCESS错误)

#### [iOS 容易引起“循环引用”的几种场景](#iOS容易引起“循环引用”的几种场景)

#### [lldb (gdb)常用的调试命令？](#lldb (gdb)常用的调试命令？)

#### [类方法 load 和 initialize 的区别](#类方法load和initialize的区别)

#### [HTTP 和 HTTPS](#HTTP 和 HTTPS)

#### [常见的 Exception Type](#常见的 Exception Type)

#### [Category 和 Extension](#Category 和 Extension)

#### [响应者链（responder chain)](#响应者链resp)

#### [UITableView 的优化](#UITableView的优化)

#### [离屏這染（Offscreen-Renderd)](#离屏這染Offscreen-Renderd)

#### [UIView 和 CALayer](#UIView 和 CALayer)

#### [TCP 和 UDP](#TCP 和 UDP)

#### [socket 和 http](#socket 和 http)

#### [远程推送 APNS](#远程推送APNS)

#### [iOS 应用程序生命周期](#iOS应用程序生命周期)

#### [view 视图生命周期](#view视图生命周期)

#### [autorelease pool](#autorelease pool)

#### [view layout](#viewlayout)

#### [简述内存分区情况](#内存分区情况)

#### [各属性作用](#各属性作用2222)

#### [简述 Notification、KVC、KVO、delegate?区别？](#简述 Notification、KVC、KVO、delegate?区别？)

#### [id 和 nil 代表什么](#id和nil代表什么)

#### [nil、Nil、NULL、NSNull](#nil、Nil、NULL、NSNull)

#### [向一个 nil 对象发送消息会发生什么？](#向一个nil对象发送消息会发生什么？)

#### [self. 和 self-> 的区别](#self区别)

#### [如何访问并修改一个类的私有属性](#的私有属性)

#### [如何为 class 定义一个对外只读、对内可读写的属性](#如何为class定义一个对外只读、对内可读写的属性)

#### [0C 中，meta-class 指的是什么？](#0C中，meta-class指的是什么？)

#### [NSString 用 copy 和 strong 的区别](#NSString 用 copy 和 strong 的区别)

#### [创建一个对象的步骤](#一个对象的步骤)

#### [setter、getter](#setter、getter)

#### [id、instancetype 是什么？区别？](#id、instancetype是什么？区别？)

#### [内存管理](#内存管理8888)

#### [KVC 的底层实现？](#KVC的底层实现？)

#### [block 的内存管理](#block的内存管理)

#### [App 的启动过程，从 main 说起](#App的启动过程，从main说起)

#### [tableview 的 cell 里面如何嵌套 collectionview](#tableview 的 cell 里面如何嵌套 collectionview)

#### [awakeFromNib 和 viewDidLoad 的区别](#awakeFromNib 和 viewDidLoad 的区别)

#### [常见的 Crash 场景](#常见的Crash场景)

#### [AFN 断点续传](#AFN断点续传)

#### [客户端的缓存机制](#客户端的缓存机制8888)

#### [数据存储方式](#数据存储方式8888)

#### [App 需要加载超大量的数据，给服务器发送请求，但服务器卡住了， 如何解决？](#App54545)

#### [网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？](#网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？)

#### [如何用 GCD 同步若干个异步调用？（如根据若干个 url 异步加载 多张图片，然后在都下载完成后合成一张整图）](#异步调用555)

#### [NSOperation、GCD、NSThread 的区别](#NSOperation、GCD、NSThread 的区别)

#### [是否可以把比较耗时的操作放在 NSNotificationCenter 中](#是否可以把比较耗时的操作放在NSNotificationCenter中)

#### [利用预渲染加速 iOS 设备的图像显示](#利用预渲染加速iOS设备的图像显示)

#### [masonry 进行 label 的多行显示](#masonry 进行 label 的多行显示)

## 二、题目解答

#### <a id="Runloop 和线程的关系" >Runloop 和线程的关系</a>

- 一一对应，主线程的 runloop 已经创建，子线程的必须手动创建
- runloop 在第一次获取时创建，在线程结束时销毁
- //在 runloop 中有多个运行模式，但是只能选择一种模式运行，mode 中至少要有一个 timer 或者是 source Mode:
- 系统默认注册 5 个 Mode:
  - kCFRunLoopDefaultMode:App 默认 mode，通常主线程在这个 mode 下运行
  - UITrackingRunLoopMode:界面跟踪 mode，用于 ScrollView 追踪触摸滑动，保证滑动时 不受其他 mode 影响
  - kCFRunLoopCommonModes:占位用的 mode，不是一个真正的 mode NSRunLoopCommonModes 相当于 NSDefaultRunLoopMode
  - UITrackingRunLoopMode UIInitializationRunLoopMode:刚启动 App 时进入的第一个 mode，启动完成之后不再 使用
  - GSEventReceiveRunLoopMode:接受系统事件的内部 mode，通常用不到 runloop

#### <a id="用@property 声明的 NSString">用@property 声明的 NSString (或 NSArray，NSDictionary)经常使 用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</a>

- 因为父类指针可以指向子类对象，使用 copy 的目的是为了让本对象的属性不受外界影 响，使用 copy 无论给我传入是一个可变对象还是不可对象，我本身持有的就是一个不可变的副本；
- 如果使用 strong，那么这个属性就有可能指向一个可变对象，如果这个可变对象在外部 被修改了，那么会影响该属性.
- strong 此特质标明该属性定义了一种拥有关系。为这种属性设定新值时，设置方法会先保留新值再释放旧值，然后再将新值设置上去。
- copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值而是将其拷贝，当属性类型为 NSString\*时，经常用此特性来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例这个类是 NSString 的子类，表示一种可以修改其值得字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以这时就要拷贝一份不可变的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是可变的，就应该在设执行属性是拷贝一份。

#### <a id="自动释放池什么时候释放？">自动释放池什么时候释放？</a>

- 第一次创建：启动 runloop 时候
- 最后一次销毁：runloop 退出的时候
- 其他时候的创建和销毁：当 runloop 即将睡眠时销毁之前的释放池，重新创建一个新的

#### <a id="什么情况下使用 weak 关键字，和 assign 的区别" >什么情况下使用 weak 关键字，和 assign 的区别？</a>

- ARC 中，有可能出现循环引用的地方使用，比如：delegate 属性
- 自定义 IBOutlet 控件属性一般也是使用 weak
- 区别：weak 表明一种非持有关系，必须用于〇 C 对象；assign 用于基本数据类型

#### <a id="怎么用copy关键子？" >怎么用 copy 关键子？</a>

- 1、 NSString、NSArray、NSDictionary 等等经常使用 copy 关键字，是因为他们有对应的可 变类型：NSMutableString、NSMutableArray、NSMutableDictionary;他们之间可能进行 赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。
- 2、 block 也使用 copy

#### <a id="NSMutableArray" >@property (copy) NSMutableArray \*array;这写法会出什么问题？</a>

- 1、 添加，删除，修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为 copy 就 是复制一个不可变 NSArray 的对象；
- 2、 使用了 atomic 属性会严重影响性能；

#### <a id="如何让自己的类用copy修饰符？即让自己写的对象具备拷贝功能" >如何让自己的类用 copy 修饰符？即让自己写的对象具备拷贝功能</a>

- 1、 需声明该类遵从 NSCopying 或 NSMutableCopying 协议
- 2、 实现 NSCopying 协议。该协议只有一个方法：
  -(id)copyWithZone:(NSZone \*)zone;

#### <a id="@property 的本质是什么" >@property 的本质是什么？ ivar、getter、setter 如何生成并添加到这个类中的</a>

- 本质：@property = ivar + getter + setter;(实例变量+getter 方法+setter 方法）
- 在编译期自动生成 getter、setter，还自动向类中添加适当类型的实例变量，也可以用 Synthesize 语法来指定实例变量的名字

#### <a id="NSThread的声明周期" >NSThread 的声明周期</a>

- 线程任务执行完毕之后被释放

#### <a id="线程安全加互斥锁" >线程安全-加互斥锁</a>

- 格式：©synchronized (self){//需要锁定的代码}
- 注意：1.锁必须全局睢一；2.加锁的位置；3.加锁的前提条件；4.加锁结果：线程同步
- 优点：防止多线程抢夺资源造成的数据安全问题
- 缺点：耗费 CPU 性能
- 使用前提：多线程使用同一块资源
- 线程同步：多条线程在同一条线上按顺序的执行任务
- atomic:原子属性，为 setter 方法加锁（默认就是 atomic)，线程安全，耗资源 nonatomic: 非原子属性，不会为 setter■ 方法加锁，非线程安全。

#### <a id="线程通信" >线程间通信</a>

- -(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
- -(void)performSelector:(SEL)aSelector onThread:(NSThread \*)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
- <2>.GCD 实现
  子线程和主线程相互切换
- <3>.NSOperationQueue 实现

#### <a id="GCD任务、队列" >GCD 任务、队列</a>

- <1>同步和异步的区别
  - 同步：只能在当前线程中执行任务，不能幵启新线程
  - 异步：可在新的线程中执行任务，能幵启新线程
- <2>队列
  - 并发队列：可多个任务并发（同时）执行（会幵启多个线程同时执行任务）；只在异步函数 (dispatch_async)下有效
  - 串行队列：一个任务执行完毕后，再执行下一个任务 主队列：主队列中的任务都在主线程中执行
- 主队列特点：如果主队列发现当前主线程有任务在执行，那么主队列会暂停调用队列中的任 务，直到主线程空闲为止。如果在主线程中添加同步方法，则会发生死锁。

#### <a id="Runloop的应用" >Runloop 的应用</a>

- NSTimer 在子线程开启一个定时器；控制定时器在特定模式下执行
- imageView 的显示
- performSelector
- 常驻线程（让一个子线程不进入消亡状态，等待其他线程发来消息，处理其他事件)
- 自动释放池

#### <a id="@protocol 和 category 中如何使用 @property?" >@protocol 和 category 中如何使用 @property?</a>

- 1、 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明，使用属性的目的，是希望遵守该协议的对象能实现该属性
- 2、 category 使用@property 也是只会生成 setter 和 getter 方法声明，如果真的需
- 要给 category 增加属性的实现，需要借助于运行时的两个函数：
  - objc_setAssociatedObject
  - objc_getAssociatedObject

#### <a id="@property中有哪些属性关键字？" >@property 中有哪些属性关键字？</a>

- 1、 原子性一 nonatomic 特质
- 2、 读/写权限 一 readwrite(读写）、readonly (只读）
- 3、 内存管理语义一 assign、strong、weak、unsafe_unretainedN copy
- 4、 方法名一 getter=<\name> N setter=<\name>

#### <a id="weak属性需要在dealloc中置nil么？" >weak 属性需要在 dealloc 中置 nil 么？</a>

不需要，在 ARC 环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil，ARC 会自动帮 我们处理，即便是编译器不帮我们做这些，weak 也不需要在 dealloc 中置 nil，runtime 内部已经帮我们实现了

#### <a id="@synthesize和@dynamic分别有什么作用？" >@synthesize 和@dynamic 分别有什么作用？</a>

- 1、@property 有两个对应的词，一个是@synthesize，一个是@dynamic。如果@dynamic 都没写，那么默认的就是@syntheszie var = \_var;
- 2、@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译 器会自动为你加上这两个方法
- 3、@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生 成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供@setter 方法和@getter 方法，编译的时候没问题，但 是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃； 或者当运行到 someVar = var 日寸，由于缺 getter 方法同样会导致崩溃。编译时没问 题，运行时才执行相应的方法，这就是所谓的动态绑定。

#### <a id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" >ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a>

- 1、 基本数据类型：atomic、readwrite、assign
- 2、 普通 0C 对象：atomic、readwrite、strong

#### <a id="合成实例" >@synthesize 合成实例变量的规则是什么？假如 property 名为 foo， 存在一个名为\_foo 的实例变量，那么还会自动合成新变量么？</a>

- 不会合成。
- Synthesize 合成实例变量的规则，有以下几点：
  - 如果指定了成员变量的名称，会生成一个指定的名称的成员变量，
  - 如果这个成员已经存在了就不再生成了.
  - 如果是@synthesize foo;还会生成一个名称为 foo 的成员变量，也就是说：
  - 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量，
  - 如果是@synthesize foo = \_foo;就不会生成成员变量了.

#### <a id="在有了自动合成属性实例变量之后" >在有了自动合成属性实例变量之后，@synthesize 还有哪些使用场 景？</a>

- 1、 同时重写了 setter 和 getter 时，系统就不会生成 ivar，使用@synthesize foo =\_foo;关联 @property 与 ivar
- 2、 重写了只读属性的 getter 时
- 3、 使用了 @dynamic 时
- 4、 在@protocol 中定义的所有属性
- 5、 在 category 中定义的所有属性
- 6、 重载的属性，当在子类中重载了父类中的属性，必须使用 Synthesize 来手动合成 ivar

#### <a id="objc中向一个nil对象发送消息将会发生什么？" >objc 中向一个 nil 对象发送消息将会发生什么？</a>

在 Objective-C 中向 nil 发送消息是完全有效的一只是在运行时不会有任何作用 如果一个方法返回值是一个对象，那么发送给 nil 的消息将返回 0(nil)，如果向一个 nil 对 象发送消息，首先在寻找对象的 isa 指针时就是 0 地址返回了，所以不会出现任何错误。

#### <a id="objc 中向一个对象发送消息[" >objc 中向一个对象发送消息[obj foo]和 objc_msgSend ()函数之间 有什么关系？</a>

[obj foo];在 objc 动态编译时，每个方法在运行时会被动态转为消息发送，即为： objc_msgSend(obj, @selector(foo));

#### <a id="unrecognized selector" >什么时候会报 unrecognized selector 的异常？</a>

- 当调用该对象上某个方法，而该对象上没有实现这个方法的时候，可以通过“消息转发”进行 解决。
- objc 在向一个对象发送消息时，runtime 库会根据对象的 isa 指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类 中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常 unrecognized selector sent to XXX。但是在这之前，objc 的运行时会给出三次極救程序崩溃的机会：
- 1、 Method resolution
  objc 运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就 会移到下一步，消息转发（Message Forwarding)。
- 2、 Fast forwarding
  如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你 把这个消息转发给其他对象的机会。只要这个方法返回的不是 nil 和 self,整个消息发送的过程就会 被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续 Normal Fowarding。这里叫 Fast,只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个 NSInvocation 对象，所以相对更快点。
- 3、 Normal forwarding
  这*步是 Runtime 最后*次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获 得函数的参数和返回值类型。如果-methodSignatureForSelector:返回 nil, Runtime 则会发出- doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime 就 会创建一个 NSInvocation 对象并发送-forwardlnvocation:消息给目标对象。

#### <a id="一个objc对象如何进行内存布局？（考虑有父类的情况）" >一个 objc 对象如何进行内存布局？（考虑有父类的情况）</a>

- 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.
- 每一个对象内部都有一个 isa 指针，指向他的类对象，类对象中存放着本对象的：
  - 1 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）
  - 2 成员变量的列表，
  - 3 属性列表，
- 它内部也有一个 isa 指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个 superclass 的指针，指向他的父类对象。
- 根对象就是 NSObject，它的 superclass 指针指向 nil
- 类对象既然称为对象，那它也是一个实例。类对象中也有一个 isa 指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的 isa 指针指向自 己，superclass 指针指向 NSObject 类。

#### <a id="objc对象的isa指针指向什么？有什么作用？" >objc 对象的 isa 指针指向什么？有什么作用？</a>

指向他的类对象，从而可以找到对象上的方法

#### <a id="分别考虑类方法 和实例方法）" >runtime 如何通过 selector 找到对应的 IMP 地址？（分别考虑类方法 和实例方法）</a>

每一个类对象中都一个方法列表,方法列表中记录着方法名称、方法实现、参数类型，其实 selector 本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现.

#### <a id="NSStringFromClass([super class])" >NSStringFromClass([super class])</a>

```
@implementation Son : Father
-(id)init {
  self = [super init];
  if (self) {
    NSLog(@"%@", NSStringFromClass([self class]));
    NSLog(@"%@", NSStringFromClass([super class]));
  }
  return self;
}
@end
答案：
都输出Son
NSStringFromClass([self class]) = Son NSStringFromClass([super class]) = Son
```

这个题目主要是考察关于〇 bjective-C 中对 self 和 super 的理解。
我们都知道：self 是类的隐藏参数> 指向当前调闬方法的这个类的实例。其实 super 是一个 Magic Keyword，它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不 同点在子：super 会告泝编译器> 调用 class 这个方法时> 要去父类的方法，而不是本类里的。当 t 吏 调用方法时，会从当前类的方法列表中幵始找，如果没有，就从父类中再找；而当使用 super 时> 则从父类的方法列表中幵始找> 然后调用父类的这个方法。

#### <a id="使用runtimeAssociate方法" >使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的 时候释放么？</a>

- 无论在 MRC 下还是 ARC 下均不需要。
- 既然会被销毁，那么具体在什么时间点？
- 根据 WWDC 2011, Session 322(36'22'')中发布的内存销毀时间表，被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的 object_dispose[)方法中释放。
- //对象的内存销毁时间表
  - 1•调用-release :引用计数变为零
    - 对象正在被销毁，生命周期即将结束.
    - 不能再有新的\_weak 弱引用，否则将指向 nil.
    - 调用[self dealloc]
  - 2•子类调用-dealloc
    - 继承关系中最底层的子类在调用-dealloc
    - 如果是 MRC 代码则会手动释放实例变量们（iVars)
    - 继承关系中每一层的父类都在调用-dealloc
  - 3.NSObject 调用-dealloc
    - 只做一件事：调用 〇 bjective-C runtime 中的 object_dispose()方法
  - 4•调用 object_dispose()
    - 为 C++的实例变量们（iVars)调用 destructors
    - 为 ARC 状态下的实例变量们（iVars)调用-release
    - 解除所有使用 runtime Associate 方法关联的对象
    - 解除所有\_weak 引用
    - 调用 free()

#### <a id="objc中的类方法和实例方法有什么本质区别和联系？" >objc 中的类方法和实例方法有什么本质区别和联系？</a>

- 类方法：
  - 类方法是属于类对象的
  - 类方法只能通过类对象调用
  - 类方法中的 self 是类对象
  - 类方法可以调用其他的类方法
  - 类方法中不能访问成员变量
  - 类方法中不能直接调用对象方法
- 实例方法：
  - 实例方法是属于实例对象的
  - 实例方法只能通过实例对象调用
  - 实例方法中的 self 是实例对象
  - 实例方法中可以访问成员变量
  - 实例方法中直接调用实例方法
  - 实例方法中也可以调用类方法(通过类名）方法

#### <a id="_objc_msgForward函数是做什么的，直接调用它将会发生什么？" >\_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</a>

- objc_msgForward 是一个函数指针（和 imp 的类型一样），用于消息转发的：当向一个对象 发送一条消息，但它并没有实现的时候，\_objc\*msgForward 会尝试做消息转发。
- objc_msgSend 在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend 的动作比较清 晰：首先在 Class 中的缓存查找 IMP (没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用*〇 bjc*msgForward 函数指针代替 imp。最 后，执行这个 imp。
- \_ob j c_msgForward 消息转发做的几件事：
  - 调用 resolvelnstanceMethod:方法（或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回 YES，那么重新开始 objc_msgSend 流 程。这一次对象会响应这个选择器，一般是因为它已经调用过 classjddMethod。如果仍没 实现，继续下面的动作。
  - 调用 forwardingTargetForSelector:方法，尝试找到\*个能响应该消息的对象。如果获取 至 IJ，则直接把消息转发给它，返回非 nil 对象。否则返回 nil，继续下面的动作。注意， 这里不要返回 self，否则会形成死循环。
  - 调用 methodSignatureForSelector:方法，尝试获得\*个方法签名。如果获取不到，则直接 调用 doesNotRecognizeSelector 抛出异常。如果能获取，则返回非 nil:创建一个 NSlnvocation 并传给 forwardlnvocation: 0
  - 调用 forwardlnvocation:方法，将第 3 步获取到的方法签名包装成 Invocation 传入，如 何处理就在这里面了，并返回非 ni。
  - 调用 doesNotRecognizeSelector：，默认的实现是抛出异常。如果第 3 步没能获得\*个方法 签名，执行该步骤。
- 上面前 4 个方法均是模板方法，开发者可以 override,由 runtime 来调用。最常见的实现消息转 发：就是重写方法 3 和 4,吞掉一个消息或者代理给其他对象都是没问题的 也就是说\_objc_msgForward 在进行消息转发的过程中会涉及以下这几个方法：
  - resolvelnstanceMethod:方法（或 resolveClassMethod: )〇
  - forwardingTargetForSelector:方法
  - methodSignatureForSelector:方法
  - forwardlnvocation:方法
  - doesNotRecognizeSelector:方法
- 一旦调用\_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了\_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉 objc_msgSend: “我没有在这个对象里找到这个方法的实现”，  如果用不好会直接导致程序 Crash,但是如果用得好，做很多事情，比如]SPatch、 RAC(ReactiveCocoa)

#### <a id="runtime如何实现weak变量的自动置nil?" >runtime 如何实现 weak 变量的自动置 nil?</a>

- runtime 对注册的类，会进行布局，对于 weak 对象会放入一个 hash 表中。用 weak 指向的对象内存地址作为 key,当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a，那么就会以 a 为键，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置 为 nil。
- 我们可以设计一个函数（伪代码）来表示上述机制：
- objc_storeWeak(&a, b)函数：
- objc_storeWeak 函数把第二个参数--赋值对象（b)的内存地址作为键值 key,将第一个参数-- weak 修饰的属性变量（a)的内存地址（&a)作为 value,注册到 weak 表中。如果第二个参数 (b)为 0 (nil)，那么把变量（a)的内存地址（&a)从 weak 表中删除，
- 你可以把〇 bjc_storeWeak(&a, b)理解为：objc_storeWeak(value, key),并且当 key 变 nil,将 value 置 nil0
- weak 修饰的指针默认值是 nil (在〇 bjective-C 中向 nil 发送消息是安全的）
- 在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，aSnil。此时向 a 发送消息不会崩溃：在 Objective-C 中向 nil 发送消息是安全的。
- 而如果 a 是由 assign 修饰的，则：在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 非 nil 时，a 还是指 向该内存地址，变野指针。此时向 a 发送消息极易崩溃。

#### <a id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添 加实例变量？为什么？" >能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添 加实例变量？为什么？</a>

- 不能向编译后得到的类中增加实例变量；
- 能向运行时创建的类中添加实例变量；
  解释下：
- 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时 runtime 会调用 class_setlvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 弓 I 用。所以不能向存在的类中添加实例变量；
- 运行时创建的类是可以添加实例变量，调用 class_addlvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。

#### <a id="runloop和线程有什么关系？" >runloop 和线程有什么关系？</a>

- 实际上，run loop 和线程是紧密相连的，可以这样说 runloop 是为了线程而生，没有线程，它就没有存在的必要。Runloops 是线程的基础架构部分，Cocoa 和 CoreFundation 都提供了 runloop 对象方便配置和管理线程的 runloop (以下都以 Cocoa 为例）。每个线程，包括程序的主 线程（main thread )都有与之相应的 runloop 对象。
- runloop 和线程的关系：
  - 主线程的 run loop 默认是启动的。iOS 的应用程序里面，程序启动后会有一个如下的 main()函数

```
int main(int argc\_» char * argv[]) {
  @autoreleasepool {
    return UIApplicationlvlain(argcJ argv^ nil, NSStringFromClass( [AppDelegate class]));
  }
}
```

- 重点是 UIApplicationMain()函数，这个方法会为 main thread 设置一个 NSRunLoop 对象，这就解 释了 ：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
- 对其它线程来说，runloop 默认是没有启动的，如果你需要更多的线程交互则可以手动配置 和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。
- 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 runloop。 NSRunLoop \*runloop = [NSRunLoop currentRunLoop];

#### <a id="runloop的mode作用是什么？" >runloop 的 mode 作用是什么？</a>

model 主要是用来指定事件在运行循环中的优先级的，分为：

- NSDefaultRunLoopMode (kCFRunLoopDefaultMode):默认，空闲状态
- UlTrackingRunLoopMode: ScrollView 滑动时
- UllnitializationRunLoopMode:启动时
- NSRunLoopCommonModes (kCFRunLoopCommonModes) : Mode 集合
  苹果公开提供的 Mode 有两个：
- NSDefaultRunLoopMode (kCFRunLoopDefaultMode)
- NSRunLoopCommonModes (kCFRunLoopCommonModes)

#### <a id="+ scheduledTimerWithTimelnterval" >+ scheduledTimerWithTimelnterval. • •的方式触发的 timer， 在滑动页面上的列表时，timer 会暂定回调，为什么？如何解决？</a>

- Run Loop 只能运行在一种 mode 下，如果要换 mode,当前的 loop 也需要停下重启成新的。利用这个机制，ScrollView 滚动过程中 NSDefaultRunLoopMode (KCFRunLoopDefaultMode) 会切换到 UITrackingRunLoopMode 来保证 ScrollView 的流畅滑动：只有在 NSDefaultRunLoopMode 模式下处理的事件会影响 ScrollView 的滑动。
- 如果我们把一个 NSTimer 对象以 NSDefaultRunLoopMode (KCFRunLoopDefaultMode) 添加到主运行循环中的时候，ScroolView 滚动过程中会因为 mode 的切换，而导致 NSTime 将不再被调度。
- 同时因为 mode 还是可定制的，所以：
  Timer 计时会被 ScrollView 的滑动影响的问题可以通过将 tim e r 添加到 NSRunLoopCommonModes (kCFRunLoopCommonModes)来解决。

#### <a id="runloop内部是如" >猜想 runloop 内部是如何实现的？</a>

一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：

```
function loopO { initialize();
 do {
  var msg = get_next_msg();
  process_msg(msg);
 } while (msg != nil);
}

// 或使用伪代码来展示下：
int main(int angc, char \* argv[]) {

 //程序一直运行状态 while (AppIsRunning) {
 //睡眠状态，等待唤醒事件
 id whoWakesMe = SleepForWakingUp();
 // 得到唤醒事件
 id event = GetEvent(whoWakesMe);
 //开始处理事件 HandleEvent(event);
 }
  return
}
```

#### <a id="objc使用什么机制管理对象内存？" >objc 使用什么机制管理对象内存？</a>

通过 retainCount 的机制来决定对象是否需要释放。每次 runloop 的时候，都会检查对象的 retainCount，如果 retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。

#### <a id="ARC通过什么方式帮助开发者管理内存？" >ARC 通过什么方式帮助开发者管理内存？</a>

- ARC 相对于 MRC，不是在编译时添加 retain/release/autorelease 这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。
- 在编译期，ARC 用的是更底层的 C 接口实现的 retain/release/autorelease，这样做性能更好，也是为什么不能在 ARC 环境下手动 retain/release/autorelease，同时对同一上下文 的同一对象的成对 retain/release 操作进行优化（即忽略掉不必要的操作）；ARC 也包含运 行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述 下】

#### <a id="BAD_ACCESS在什么情况下出现？" >BAD_ACCESS 在什么情况下出现？</a>

- 访问了野指针，比如对一个已经释放的对象执行了 release、访问已经释放对象的成员变量或者发消息。死循环。
- BAD_ACCESS 报错属于内存访问错误，会导致程序崩溃，错误的原因是访问了野指针(悬挂指针)。野指针指的是本来指针指向的对象已经释放了，但指向该对象的指针没有置 nil，指针指向随机的未知的内存，程序还以为该指针指向那个对象，导致存在一些潜在的危险访问操作，这些危险访问操作无法被指针指向的未知内存所处理，就会导致 BAD_ACCESS 错误造成程序崩溃。访问的含义包括多种情况，例如:向野指针发送消息，读写野指针本来指向的对象的成员变量等等。

#### <a id="使用block时什么情况会发生引用循环，如何解决？" >使用 block 时什么情况会发生引用循环，如何解决？</a>

—个对象中强引用了 block,在 block 中又强引用了该对象，就会发生循环引用。

- 解决方法是将该对象使用\_weak 或者\_block 修饰符修饰之后再在 block 中使用。
  - id weak weakSelf = self;或者 weak \_typeof(&\*self)
    weakSelf = self 该方法可以设置宏
  - id —block weakSelf = self;
- 或者将其中一方强制置空 XXX = nil。

#### <a id="在block内如何修改block外部变量？" >在 block 内如何修改 block 外部变量？</a>

- Block 不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。
- \_\_block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。block 内部的变量会被 copy 到堆区，进而在 block 内部也可以修改外部变量的值。 block 也属于“函数”的范畴，变量进入 block,实际就是已经改变了作用域。

#### <a id="苹果是如何实现autoreleasepool的？" >苹果是如何实现 autoreleasepool 的？</a>

- autoreleasepool 以一个队列数组的形式实现，主要通过下列三个函数完成.
  - objc_autoreleasepoolPush
  - objc_autoreleasepoolPop
  - objc_autorelease
- 看函数名就可以知道，对 autorelease 分別执行 push,和 pop 操作。销毁对象时执行 release 操作。
- 举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用 域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：

#### <a id="不手动指定autoreleasepool的前提下" >不手动指定 autoreleasepool 的前提下，一个 autorealese 对象在什 么吋刻释放？（比如在一个 vc 的 viewDidLoad 中创建）</a>

- 分两种情况：手动干预释放时机、系统自动去释放
  - 手动干预释放时机--指定 autoreleasepool 就是所谓的：当前作用域大括号结束时释放。
  - 系统自动去释放…不手动指定 autoreleasepool
- Autorelease 对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放
- 释放的时机总结起来，可以用下图来表示：
  ![2020-08-16-17-21-13](http://files.pandaleo.cn/2020-08-16-17-21-13.png)
  下面对这张图进行详细的解释：
- 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都 会启动一次运行循环，来处理用户所有的点击事件、触摸事件。
- 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。
- 但是如果每次都放进应用程序的 main.m 中的 autoreleasepool 中，迟早有被撑满的\_刻。这个 过程中必定有一个释放的动作。何时？在一次完整的运行循环结束之前，会被销毁。
- 那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。
- 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。
- 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如：自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释 放池去处理它，而造成内存泄露。
- 但对于 blockOperation 和 invocationOperation 这种默认的 Operation，系统已经帮我们封装好了，不需要手动创建自动释放池。
- @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。
- 如果在一个 vc 的 viewDidLoad 中创建\_个 Autorelease 对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。

#### <a id="使用系统的某些" >使用系统的某些 block api (如 UlView 的 block 版本写动画时），是 否也考虑引用循环问题？</a>

- UlView 的 block 版本写动画时不需要考虑，所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self )没有问题，比如这些不用考虑:

```
[UlView animateWithDuration:duration animations:^{ [self.superview layoutlfNeeded]; }];
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];
[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification
object:nil queue:[NSOperationQueue mainQueue]
usingBlock:A(NSNotification *
self.someProperty = xyz; }];
```

- 如果你使用一些参数中可能含有 ivar 的系统 api，如 GCD、NSNotificationCenter 就要小心—点：比如 GCD 内部如果引用了 self,而且 GCD 的其他参数是 ivar，贝要考虑到循环引用：

```
__weak __typeof_(self) weakSelf = self; dispatch_group_async(_operationsGroupJ _operationsQueuej ^ {
  __typeof__(self) strongSelf = weakSelf;
  [strongSelf doSomething];
  [strongSelf doSomethingElse];
})；
```

- 类似的：

```
__weak __typeof__(self) weakSelf = self;
_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queueinil
usingBlock:^(NSNotification *note) {
  __typeof__(self) strongSelf = weakSelf;
  [strongSelf dismissModalViewControllerAnimated:YES];
}];

self --> _observer --> block --> self 显然这也是一个循环引用。
```

#### <a id="两种类型？" >GCD 的队列（dispatch_queue_t)分哪两种类型？</a>

- 串行队列 Serial Dispatch Queue
- 并行队列 Concurrent Dispatch Queue

#### <a id="加载多张图 片，然后在都下载完成后合成一张整图）" >如何用 GCD 同步若干个异步调用？（如根据若干个 url 异步加载多张图 片，然后在都下载完成后合成一张整图）</a>

- 使用 Dispatch Group 追加 fcilock 到 Global Group Queue，这些 fcilock 如果全部执行完毕，就会执
  行 Main Dispatch Queue 中的结束处理的 block。

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group) queue) A{ /*加载图片 1 */ });
dispatch_group_async(group) queue) A{ /*加载图片2 */ });
dispatch_group_async(group) queue) A{ /*加载图片3 */ });
dispatch_group_notify(group, dispatch_get_main_queue()_» A{
//合并图片
});
```

![2020-08-16-17-37-06](http://files.pandaleo.cn/2020-08-16-17-37-06.png)

#### <a id="dispatch_barrier_async 的作用是什么？" >dispatch_barrier_async 的作用是什么？</a>

- 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 并行队列中的操作全部执行完之后，然后再执行 dispatch barrier async 函数追加的处理，等 dispatch barrier async 追加的处理执行结束之后，Concurrent Dispatch Queue 才恢复之前的动作继续执行。
- (注意：使用 dispatch_barrier_async，该函数只能搭配自定义并行队列 dispatch queue t 使用。不能使用：dispatch_get_global_queue，否则 dispateh barrier async 的作用会和 dispatch async 的作用一模一样〇 )

#### <a id="苹果为什么要废弃 dispatch_get_current_queue?" >苹果为什么要废弃 dispatch_get_current_queue?</a>

dispatch_get_current_queue 容易造成死锁

#### <a id="dispatch_sync(dispatch_get_main_queue(),^{});" >dispatch_sync(dispatch_get_main_queue(),^{});</a>

- 发生主线程死锁
  ![2020-08-16-17-41-25](http://files.pandaleo.cn/2020-08-16-17-41-25.png)

#### <a id="addObserver:forKeyPath" >addObserver:forKeyPath:options:context:各个参数的作用分别是什 么，observer 中需要实现哪个方法才能获得 KVO 回调？</a>

```
//添加键值观察
/*
1观察者，负责处理监听事件的对象
2观察的属性
3观察的选项
4上下文
*/
[self.person addObserver:self forKeyPath:@"name"
options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];
// observer中需要实现一下方法：
//所有的kvo监听到事件，都会调用此方法
/*
1 观察的属性
2 观察的对象
3 change属性变化字典（新/旧>
4 上下文，与监听的时候传递的一致
*/
-(void)observeValueForKeyPath:(NSString ^)keyPath ofObject:(id)object change:(NSDictionary ^)change context:(void ^)context;
```

#### <a id="如何手动触发一个value的KVO?" >如何手动触发一个 value 的 KVO?</a>

- 所谓的“手动触发”是区别于“自动触发”：
- 自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。
- 自动触发 KVO 的原理：
- 键值观察通知依赖于 NSObject 的两个方法：willChangeValueForKey:和 didChangevlueForKey:。在一个被观察属性发生改变之前，willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context:会被调用，继而 didChangeValueForKey:也会被调用。如果可以手动实现这些调用，就可以实现“手动触 发”了。

- “手动触发”的使用场景是什么？ 一般我们只在希望能控制“回调的调用时机”时才会这么做。 而“回调的调用时机”就是在你调用 didChangeValueForKey:方法时。
- 具体做法如下：
- 如果这个 value 是表示时间的 self.now，那么代码如下：最后两行代码缺一不可。

```
//@property (nonatomic, strong) NSDate *now;
-(void)viewDidLoad {
  [super viewDidLoad];
  _now = [NSDate date];
  [self addObserver:self forKeyPath:@Mnow" options:NSKeyValueObservingOptionNew context:nil];
  NSLog(@"l");
  [self willChangeValueForKey :@"now"]; //“手动触发 self .now 的 KVO’’，必写。
  NSLog(@”2”）；
  [self didChangeValueForKey :@"now"]; //“手动触发 self .now 的 KVO’’，必写。
  NSLog(@"4M);
}
```

- 但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：
- 比如调用 setNow:时，系统还会以某种方式在中间插入 wilChangeValueForKey:、 didChangeValueForKey:和 observeValueForKeyPath:ofObject:change:context:的调用。

#### <a id="用 setValue:" >若一个类有实例变量 NSString \*\_foo，调用 setValue:forKey:时，可以以 foo 还是\_foo 作为 key?</a>

都可以。

#### <a id="KVC的keyPath中的集合运算符如何使用？" >KVC 的 keyPath 中的集合运算符如何使用？</a>

- 必須用在集合对象上或普通对象的集合属性上
- 简单集合运算符有@avg，@count ，@max ，@min， @sum
- 格式 @"@sum.age"，或 @"集合属性.@max.age"

#### <a id="KVC和KVO的keyPath—定是属性么？" >KVC 和 KVO 的 keyPath—定是属性么？</a>

- KVC 支持实例变量；
- 如果将一个对象设定成属性，这个属性是自动支持 KVO 的；如果这个对象是一个实例变量，那么这个 KVO 是需要我们自己来实现的。手动支持
- 手动设定实例变量的 KV0 实现监听，如下图：
  ![2020-08-16-18-37-22](http://files.pandaleo.cn/2020-08-16-18-37-22.png)

#### <a id="如何关闭默认的KVO的默认实现，并进入自定义的KVO实现?" >如何关闭默认的 KVO 的默认实现，并进入自定义的 KVO 实现?</a>

- 利用 Runtime 动态创建类、实现 KVO
  链接：http：//tech.globing.com/cn/implement-kvo/

#### <a id="apple用什么方式实现对一个对象的KVO?" >apple 用什么方式实现对一个对象的 KVO?</a>

- KVO 实现：
- 在使用 KVC 命名约定时，当你观察一个对象时，一个新的类会被动态创建。这个类继承自该 对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa- swizzling)把这个对象的 isa 指针（isa 指针告诉 Runtime 系统这个对象的类是什 么）指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。
- 实现原理如下图：
  ![2020-08-16-18-42-47](http://files.pandaleo.cn/2020-08-16-18-42-47.png)
- Apple 使用了 isa 混写（isa-swizzling)来实现 KW。
- KVO 在调用存取方法之前总是调用 willChangeValueForKey:，之后总是调用 didChangeValueForkey:。怎么做到的呢？答案是通过 isa 混写（isa-swizzling)。第 一次对一个对象调用 addObserver:forKeyPath:options:context:时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中，Cocoa 创建观察属性的 setter ,大致工作原理如下：

```
-(void)setNow:(NSDate *)aDate {
  [self willChangeValueForKey: @"now"];
  [super setValue:aData forkey: @"now"];
  [self didChangeValueForKey: @"now"];
}
```

#### <a id="IB0utlet连出来的视图属性为什么可以被设置成weak?" >IB0utlet 连出来的视图属性为什么可以被设置成 weak?</a>

- 因为有外链，那么视图在 xib 或者 storyboard 中肯定存在，视图已经对它有一个强引用了。
- 不过这个回答漏了个重要知识，使用 storyboard (xib 不行）创建的 vc,会有一个叫 \_topLevelObjectsToKeepAliveFromStoryboard 的私有数组强引用所有 top level 的对象，所以这时即便 outlet 声明成 weak 也没关系。

#### <a id="UserefinedRuntimeAttributes" >IB 中 User Defined Runtime Attributes 如何使用？（应该知道在哪吧）</a>

它能够通过 KVC 的方式配置一些你在 interface builder 中不能配置的属性。当你希望在 IB 中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的 Viewcontroller。

#### <a id="如何调试BAD_ACCESS错误" >如何调试 BAD_ACCESS 错误</a>

- 1、 重写 object 的 respondsToSelector 方法，显示出现 EXEC_BAD_ACCESS 前访问的最后一 个 object
- 2、 通过 Zombie
  ![2020-08-16-18-49-33](http://files.pandaleo.cn/2020-08-16-18-49-33.png)
- 3、 设置全局断点快速定位问题代码所在行
- 4、 Xcode 7 已经集成了 BAD_ACCESS 捕获功能：Address Sanitizer。 Build Settings 中勾选 Enable Address Sanitizer

#### <a id="iOS容易引起“循环引用”的几种场景" >iOS 容易引起“循环引用”的几种场景</a>

- 最简单的理解：对象 A 持有对象 B，对象 B 又持有对象 A，就会造成循环引用
- 1、 parent-child 相互持有、委托模式
- 2、 block:  
  隐式（间接）循环引用。ObjectA 持有 ObjectB，ObjectB 持有 block。那么在 block 中调用 ObjectA 的 self 会造成间接循环引用；
  即使在你的 block 代码中没有显式地出现”self”，也会出现循环引用！只要你在 block 里用到了 self 所拥有的东西！
  显式循环引用，编译器会报警告，在 block 引用 self 的时候最好使用 weak-strong dance 技术。
- 3、 NSTimer:  
  NSTimer 会持有对象，所以：在删除对象之前，需要[timer invalidate]。

```
@interface FtKeepAlive : NSObject
{
  NSTimer*	_keepAliveTimer; // 发送心跳timer
}
//实现文件
_keepAliveTimer = [NSTimer scheduledTimerWithTimelnterval:_expired target: self selector:@selector(keepLiveStart) userlnfornil repeats:YES];
```

如上代码，类持有\_keepAliveTimer，\_keepAliveTimer 又持有 self,造成循环引用。

- 4、 比如把 self 加入 array 中。也会造成循环引用
- 5、 使用类别添加属性  
  有一个类 A，给 A 动态添加属性 p。如果 p 中再引用类 A，容易造成循环引用

#### <a id="lldb (gdb)常用的调试命令？" >lldb (gdb)常用的调试命令？</a>

- breakpoint 设置断点定位到某一个函数
- n 断点指针下一步
- po 打印对象

#### <a id="类方法load和initialize的区别" >类方法 load 和 initialize 的区别</a>

- iOS 会在运行期提前并且自动调用这两个方法。
- 区别：load 是只要类所在文件被引用就会被调用，而 initialize 是在类或者其子类的第一个方法被调用前调用（runtime 对+(void)load 的调用并不视为类的第一个方法）。所以如果类没有被引用进项目，就不会有 load 调用；但即使类文件被引用，但是没有使用，那么 initialize 也不会被调用。 相同点在于：方法只会被调用一次。（其实这是相对 runtime 来说的）。
- 方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别 (Category)中的方法。

|                                | +(void)load                | +(voidinitialize           |
| ------------------------------ | -------------------------- | -------------------------- |
| 执行时机                       | 在程序运行后立即执行       | 在类的方法第一次被调用执行 |
| 若自身未定义，是否沿父类的方法 | 否                         | 是                         |
| 类别中的定义                   | 全都执行，但后于类中的方法 | 覆盖类中的方法，只执行一个 |

- 当类对象被引入项目吋，runtime 会向每一个类对象发送 load 消息.load 方法还是非常的神奇的，因为它会在每一个类甚至分类被引入吋仅调用一次，调用的顺序是父类优先于子类，子类优先 于分类.而且 load 方法不会被类自动继承，每一个类中的 load 方法都不需要像 viewDidLoad 方法一样调用父类的方法。

#### <a id="HTTP 和 HTTPS" >HTTP 和 HTTPS</a>

![2020-08-16-19-06-01](http://files.pandaleo.cn/2020-08-16-19-06-01.png)

- HTTP 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)， 用于从 WWW 服务器传输超文本到本地浏览器的传输协议。HTTP 是采用明文形式进行数据传输，极易被不法份子窃取和篡改。
- HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。HTTPS 主要作用是：
  - 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全；
  - 对网站服务器进行真实身份认证。
- 区别：
  - 1、 HTTPS 是加密传输协议，HTTP 是名文传输协议；
  - 2、 HTTPS 需要用到 SSL 证书，而 HTTP 不用；
  - 3、 HTTPS 比 HTTP 更加安全，对搜索引擎更友好
  - 4、 HTTPS 标准端口 443，HTTP 标准端口 80;
  - 5、 HTTPS 基于传输层，HTTP 基于应用层；
  - 6、 HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示；
- 如下图 HTTP 和 HTTPS 的网络分层：
  ![2020-08-16-19-07-29](http://files.pandaleo.cn/2020-08-16-19-07-29.png)

#### <a id="常见的 Exception Type" >常见的 Exception Type</a>

- 1> EXC_BAD_ACCESS  
  此类型的 Excpetion 是我们最长碰到的 Crash,通常用于访问了不该访问的内存导致。一般 EXC_BAD_ACC ESS 后面的"（）"还会带有补充信息。
  - SIGSEGV:通常由于重复释放对象导致，这种类型在切换了 ARC 以后应该已经很少见到了
  - SIGABRT:收到 Abort 信号退出，通常 Foundation 库中的容器为了保护状态正常会做\_些检测，例如 插入 nil 到数组中等会遇到此类错误
  - SEGV: (Segmentation Violation),代表无效内存地址，比如空指针，未初始化指针，栈溢出等
  - SIGBUS:总线错误，与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址，而 SIGBUS 访问的是有 效地址，但总线访问异常（如地址对齐问题）
  - SIGILL:尝试执行非法的指令，可能不被识别或者没有权限
- 2> EXC_BAD_INSTRUCTION  
  此类异常通常由于线程执行非法指令导致
- 3> EXC_ARITHMETIC  
  除零错误会抛出此类异常
- 处理此类异常方式：符号化 Crash 日志。比较常用的有 Crashlytics、Flurry、友盟等。

#### <a id="Category 和 Extension" >Category 和 Extension</a>

- Category 的方法不一定非要在 implementation 中实现，也可以在其他位置实现，但是当调用 Category 的方法时，依据继承树没有找到该方法的实现，程序则会崩溃。
- Category 理论上不能添加变量，但是可以使用@dynamic 来弥补这种不足。
- Category 为原始类添加方法，必须要小心不要去重写已经存在的方法
- Extension 中的方法必须在 implementation 中实现，否则编译会报错。
- Extension 管理类的私有方法

#### <a id="响应者链resp" >响应者链（responder chain)</a>

![2020-08-16-19-13-14](http://files.pandaleo.cn/2020-08-16-19-13-14.png)

- 如上图，响应者链有以下特点：

  - 响应者链通常是由 initial view 幵始；
  - UlView 的 nextResponder 它的 superview;如果 UlView 已经是其所在的 UlViewController 的 top view，那么 UlView 的 nextRespondr 就是 UlViewController ；
  - UlViewController 如果有 Super ViewController，那么它的 nextResponde›r 为其 Super ViewController 最表层的 View;如果没有，那么它的 nextResponder 就是 UlWindow；
  - UlWindow 的 contentView 指向 UIApplication，将其作为 nextResponder;
  - UIApplication 是一个响应者链的终点，它的 nextResponder 指向 nil，整个 responder chain 结束。

![2020-08-16-19-16-59](http://files.pandaleo.cn/2020-08-16-19-16-59.png)

- 假设用户触摸了上图的 View E 区域，那么 iOS 将会按下面的顺序反复检测 subview 来寻找 Hit-Test View
  - 触摸区域在视图 A 内，所以检测视图 A 的 subview B 和 C;
  - 触摸区域不在视图 B 内，但是在视图 C 内，所以检查视图 C 的 subview D 和 E;
  - 触摸区域不在视图 D 内，在视图 E 中；
- 视图 E 在整个视图体系中是 lowest view,所以视图 E 就是 Hit-Test View。
- 事件的链有两条：事件的响应链；Hit-Testing 时事件的传递链。
  - 响应链：由离用户最近的 view 向系统传递。initial view -> super view -> view controller -> window -> Application -> AppDelegate
  - Hit-Testing 链：由系统向离用户最近的 view 传递。UIKit -> active app's event queue -> window -> root view ->••••••->lowest view

#### <a id="UITableView的优化" >UITableView 的优化</a>

- 1 重用 cell
- 2 缓存行高
  - •若 cell 定高，删除代理中的方法 tableView:heightForRowAtIndexPath:方法，  
    设置 self.tableView.rowHeight = 88;
  - 若 cell 不定高，不要设置 estimatedHeightForRow(因为 estimatedHeightForRow 不能和 heightForRow 里面的 layoutlfNeed 同时存在，这两者同时存在会出现“窜 动”的 bug),解决方法是在请求到数据的时候提前计算好行高，用个字典缓存好高度；
- 3 加载网络数据，下载图片，使用异步加载，并缓存，从网络搂回来图片后先根据需要显示 的图片大小切成合适大小的图，每次只显示处理过大小的图片，当查看大图时在显示大图 ，如果服务器能直接返回预处理好的小图和图片的大小更好。图片数量多时，必要的时候 要准备好预览图和高清图，需要时再加载高清图，图片的懒加载方法，即延迟加载，当 滚动速度很快时避免频繁请求服务器数据。
- 4 使用局部刷新
  - 尽量不要使用 reloadData，刷新某一分组、某一行使用对应的方法做局部刷新
- 5 渲染，尽量少用或不用透明图层
  - •将 cell 的 opaque 值设为 Yes,背景色和子 view 不要使用 clearColor，尽量不要使用 阴影渐变、透明度也不要设置为 0
- 6 少用 addSubview 给 Cell 动态添加子 View，初始化时直接设置好，通过 hidden 控制显示隐 藏，布局也在初始化时直接布局好，避免 cell 的重新布局
- 7 如果 cell 内显示的内容来自 web，使用异步加载，缓存结果请求。
- 8 按需加载 cell，cell 滚动很快吋，只加载范围内的 cell，如果目标行与当前行相差超过››指定行数，只在目标滚动范围的前后制定 n 行加载。滚动很快吋，只加载目标范围内的 cell，这样按需加载，极大地提高了流畅性。方法如下：
  ![2020-08-16-19-23-34](http://files.pandaleo.cn/2020-08-16-19-23-34.png)

- 记得在"tableView: cellForRowAtlndexPath:方法中加入判断:

```
if (needLoadArr.count>0&&[needLoadArr indexOfObject:indexPath]==NSNotFound) {

  [cell clear];
  return;
}
```

- 滚动很快吋，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。

- 9 遇到复杂界面，像朋友圈涉及图文混排的，需要异步绘制。
  - 继承 UITableViewCell，给自定义的 Cell 添加 draw 方法，在方法中利用 GCD 异步绘制；或者直接重写 drawRect 方法。但如果在重写 drawRect 方法就不需要用 GCD 异步线程了，因为 drawRect 本来就是异步绘制
  - 绘制 cell 不建议使用 UlView，建议使用 CALayer。UlView 的绘制是建立在 CoreGraphic 上的，使用的是 CPU。CALaye 使用的是 Core Animation, CPU、GPU 通吃，由系统决定使用哪个。View 的绘制使用的是自下向上的一层一层的绘制，然后渲染 Layer 处理的是 Texure，利用 GPU 的 Texture Cache 和独立的浮点数计算单元加速纹理的处理。GPU 不喜欢透明，所以所有的绘图一定要弄成不透明，对于圆角和阴影这些的可以截个伪透明的小图然后绘制上去。在 layer 的回调里一定也只做绘图，不做计算！
  - cell 被重用时，它内部绘制的内容并不会被自动清除，因此需要调用 setNeedsDisplay 或 setNeedsDisplaylnReciz:方法

#### <a id="离屏這染Offscreen-Renderd" >离屏這染（Offscreen-Renderd)</a>

- 下面的情况或操作会引发离屏渲染：
  - 为图层设置遮罩（layer.mask)
  - 将图层的 layer.masksToBounds / view.clipsToBounds 属性设置为 true
  - 将图层 layer.allowsGroupOpacity 属性设置为 YES 和 layer .opacity 小于 1.0
  - 为图层设置阴影（layer.shadow \*)。
  - 为图层设置 layer_shouldRasterize=true (光栅化）
  - 具有 layer.cornerRadius, layer.edgeAntialiasingMask, layer.allowsEdgeAntialiasing 的图层（圆角、抗据齿）
  - 文本（任何种类，包括 UILabel, CATextLayer、Core Text 等）
  - 使用 CGContext 在 drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空 的实现
- 优化方案
  - 圆角优化使用 CAShapeLayer 和 UIBezierPath 设置圆角；直接覆盖一张中间为圆形透明的图片（推荐使用）
  - shadow 优化使用 ShadowPath 指定 layer 阴影效果路径，优化性能 使用异步进行 layer 渲染（Facebook 开源的异步绘制框架 AsyncDisplayKit)
  - 设置 layer 的 opaque 值为 YES,减少复杂图层合成 尽量使用不包含透明（alpha)通道的图片资源 尽量设置 layer 的大小值为整形值
- Core Animation 工具检测离屏渲染  
  对于离屏渲染的检测，苹果为我们提供了一个测试工具 Core Animation 可以在 Xcode- >Open Develeper Tools->Instruments 中找到，如下图:
  ![2020-08-16-19-34-35](http://files.pandaleo.cn/2020-08-16-19-34-35.png)
  - 洋红色是因为像素没对齐，比如上面的 label, —般情况下因为像素没对齐，需要抗锯齿，图像会 出现模糊的现象。
  - 解决办法：在设置 view 的 frame 时，在高分屏避免出现 21.3，6.7 这样的小数，尤其是 X，y 坐 标，用 ceil 或 floor 或 round 取整。每 0.5 个点对应一个 pixel, 0.3,0.7 这样的就难为 iPhone 了，低分屏不要出现小数。
  - 黄色是因为显示的图片实际大小与显示大小不同，对图片进行了拉伸，测试显示使用 image view 显示实际大小的图也会变黄。
  - 减少洋红色和黄色可以提升滚动的流畅性

#### <a id="UIView 和 CALayer" >UIView 和 CALayer</a>

- UlView 是 iOS 中所有的界面元素都继承自它，它本身完全是由 CoreAnimation 来实现的。每一个 UlView 内部都默认关联着一个 layer,真正的绘图部分，是由一个叫 CALayer (Core Animation Layer)的类来管理；
- UlView 有个 layer 属性，可以返回它的主 CALayer 实例，UlView 有一个 layerClass 方法，返回主 layer 所使用的类，UlView 的子类，可以通过重载这个方法，来让 UlView 使用不同的 CALayer 来显示；
- UlView 的 layer 树形在系统内部，被维护着三份 copy (presentLayer Tree、modeLayer Tree、 render Tree)，修改动画的属性，其实是 Layer 的 present Layer 的属性值；
- 动画的运作：对 UlView 的 subLayer (非主 Layer)属性进行更改，系统将自动进行动画生成。
- 区别
  - UlView 继承自 UIResponder，能接收并响应事件，负责显示内容的管理；而 CALayer 继承自 NSObject，不能响应事件，负责显示内容的绘制；
  - UlView 侧重于展示内容，而 CALayer 则侧重于图形和界面的绘制；
  - 当 View 展示的时候，View 是 layer 的 CALayerDelegate，View 展示的内容是由 CALayer 进行 display 白勺；
  - view 内容展示依赖 CALayer 对内容的绘制，UlView 的 frame 也是由内部的 CALayer 进行绘制；
  - 对 UlView 的属性修改，不会引起动画效果，但是对于 CALayer 的属性修改，是支持默认动画效果 的，在 view 执行动画的时候，view 是 layer 的代理，layer 通过 actionForLayer: forkey 向对应的 代理 view 请求动画 action;
  - 每个 UlView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UlView 的尺寸样式 都由内部的 Layer 所提供，layer 比 view 多了个 anchorPoint;
  - 一个 CALayer 的 frame 是由其 anchorPoint, position, bounds, transform 共同决定的，而一个 UlView 的的 frame 只是简单地返回 CALayer 的 frame,同样 UlView 的 center 和 bounds 也只是简单 返回 CALayer 的 Posit ion 和 Bounds 对应属性。

#### <a id="TCP 和 UDP" >TCP 和 UDP</a>

- TCP:传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须 先在双方之间建立一个 TCP 连接，一个 TCP 连接必须要经过“三次握手”才能建立起来，之后才能传输 数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
- UDP:用户数据报协议，是面向数据报的运输层协议。它是面向非连接的协议，它不与对方建立连 接，而是直接就把数据包发送过去！ UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环 境。UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达 目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制， 故而传输速度很快
- tcp 协议和 udp 协议的差别
  - tcp-面向连接 udp-面向非连接
  - tcp-传输可靠 udp-不可靠
  - tcp-传输大量数据 udp-少量数据
  - tcp-速度慢 udp-快
- TCP 连接的三次握手
  - 第一次握手：客户端发送 syn 包（Syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；
  - 第二次握手：服务器收到 syn 包，必须确认客户的 SYN (ack=j+l)，同时自己也发送一个 SYN 包 (syn=k)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
  - 第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(aCk=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
- 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状 态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下 去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手” (过程就不细写了，就是服务器和客户端交互，最终确定断开）

#### <a id="socket 和 http" >socket 和 http</a>

- socket 连接和 http 连接的区别
  - http 是基于 socket 之上的。socket 是一套完成 tcp，udp 协议的接口。
  - HTTP 协议：简单对象访问协议，对应于应用层，HTTP 协议是基于 TCP 连接的
  - tcp 协议： 对应于传输层
  - ip 协议： 对应于网络层
  - TCP/IP 是传输层协议，主要解决数据如何在网络中传输；而 HTTP 是应用层协议，主要解决如何包装数据。
  - Socket 是对 TCP/IP 协议的封装，Socket 本身并不是协议，而是一个调用接口，通过 Socket,我们才 能使用 TCP/IP 协议。
  - http 连接：短连接，即客户端向服务器端发送一次请求，服务端响应后连接，请求结束后，会主动释 放连接即会断掉
  - socket 连接：长连接，理论上客户端和服务端一旦建立连接将不会主动断掉；但由于各种因素可能 会断开，比如：服务端或客户端主机 down 了，网络故障，或两者之间长时间没有数据传输，网络防火 墙可能会断开该连接以释放网络资源。所以当一个 socket 连接中没有数据的传输，为了维持连接需要发送心跳消息；
- socket 建立网络连接的步骤
  - 建立 socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket，另一个运行 于服务器端，称为 ServerSocket。
  - 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
  - 1 服务器监听：服务端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网 络状态，等待客户端的连接请求。
  - 2 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务端的套接字。为此，客户端的 套接字必须首先描述它要连接的服务器的套接字，指出服务端套接字的地址和端口号，然后就向服务 端套接字提出连接请求。
  - 3 连接确认：当服务端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字 的请求，建立一个新的线程，把服务端套接字的描述发给客户端，一旦客户端确认了此描述，双方就 正式建立连接。而服务端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
- socket 编程中（荐研究 GCDAsyncSocket)的断线重连机制
- 断线重连：使得 IM 软件能够长在线，或者短时间内掉线，最好可以做到用户无感知。目的是让 IM 软件 维持在线的状态。
- 实现方法
  - IM 客户端始终尽可能的保持连接跟服务器的连接，客户端维护已登录状态，以便断线重连。从逻辑层 次上来说，断线重连的逻辑是基于登录逻辑的，首次登录成功后，都有可能断线重连 断线重连，实质分两步：一、使客户端断线；二、让客户端重连服务器。一般来说这两步是一个有前 后顺序，完整的过程。
  - 一、使客户端断线，即让客户端处于“未连接”状态。以下情况将触发这个事件：
    - 网络切换，如从 WiFi 切换到 4G，网络事件。
    - 网络连接失败、网络不可用。
    - 心跳失败、心跳超时，统称心跳失败。
    - IM 软件后台运行即将结束。
  - 二、让客户端重连服务器，客户端根据以下几种情况实现重连服务器。
    - iOS 系统“网络可用”的通知
    - IM 软件切换到前台，用户触发事件。
    - 网络切换，如从 WiFi 切换到 4G，网络事件。
    - 心跳失败的事件。
    - 客户端重新启动事件。
  - 断线重连的场景总结为：
    - •重新启动（自动登录）  
      需要提前加载用户缓存，保证用户到达主界面后能看到历史信息。
    - 网络错误，网络切换  
      网络连接失败有很多种，不同的场景，客户端要使用不同的逻辑处理。
    - 心跳失败  
      心跳超时，失败统称心跳失败。这个案例说明当前客户端一服务器连接已经损坏，或者当前用户身份有变化。心跳失败后首先将客户端离线，然后进行断线重连操作，避免心跳失败和网络错误事件一并 发生，造成两次登录。
    - 网络可达或者切换到前台  
      为了避免重复登录，当 IM 软件处于“登录成功'“连接中”或者“已注销”的几个状态的时候，客户端 忽略“网络可达或者切换到前台”的事件。
- 客户端心跳  
  IM 基本的底层逻辑中有“心跳”概念，即客户端定时向 Server 发一个信令包，表示客户端还“活” 着。注意，是客户端发起的。那么心跳终止了会发生什么事情呢？分两种情况：Server 主动断开 socket,客户端主动断开 socket。
- Server 主云力断开 socket  
  Server 只是接收客户端发起的心跳。假如，Server 长时间没有收到客户端的心跳，Server 认为客户 端已经“死了”，主动断开这个连接。此时客户端可能就是假在线了。
- 2 •客户端断开 socket  
  客户端对待心跳，要比 Server 麻烦一些。客户端要关注两个值：
  - •心跳间隔值，即客户端多长时间发一次心跳？
  - •心跳的超时时间。客户端发送一次心跳，如果长时间得不到 Server 应答，代表网络糟糕。客户端 需要断开 socket,主动离线。
  - 很明显，第二点就是客户端主动断开的情况，一般情况下，超时时间为 60 秒。
- 网上也有争论：到底是否需要心跳，微信是没有心跳的，qq 和飞信有心跳。也有专家说心跳包已经影响到移动网络，因为心跳是定时频繁发送。
- 下面是“心跳失败”引起的断线重连的流程图
  ![2020-08-16-19-41-28](http://files.pandaleo.cn/2020-08-16-19-41-28.png)

#### <a id="远程推送APNS" >远程推送 APNS</a>

- 远程推送的基本过程
- 1 客户端的 app 需要将用户的 UDID 和 app 的 bundlelD 发送给 apns 服务器，进行注册，apns 将 加密后的 device Token 返回给 app;
- 2 app 获得 device To ken 后，上传到公司服务器；
- 3 当需要推送通知时，公司服务器会将推送内容和 device Token—起发给 apns 服务器；
- 4 apns 再将推送内容推送到相应的客户端 a pp 上。

#### <a id="iOS应用程序生命周期" >iOS 应用程序生命周期</a>

i 〇 s 程序启动原理（过程）：如下
![2020-08-16-19-57-52](http://files.pandaleo.cn/2020-08-16-19-57-52.png)
appdelegate 执行顺序：如下
![2020-08-16-19-58-42](http://files.pandaleo.cn/2020-08-16-19-58-42.png)

- 1、应用稃序的状恐 状恐如下：
  - Not running 末运行 稃序没启动
  - inactive 末激活 稃序在前台运行,不过设有收到。在没有事件处理情况下稃序通常停留在这个状恐
  - Active 激活 稃序在前台运行而且接收到了事件。这也是前台的个正常的梗式
  - Backgroud 后台 稃序在后台而且能执行代码，大多数程序进入后台会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended〉。有的程序经过特殊的请求后可以长期处于 Background 状态。
  - Suspended 挂起 稃序在后台不能执行代码。系纸会自动把程序变成这个状态而且不会发出通知。 当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。
- 下图是程序状态变化图：
  ![2020-08-16-20-06-01](http://files.pandaleo.cn/2020-08-16-20-06-01.png)

```
UIApplicationMain
UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName);
/*
argc:系统或者用户传入的参数个数
argv:系统或者用户传入的实际参数
argc、argv:直接传递给UIApplicationMain进行相关处理即可
1. principalClassName:指定应用程序类名（app的象征），该类必须是UIApplication(或 子类）。如果为nil,则系统默认UIApplication类
2. delegateClassName:创建并设置UIApplication对象的代理，指定应用程序的代理类，该 类必须遵守UIApplicationDelegate协议
UIApplicationMain 函数会根据 principalCla ssName 创建 UIApplication 对象，根据 delegateClassName创建一fdelegate对象，并将该delegate对象赋值给UIApplication 对象中的delegate属性
3. 接着会建立应用的Main Runloop (事件循环），处理与用户交互产生的事件(首先会在程序 完毕后调用 delegate 对象白勺 application: didFinishLaunchingWithOptions:方法）
程序正常退出时UIApplicationMain函数才返回
*/
```

#### <a id="view视图生命周期" >view 视图生命周期</a>

- 视图创建：调用 viewDidLoad 方法
- 视图即将可见：调用 viewWillAppear 方法
- 视图已经可见：调用 viewDidAppear 方法
- 视图即将不可见：调用 viewWillDisappear 方法
- 视图已经不可见：调用 viewDidDisappear 方法
- 系统低内存：调用 didReceiveMemoryWarning 方法和 viewDidUnload 方法
- 注意：
  - 1 viewDidLoad 方法在应用运行的时候只会调用一次，其他方法会被调用多次。
  - 2 低内存情况下，iOS 会调用 didReceiveMemoryWarning 和 viewDidUnLoad 方法，但是 iOS6 以后就不在使用 viewDidUnLoad 方法，仅支持 didReceiveMemoryWarning 方法，该方法主要用于释放内存 (视图控制器中的一些成员变量和视图的释放）。

#### <a id="autorelease pool" >autorelease pool</a>

- autorelease 的原理是什么？  
  autorelease 实际上只是把对 release 的调用延迟了，对于每一个 autorelease，系统只是把该 Object 放入了当前的 Autorelease pool 中，当该 pool 被释放时，该 pool 中的所有 Object 会被调用 Release。
- autorelease 的对象何时释放？
  - 对于 autorelease pool 本身，会在如下两个条件发生时候被释放
    - 1、 手动释放 Autorelease pool
    - 2、 Runloop 结束后自动释放
  - 对于 autorelease pool 内部的对象在引用计数==0 的时候释放。release 和 autorelease pool 的 drain 都会触发引用计数减一。
- NSAutoreleasePool 是什么？
  - NSAutoreleasePool 实际上是个对象引用计数自动处理器，在官方文档中被称为是一个类。 NSAutoreleasePool 可以同时有多个，它的组织是个栈，总是存在一个栈顶 pool,也就是当前 pool,每创建一个 pool,就往栈里压一个，改变当前 pool 为新建的 pool,然后，每次给 pool 发送 drain 消息，就弹出栈顶的 pool,改当前 pool 为栈里的下一个 pool。
  - NSAutoreleasePool 中还提到，每一个线程都会维护自己的 autoreleasepool 堆找，每一个 autoreleasepool 只对应\_个线程。
- NSAutoreleasePool 和 autoreleasepool 的区别
  - 当你使用 ARC,就必须将 NSAutoreleasePool 的地方换@autoreleasepool
  - 两者的作用时间不一样。AutoReleasePool 对象的写法作用于运行时，@autoreleasepool 作用于编译阶段。如果要启用 ARC 的话，在编译阶段就需要告诉编译器启用自动引用计数管理，而不能在运行 时动态添加。
  - autoreleased 对象是被添加到了当前最近的 autoreleasepool 中的，只有当这个 autoreleasepool 自身 drain 的时候，autoreleasepool 中的 autoreleased 对象才会被 release。这个对象的引用计数-1，变成了 0 该 autoreleased 对象最终被释放
  - 向一个对象发送-autorelease 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的找顶 next 指针指向的位置。
  - 自动释放池是 NSAutoreleasePool 的实例，其中包含了收到 autorelease 消息的对象。当一个自动 释放池自身被销毁（dealloc)时，它会给池中每一个对象发送一个 release 消息（如果你给一个对象多次发送 autorelease 消息，那么当自动释放池销毁时，这个对象也会收到同样数目的 release 消息）
- autorelease 作用：

  - 对象执行 autorelease 方法时会将对象添加到自动释放池中
  - 当自动释放池销毁时自动释放池中所有对象作 release 操作
  - 对象执行 autorelease 方法后自身引用计数器不会改变，而且会返回对象本身
  - autorelease 实际上只是把对象 release 的调用延迟了，对于对象的 autorelease 系统只是把 当前对象放入了当前对应的 autorelease pool 中，当该 pool 被释放时（[pool drain])，该 pool 中的所有对象会被调用 Release,从而释放使用的内存。这个可以说是 autorelease 的 优点，因为无需我们再关注他的引用计数，直接交给系统来做！
  - @autoreleasepool
    - 自己开启一个线程，你需要创建自己的自动释放池块。如果你的应用或者线程长时间存活，并可能 产生大量的自动释放的对象；你应该手动创建自动释放池块；否则，自动释放的对象会积累并占用你的内存。当使用 ARC 来管理内存时，在线程中使用 for 大量分配对象而不用 autoreleasepool 则可能会造成内存泄露
    - 如果你创建的线程没有调用 Cacoa，你不需要使用自动释放池块。
  - 在 ARC 环境下，使用@autoreleasepool 可以释放池上下文，但是如下代码，@autoreleasepool 有必要吗？

  ```
  for (int i = 0; i < 1000000; i++) {
    @autoreleasepool {
      NSString *str = @"ABc";
      NSString *string = [str lowercasestring];
      string = [string stringByAppendingString:@"xyzM];
      NSLog(@,,%@"J string);
    }
  }
  ```

  有必要，在遇到需要大量创建对象的地方使用 autoreleasepool 可以加快对象释放的速度。

#### <a id="viewlayout" >view layout</a>

- 相关方法
  - -(CGSize)sizeThatFits:(CGSize)size
  - -(void)sizeToFit
  - -(void)layoutSubviews
  - -(void)layoutlfNeeded
  - -(void)setNeedsLayout
  - -(void)setNeedsDisplay
  - -(void)drawRect
- layoutSubviews 在以下情况下会被调用：
  - 1、 init 初始化不会触发 layoutSubviews，但是用 initWithFrame 初始化时，当 rect 的值不为 CGRectZero 时，也会触发
  - 2、 addSubview 会触发 layoutSubviews
  - 3、 设置 view 的 Frame 会触发 layoutSubviews,前提是 frame 的值设置前后发生了变化
  - 4、 滚动一个 UlScrollView 会触发 layoutSubviews
  - 5、 旋转 Screen 会触发父 UlView 上的 layoutSubviews 事件
  - 6、 改变一个 UIView 大小的时候也会触发父 UlView 上的 layoutSubviews 事件
- layoutSubviews,当我们在某个类的内部调整子视图位置时，需要调用。
  反过来的意思就是说：如果你想要在外部设置 subviews 的位置，就不要重写。
- 刷新子对象布局
  - -layoutSubviews:默认没有做任何事情，需要子类进行重写
  - -setNeedsLayout:标记为需要重新布局，异步调用 layoutlfNeeded 刷新布局，不立即刷新，但 layoutSubviews—定会被调用
  - -layoutlfNeeded:如果有需要刷新的标记，立即调用 layoutSubviews 进行布局（如果没有标记， 不会调用 layoutSubviews)
  - 注：setNeedsLayout 方法并不会立即刷新，立即刷新需要调用 layoutlfNeeded 方法。
  - 如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutlfNeeded]，实现布局.
  - setNeedsLayout 在 receiver 标上一个需要被重新布局的标记，在系统 runloop 的下一个周期自动 调用 layoutSubviews
  - layoutlfNeeded UIKit 会判断该 receiver 是否需要 layout,遍历的不是 superview 链，应该是 subviews 链
  - 在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutlfNeeded]
- 重绘
  - -drawRect:(CGRect)rect:重写此方法，执行重绘任务
  - -setNeedsDisplay:标记为需要重绘，异步调用 drawRect
  - -setNeedsDisplaylnRect: (CGRect)invalidRect:标记为需要局部重绘
  - sizeToFit 会自动调用 sizeThatFits 方法； sizeToFit 不应该在子类中被重写，应该重写 sizeThatFits sizeThatFits 传入的参数是 receiver 当前的 size,返回一个适合的 size sizeToFit 可以被手动直接调用
  - sizeToFit 和 sizeThatFits 方法都没有递归，对 subviews 也不负责，只负责自己
  - layoutSubviews 对 subviews 重亲斤布局 layoutSubviews 方法调用先于 drawRect
  - drawRect 是对 receiver 的重绘，能获得 context
  - setNeedDisplay 在 receiver 标上\_个需要被重新绘图的标记，在下一个 draw 周期自动重绘， iphone device 的刷新频率是 60hz,也就是 1/60 秒后重绘
  - setNeedsDisplay 该方法在调用时，会自动调用 drawRect 方法。drawRect 方法主要用来画图
- 总结  
  当需要刷新布局时，用 setNeedsLayOut 方法；当需要重新绘画时，调用 setNeedsDisplay 方法

#### <a id="内存分区情况" >简述内存分区情况</a>

- 代码区：存放函数二进制代码
- 数据区：系统运行时申请内存并初始化，系统退出时由系统释放，存放全局变量、静态变量、常量
- 堆区：通过 malloc 等函数或 new 等动态申请到的，需手动申请和释放
- 栈区：函数模块内申请，函数结束时由系统自动释放，存放局部变量、函数参数

#### <a id="各属性作用2222" >各属性作用</a>

- readwrite:可读可写，需要生成 getter、setter 方法
- readonly:只读，只生成 getter,不会生成 setter,不希望属性在类外部被更改
- assign:赋值，setter 方法将传入的参数赋值给实例变量；仅设置变量时，assign 用于基本数 据类型
- retain:表示持有特性，setter 方法将传入的参数先保留，在赋值，传入参数的引用计数会+1
- copy:表示赋值特性，setter 方法将传入的对象复制一份
- nonatomic:非原子操作，决定编译器生成的 setter、getter 是否是原子操作
- atomic:表示多线程安全，一般使用 nonatomic

#### <a id="简述 Notification、KVC、KVO、delegate?区别？" >简述 Notification、KVC、KVO、delegate?区别？</a>

- KVO: —对多，观察者模式，键值观察机制，提供了观察某一属性变化的方法，极大简化了代码
- KVC:键值编码，一个对象在调用 setValue
  - 检查是否存在相应 key 的 set 方法，存在就调用 set 方法
  - set 方法不存在，就查找\_key 的成员变量是否存在，存在就直接赋值
  - 如果\_key 没找到，就查找相同名称的 key,存在就赋值
  - 如果都没有找到，就调用 valueForllndefinedKey 和 setValue:forUndefinedKey
- delegate:发送者和接收者的关系是直接、一对一的关系
- Notification:观察者模式，发送者和接收者的关系是间接、多对多的关系
- 区别：
  - delegate 的效率比 Notification 高
  - delegate 比 Notification 更直接，需要关注返回值，常带有 should 关键词；Notification 不关心结果，常带有 did 关键词
  - 两个模块之间的联系不是很紧密，就用 Notification 传值，比如多线程之间的传值
  - KVO 容易实现两个对象的同步，比如 Model 和 View 的同步

#### <a id="id和nil代表什么" >id 和 nil 代表什么</a>

- id 类型的指针可以指向任何 0C 对象
- nil 代表空值（空指针的值，0)

#### <a id="nil、Nil、NULL、NSNull" >nil、Nil、NULL、NSNull</a>

- oc 中
  - nil、Nil、NULL 都表示（void \*)0
  - NSNull 继承于 NSObject，很特殊的类，表示是空，什么也不存储，但它却是对象，只是一个占 位对象。使用场景：比如服务端接口让传空，NSDictionary \*params = @{@“argl” ： @ffvaluel”，@“arg2” ： arg2.isEmpty ? [NSNull null] : arg2};
- 区别
  - NULL 是宏，是对于 C 语言指针而使用的，表示空指针
  - nil 是宏，是对于 0C 中的对象而使用的，表示对象为空
  - Nil 是宏，是对于 0C 中的类而使用的，表示类指向空
  - NSNull 是类类型，是用于表示空的占位对象，于]S 或服务端的 null 类似的含义

#### <a id="向一个nil对象发送消息会发生什么？" >向一个 nil 对象发送消息会发生什么？</a>

- 向 nil 发送消息是完全有效的 一 只是在运行时不会有任何作用
- 如果一个方法返回值是一个对象，那么发送给 nil 的消息将返回 0(nil)
- 如果方法返回值为指针类型，其指针大小为小于或等于 sizeof(void \*)，float、double、 long double、long long 的整型标量，发送给 nil 的消息将返回 0
- 如果方法返回值为结构体，发送给 nil 的消息将返回 0，结构体中各个字段的值也都是 0

#### <a id="self区别" >self. 和 self-> 的区别</a>

- self. 是调用 getter 或 setter 方法
- self 是当前本身，是一个指向当前对象的指针
- self-> 是直接访问成员变量

#### <a id="的私有属性" >如何访问并修改一个类的私有属性</a>

- 通过 KVC
- 通过 runtime 访问并修改

#### <a id="如何为class定义一个对外只读、对内可读写的属性" >如何为 class 定义一个对外只读、对内可读写的属性</a>

在头文件.h 中将属性定义为 readonly,在.m 中将原属性重新定义为 readwrite

#### <a id="0C中，meta-class指的是什么？" >0C 中，meta-class 指的是什么？</a>

meta-class 是 class 对像的类，为这个 class 类存储类方法，当一个类发送消息时，就去这个类对应的 meta-class 中查找那个消息，每个 class 都有不同的 meta-class，所有的 metaclass 都使用基类的 meta-class(假如类继承自 NSObject， 那么他所对应的 meta-class 也是 NSObject)作为他们的类。

#### <a id="NSString 用 copy 和 strong 的区别" >NSString 用 copy 和 strong 的区别</a>

NSString 为不可变字符串，用 copy 和 strong 都是只分配一次内存，但是如果用 copy,需要 先判断字符串是不是不可变字符串，如果是不可变字符串，就不再分配空间，如果是可变字符串才分配空间。如果程序中用到的 NSString 特别多，每一次都要先判断就会耗费性能，用 strong 就不会再判断了，所以不可变字符串可以直接用 strong。

#### <a id="一个对象的步骤" >创建一个对象的步骤</a>

- 内存空间
- 初始化参数
- 返回内存地址值

#### <a id="setter、getter" >setter、getter</a>

- setter 方法：为外界提供一个设置成员变量的方法，好处 一 不让数据暴露在外，保证数据安全性；对设置的数据过滤
- getter 方法：为调用者返回对象内部的成员变量
- 点语法的本质是对 setter 或 getter 方法的调用

#### <a id="id、instancetype是什么？区别？" >id、instancetype 是什么？区别？</a>

- id:万能指针，能作为参数、方法的返回类型
- instancetype:只能作为方法的返回类型，并且返回的类型是当前定义类的类类型

#### <a id="内存管理8888" >内存管理</a>

- ARC 所做的是在代码编译期自动在合适的位置插入 release 或 autorelease，只要没有强指针指向对象，对象就会被释放。ARC 中不能手动使用 NSZone，也不能调用父类的 dealloc
- 调用对象的 release 方法会销毁对象吗？
  - 不会，调用 release 只是将对象的引用计数器-1，当对象的引用计数器=0 时候会调用对象的 dealloc 方法才能释放对象的内存
- objc 使用什么机制管理对象内存？
  - 通过引用计数器（retainCount)的机制来决定对象是否需要释放。每次 RunLoop 完成一个循环 的时候，都会检查对象的 retainCount，如果 retainCount 为 0，说明该对象没有地方需要继续 使用了，就被释放了。
  - ARC 的判断准则：只要没有强指针指向对象，对象就会被释放
- 内存管理的范围？
  - 管理所有继承自 NSObject 的对象，对基本数据类型无效。是因为对象和其他基本数据类型在系统中存储的空间不一样，其他局部变量主要存储在栈区（因为基本数据类型占用的存储空间是固定的，一般存放于栈区），而对象存储于堆中，当代码块结束时，这个代码块中的所有局部变量会自动弹栈清空，指向对象的指针也会被回收，这时对象就没有指针指向了，但依然存在于堆中，造成 内存泄漏。
- 内存管理研究的对象：
  - 野指针：指针变量没有进行初始化或指向的空间已经被释放。
    - 使用野指针调用对象方法，会报异常，程序崩溃
    - 在调用完 release 后，把保存对象指针的地址清空，赋值为 nil,找 oc 中没有空指针异常 所以[nil retain]调用方法不会有异常
  - 内存泄漏
    - 如 Person \*p = [Person new];(对象提前赋值 nil 或清空）在找区的 p 已经被释放，而堆区 new 产生的对象还没有释放，就会造成内存泄漏
    - MRC 造成内存泄漏的情况：1、没有配对释放，不符合内存管理原则；2、对象提前赋值 nil 或 清空，导致 release 不起作用
  - 僵尸对象：堆中已经被释放的对象（retainCount=0)
  - 空指针：指针赋值为空，nil
- alloc、allocWithZone、new 时：该对象引用计数 +1;
- retain:手动为该对象引用计数+1;
- copy:对象引用计数+1; //注意：copy 的 oc 数据类型是否有 mutable,如有为深拷贝，新对象引用计数为 1;如果没有，为浅拷贝，引用计数+1 A
- mutableCopy:生成一个新对象，新对象引用计数+1;
- release:手动为该对象引用计数-1;
- autorelease:把该对象放入自动释放池，当自动释放池释放时，向池中的对象发送 release 消 息，其内的对象引用计数-1，只能释放自己拥有的对象；
- NSAutoreleasePool: NSAutoreleasePool 是通过接收对象向它发送的 autorelease 消息， 记录该对象的 release 消息，当自动释放池被销毁时，会自动向池中对象发送 release 消息。
- 对象如何加入池中：调用对象的 autorelease 方法
- 多次调用对象的 autorelease 方法会导致：野指针异常

#### <a id="KVC的底层实现？" >KVC 的底层实现？</a>

当一个对象调用 setValue 方法时，方法内部会做以下操作：

- 1、 检查是否存在对应 key 的 set 方法，如果存在，就调用 set 方法
- 2、 如果 set 方法不存在，就会查找与 key 相同名称并且带下划线的成员变量\_key，如果有，则直接给成员变量赋值
- 3、 如果没有找到\_key，就会查找相同名称的属性 key,如果有就直接赋值
- 4、 如果还没找到，则调用 valueForllndefinedKey:和 setValue:forUndefinedKey:
- 这些方法的默认实现都是抛出异常，可以根据需要重写他们

#### <a id="block的内存管理" >block 的内存管理</a>

无论 ARC 还是 MRC，只要 block 没有访问外部变量，block 始终在全局区

- MRC 下:
  - block 如果访问外部变量，block 在栈区
  - 不能对 block 使用 retain，否则不能保存在堆区
  - 只有使用 copy，才能放到堆区
- ARC 下
  - block 如果访问外部变量，block 在堆区
  - block 是一个对象，可以使用 copy 或 strong 修饰，最好是使用 copy

#### <a id="App的启动过程，从main说起" >App 的启动过程，从 main 说起</a>

App 启动分两类：1、有 stroyboard; 2、无 storyboard

- 有 stroyboard 情况下：
  - main 函数
  - UIApplicationMain
    - 创建 UIApplication 对象
    - 创建 UIApplication 的 delegate 对象
  - 根据 info, plist 获得 Main .storyboard 的文件名，加载 Main .storyboard
  - 创建 UlWindow
  - 创建和设置 UlWindow 的 rootViewController
  - 显示窗口 window
- 没有 stroyboard 情况下：
  - main 函数
  - UIApplicationMain
    - 创建 UIApplication 对象
    - 创建 UIApplication 的 delegate 对象
  - delegate 对象开始处理（监听）系统事件
    - 程序启动完毕时，调用 didFinishLaunching 方法
    - didFinishLaunching 方法中创建 UlWindow 设置 rootViewController 并显示窗口 window

#### <a id="tableview 的 cell 里面如何嵌套 collectionview" >tableview 的 cell 里面如何嵌套 collectionview</a>

用自定义的继承自 UITableViewCell 的类，在 initWithFrame 方法里面初始化自定义的继承自 UlCollectionView 的类

#### <a id="awakeFromNib 和 viewDidLoad 的区别" >awakeFromNib 和 viewDidLoad 的区别</a>

- awakeFromNib:当.nib 文件被加载的时候，会发送一个 awakeFromNib 消息到.nib 文件中 每个对象，每个对象都可以定义自己的 awakeFromNib 来响应这个消息。即通过.nib 文件创建 的 view 对象会执行 awakeFromNib
- viewDidLoad:当 view 被加载到内存就会执行，不管是通过 nib 还是代码形式

#### <a id="常见的Crash场景" >常见的 Crash 场景</a>

- 访问僵尸对象
- 访问了不存在的方法
- 数组越界
- 在定时器下一次回调前将定时器释放，会 crash

#### <a id="AFN断点续传" >AFN 断点续传</a>

- 检查服务端文件信息
- 检查本地文件
- 如果本地文件比服务端文件小，断点续传，利用 HTTP 请求头的 Range 实现断点续传
- 如果比服务端文件大，重新下载
- 如果和服务端文件一样，下载完成
- afn 默认超时时间是 60s

#### <a id="客户端的缓存机制8888" >客户端的缓存机制</a>

缓存分为：内存数据缓存、数据库缓存、文件缓存

- 每次想获取数据的时候，先检测内存中有无缓存
- 在检测本地有无缓存（数据库/文件）
- 最终发送网络请求
- 将服务端返回的数据进行缓存（内存、数据库、文件）

#### <a id="数据存储方式8888" >数据存储方式</a>

- 4 种数据持久化：属性列表（plist)、对象归档、sqlite、Core Data NSUserDefaults 用于存储配置信息
- 如何存储用户的一些敏感信息，如登录的 token?  
  使用 keychain 来存储，即钥匙串，使用 keychain 需要导入 Security 框架
- 使用 NSUserdefaults 时，如何处理布尔的默认值？（比如返回 N0,不知道是真的 N0,还是没有 设置过的 NO)

```
if ([ [NSUserDefaults standardllserDefaults]
  objectForKey :@"keyM] == nil) {
  NSL〇g(@ ”没有设置过");
}
```

#### <a id="App54545" >App 需要加载超大量的数据，给服务器发送请求，但服务器卡住了， 如何解决？</a>

- 设置请求超时
- 给用户提示请求超时
- 根据用户操作再次请求数据

#### <a id="网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？" >网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？</a>

利用字典（图片地址为 key,下载操作为 value)

#### <a id="异步调用555" >如何用 GCD 同步若干个异步调用？（如根据若干个 url 异步加载 多张图片，然后在都下载完成后合成一张整图）</a>

使用 dispatch_group_async 追加 block 到 global queue 中，这些 block 全部执行完毕，
就会执行 main dispatch queue 中的结束处理的 block。
代码如下：

```
dispatch_queue_t queue = dispatch_get_global_queue(0,0); dispatch_group_t group = dispatch_group_create();
//下图片1,放线程组中
dispatch_group_async(group,, queue, ^{
  NSURL *url = [NSURL URLWithString:@,,M]；
  NSData *imgDatal = [NSData dataWithContentsOfURL:url]; self.imgl = [Ullmage imageWithData:imgDatal];
})；
//下载图片2
dispatch_group_async(group,, queue, ^{
  NSURL *url = [NSURL URLWithString:@,,M]；
  NSData *imgData2 = [NSData dataWithContentsOfURL:url]; self.img2 = [Ullmage imageWithData:imgData2];
});
//合并图片
dispatch_group_notify(group,, queue, ^{
  NSLog(@Mcombie——%@"J, [NSThread currentThread]); UIGraphicsBeginImageContext(CGSizelvlake(200J, 200));
  [self.imgl drawInRect:CGRectMake(0J 0j 200^ 100)]; self.imgl = nil;
  [self.img2 drawInRect:CGRectMake(0, 100) 200) 100)]; self.img2 = nil;
  Ullmage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndlmageContext();
  dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@MUI——%§"j [NSThread currentThread]); //self.imgView.image = img;
  });
}); 

```

#### <a id="NSOperation、GCD、NSThread 的区别" >NSOperation、GCD、NSThread 的区别</a>

NSOperation 与 GCD 的区别：

- GCD：
  - GCD 是 iOS4.0 推出的，纯 c
  - GCD 是将任务（block)添加到队列（串行、并行、全局、主队列），并且以同步/异步的方式执行任务的函数
  - GCD 提供 NSOperation 不具备的功能:
    - 一次性执行
    - 延迟执行
    - 调度组
    - GCD 是严格的队列，先进先出 FIFO
- NSOperation:
  - NSOperation 是 iOS2.0 推出的，iOS4.0 以后又重写的
  - NSOperation 是将操作（异步任务）添加到队列（并发队列），就会执行指定的函数
  - NSOperation 提供的方便操作：
    - 最大并发数
    - 队列的暂停和继续 -取消所有的操作
    - 指定操作之间的依赖关系，可以让异步任务同步执行
    - 可以利用 KVO 监听一个 operation 是否完成
    - 可以设置 operation 的优先级，能使同一个并行队列中的任务区分先后地执行
    - 对 NSOperation 继承，在这之上添加成员变量和成员方法，提高代码的复用度
- GCD 与 NSThread 的区别：
  - NSThread 使用@selector 指定要执行的方法，代码分散
  - GCD 通过 block 指定要执行的方法，代码集中
  - GCD 不用管理线程的生命周期（创建、销毁、复用）
  - 如果要开多个线程 NSThread 必须实例化多个线程对象
  - NSThread 通过 performSelector 方法实现线程间通信
- 为什么要取消/恢复队列？
  - 一般内存警告后取消队列中的操作
  - 为了保证 scrollView 在滚动的时候流畅，通常在滚动开始时，暂停队列中的所有操作，滚动结 束后，恢复操作
- \_\_bridge :用于 Foundation 和 Core Fundation 之间数据的桥接

#### <a id="是否可以把比较耗时的操作放在NSNotificationCenter中" >是否可以把比较耗时的操作放在 NSNotificationCenter 中</a>

- 如果在异步线程发的通知，可以执行耗时的操作
- 如果在主线程发的通知，则不可以执行耗时的操作

#### <a id="利用预渲染加速iOS设备的图像显示" >利用预渲染加速 iOS 设备的图像显示</a>

```
static const CGSize imageSize = {100^ 100};

- (void)awakeFromNib {
  if	(!self.image) {
    self.image = [Ullmage imageNamedrandom.jpg"];
    if (NULL != UIGraphicsBeginlmageContextWithOptions) {

      UIGraphicsBeginImageContextlAlithOptions(imageSize^ YES, 0)；
    } else {
      UIGraphicsBeginImageContext(imageSize);
      [image drawInRect:imageRect];
      self.image = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndlmageContext();
    }
  }
}

```

- 这里需要判断一下 UIGraphicsBeginlmageContextWithOptions 是否为 NULL，因为它 是 iOS 4.0 才加入的。
- 由于 JPEG 图像是不透明的，所以第二个参数就设为 YES。
- 第三个参数是缩放比例，iPhone 4 是 2.0，其他是 1.0。虽然这里可以用[UlScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了。

#### <a id="TableView中实现平滑滚动延迟加载图片" >TableView 中实现平滑滚动延迟加载图片</a>

利用 CFRunLoopMode 的特性，可以将图片的加载放到 NSDefaultRunLoopMode 的 mode 里，这样在滚动 UITrackingRunLoopMode 这个 mode 时不会被加载而影响到。主线程繁忙的时候 performSelector: withObject: afterDelay:会延后执行，所以在发生触摸或是视图还在滚动时这个方法不会运行；

```
Ullmage \*downloadedImage = …；
[self.avatarlmageView performSelector:@selector(setImage:) withObject:downloadedlmage afterDelay:0
inModes:@[NSDefaultRunLoopMode]];
```

masonry 进行 label 的多行显示

#### <a id="masonry 进行 label 的多行显示" >masonry 进行 label 的多行显示</a>

注意：使用 masonry 进行 label 的多行显示设置时，主要是如下两个参数的设置

- 1、 @property(nonatomic)CGFloat preferredMaxLayoutWidth
- 2、 - (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis: (UILayoutConstraintAxis)axis
