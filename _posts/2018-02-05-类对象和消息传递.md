---
layout: post
title: '类对象和消息传递'
date: 2018-02-05
author: 李大鹏
cover: ''
tags: iOS Runtime
---

#### 1. 对象、类对象、原类对象

- 类对象存储实例方法列表等信息
- 元类对象存储类方法列表等信息
  ![](http://files.pandaleo.cn/d0ecd785f8d74ea94a23ae94d8182d78.png)
  - Root class，根类，没有父类，指向 nil
- 实例对象可以通过 isa 找到类对象，类对象存储实例方法列表等信息，类对象通过 isa 找到元类对象，从而访问元类对象存储的类方法列表等信息。
- 类对象和元类对象都是 objc_class 数据结构，都继承了 NSObject，所以可以通过 isa 指针查找。
- 任何元类指针对象都指向根元类对象，元类对象的 isa 指针指向自己。
- 如果调用类方法没有对应的实现，但是有同名的实例的方法，是否会发生崩溃？会不会产生实际的调用？回答如下。
- 根元类对象的 superclass 指针指向根类对象。调用类方法不存在的情况下，由于 Root class（meta） 的 isa 指针指向根类对象，会查找实例对象方法并调用。
- 消息传递过程：调用实例方法时，先通过 isa 找到类对象的方法列表，查找方法实现，没有时顺次查找父类对象方法列表，最后到根类。如果没有找到，会转到消息转发流程。类方法类似，区别在于最后的根元类对象找不到会根据 isa 指针查找根类对象。

#### 2. 消息传递

![](http://files.pandaleo.cn/9358bd2e0b4ec6c5c31747efbfd138d3.png)
两次打印都是 Phone

```
void objc_msgSend(void /* id self, SEL op, … */)
```

![](http://files.pandaleo.cn/fa53d1012e0ea7a39c0c42ac693480aa.png)

- 转化为函数调用
- self，消息传递的接收者
- @selector(class)，消息传递的消息名称（选择器）

```
void objc_msgSendSuper(void /* struct objc_super *super, SEL op, …*/)
```

- objc_super
  - super，编译器关键字，经过编译器编译后会解析成 objc_super 类型的结构体指针
  - receiver，当前对象，super 时 Phone，当前对象时 mobile，所以当前对象是 Phone
  - 虽然从传递的时结构体，但是消息的接收者仍然是当前对象

![](http://files.pandaleo.cn/013ec9212a419b944fa7f955108bd6d7.png)

- super 中包含的 receiver 是 self，即当前对象

#### 3. 消息传递过程

![](http://files.pandaleo.cn/97c4810c40c7feb71f5b1eb6fa66e465.png)

- 调用方法时，先查找缓存，找到后通过函数指针调用函数，完成消息传递
- 缓存未命中，根据当前实例的 isa 指针，查找当前类对象的方法列表，找到后通过函数指针调用函数，完成消息传递
- 方法列表未命中，通过当前类对象的 superClass 指针，查找父类的方法列表，如果未查到，会根据父类的 superClass 指针往上查找，直到 nil 为止。查到后通过函数指针调用函数，完成消息传递。
- 如果找到根类（Object）对象，仍未找到方法实现，会进入到消息转发流程，结束消息传递过程。

#### 4. 缓存查找

- 例：给定值是 SEL，目标值是对应 bucket_t 中的 IMP
  ![](http://files.pandaleo.cn/a581ec9f9b6363c8f358b6d58041ea56.png)

  - 根据方法选择器 SEL，通过函数映射出对应的 bucket_t 在数组中的位置。
  - 哈希查找，通过给定值，经过哈希函数算法计算出的值，就是给定值在对应数组中的索引位置
  - f(key) 选择器因子和对应的 mask 做位与运算，计算对应的 bucket_t 在数组中的索引位置，mask 时 bucket_t 的成员你变量。
  - 查找到选择器因子对应的 bucket_t 之后，提取对应的 IMP 函数指针，返回给调用方

#### 5. 当前类中查找

- 对于已排序好的列表，采用二分法查找算法查找方法对应执行函数。
- 对于没有排序的列表，采用一般遍历查找方法对应执行函数。

#### 6. 父类逐级查找

![](http://files.pandaleo.cn/0b1112a61f79a2cb7445337bcd12f85e.png)

- 通过当前类对象的 superclass 成员变量访问父类
- 将当前类转移到父类时，要判断父类是否为空，空时结束，进入消息转发
- 如果不为空，在父类方法缓存中查找方法实现，找到结束
- 没有找到，遍历当前类的方法列表，找到结束
- 未找到，继续逐级向上查找，重复第 2 步。

#### 7. 消息转发流程

![](http://files.pandaleo.cn/fc48226ba969aebd79df0c54a62f6cb4.png)

- resolveInstanceMethod，参数：方法选择器，返回 Bool 类型，是否要解决当前实例方法的实现，类方法。返回 YES，通知系统消息已处理，结束消息转发流程。
- 返回 NO，回调 forwardingTargetForSelector:，参数：方法选择器 SEL 类型，返回值 id，告诉系统实例方法调用由哪个对象处理。如果指定了转发目标，系统会将消息转发给转发目标，结束消息转发流程。
- 返回 nil，最后一次机会，调用 methodSignatureForSelector: ，参数：方法选择器 SEL 类型，返回值 methodSignature 类型的对象，包含方法选择器返回值类型、参数个数和参数类型的封装。返回方法签名时，系统会调用 forwardInvocation: ，如果 forwardInvocation: 能够处理消息，则消息转发流程结束。
- 返回 nil，或 forwardInvocation: 没法处理，会标记消息无法处理，出现 crash，未识别选择器。
