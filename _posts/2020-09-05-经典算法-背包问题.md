---
layout: post
title: '经典算法-背包问题'
date: 2017-09-05
author: 李大鹏
cover: ''
tags: 算法
---

#### 1. 题目描述

- 物品编号 1 2 3 4
- 物品体积 2 3 4 5
- 物品价值 3 4 5 6

#### 2. 表格分析

| 容量\编号 | 0   | 1   | 2   | 3   | 4   |
| --------- | --- | --- | --- | --- | --- |
| 0         | 0   | 0   | 0   | 0   | 0   |
| 1         | 0   | 0   | 0   | 0   | 0   |
| 2         | 0   | 3   | 3   | 3   | 3   |
| 3         | 0   | 3   | 4   | 4   | 4   |
| 4         | 0   | 3   | 4   | 5   | 0   |
| 5         | 0   | 3   | 7   | 7   | 7   |
| 6         | 0   | 3   | 7   | 8   | 8   |
| 7         | 0   | 3   | 7   | 9   | 9   |
| 8         | 0   | 3   | 7   | 9   | 10  |

#### 3. 解法归纳：

- 如果装不下当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。
- 如果装得下物品。

  - 假设 1：装当前物品，再给当前物品预留了响应空间的情况下，前 n-1 个物品的最佳组合加上当前物品的价值就是总价值；
  - 假设 2：不装当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。
  - 选取假设 1 和假设 2 中较大的价值，为当前最佳组合的价值。

- 回溯归纳：  
  从表的右下角开始回溯，如果发现前 n 个物品最佳组合的价值和前 n-1 个物品最佳组合的价值一样，说明第 n 个物品没有被装入。否则，第 n 个物品被装入。

#### 4. 代码：<main.cpp>

```
#include <iostream>
using namespace std;
int weight[5] = { 0, 2, 3, 4, 5 };
int value[5] = { 0, 3, 4, 5, 6 };
ind dp[5][9] = {0};
int object[5];
void Dynamic() { // 动态规划找到背包所能装下最大价值
	for (int i = 1; i < 5; i++) { // j = 容量\编号 = i
		for(int j = 1;  j < 9; j++ {
			if(weight[i] > j) {
				dp[i][j] = dp[i-1][j];
			} else {
				dp[i][j] = max[dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
			}
		}
	}
}

void Find(int i,  int j) { // 回溯找到到底装了哪些物品

	if (i == 0) {
		for(int i = 0; i < 5; i++ {
			cout << object[i] << “ “;
		}
		return ;
	} else if(dp[i][j] == dp[i - 1][j]) {
		object[i] = 0;
		Find(i-1, j);
	} else if(dp[i][j] == dp[i-1][j-weight[i]] + value[i]) {
		object[i] = 1;
		Find(i - 1, j - weight[i]);
	}
}

```
